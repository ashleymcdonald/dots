(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(require('./../views/content_page.coffee')).initialize().render();


},{"./../views/content_page.coffee":44}],2:[function(require,module,exports){
(function (global){
var $, Handlebars, _;

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

Handlebars = require('hbsfy/runtime');

Handlebars.registerHelper('select', function(value, options) {
  return options.fn(this).replace(new RegExp("value=\"" + value + "\""), '$& selected=selected');
});

Handlebars.registerHelper('option', function(selectedValue, options) {
  var isMatch, selected, text, value;
  value = options.hash.value || this;
  text = options.hash.text || this;
  isMatch = (selectedValue != null ? selectedValue.toLowerCase() : void 0) === value.toLowerCase();
  selected = isMatch ? 'selected="selected"' : '';
  return new Handlebars.SafeString("<option value='" + value + "'    " + selected + ">" + text + "</option>");
});

Handlebars.registerHelper('ifDefined', function(value, options) {
  if (!_.isUndefined(value)) {
    return options.fn(this);
  }
});

Handlebars.registerHelper('ifEqual', function(v1, v2, options) {
  if (v1 === v2) {
    return options.fn(this);
  }
});


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"hbsfy/runtime":162}],3:[function(require,module,exports){
var Handlebars;

Handlebars = require('hbsfy/runtime');

Handlebars.registerPartial('page-info-icon', require('./../../templates/partials/page_info_icon.hbs'));

Handlebars.registerPartial('highlight-icon', require('./../../templates/partials/highlight_icon.hbs'));

Handlebars.registerPartial('locked-icon', require('./../../templates/partials/locked_icon.hbs'));

Handlebars.registerPartial('settings-icon', require('./../../templates/partials/settings_icon.hbs'));

Handlebars.registerPartial('dock-icon', require('./../../templates/partials/dock_icon.hbs'));

Handlebars.registerPartial('close-icon', require('./../../templates/partials/close_icon.hbs'));

Handlebars.registerPartial('ose-icon', require('./../../templates/partials/ose_icon.hbs'));

Handlebars.registerPartial('export-icon', require('./../../templates/partials/export_icon.hbs'));


},{"./../../templates/partials/close_icon.hbs":93,"./../../templates/partials/dock_icon.hbs":94,"./../../templates/partials/export_icon.hbs":95,"./../../templates/partials/highlight_icon.hbs":96,"./../../templates/partials/locked_icon.hbs":97,"./../../templates/partials/ose_icon.hbs":98,"./../../templates/partials/page_info_icon.hbs":99,"./../../templates/partials/settings_icon.hbs":100,"hbsfy/runtime":162}],4:[function(require,module,exports){
(function (global){
var Analytics, Browser, Mixpanel, Model, Page, Settings, User, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

Model = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null).Model;

Mixpanel = require('mixpanel');

Settings = require('./settings.coffee');

Page = require('./page.coffee');

User = require('./user.coffee');

Browser = require('./browser.coffee');

module.exports = Analytics = (function(_super) {
  __extends(Analytics, _super);

  function Analytics() {
    _ref = Analytics.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  Analytics.analytics = null;

  Analytics.getInstance = function() {
    return this.analytics != null ? this.analytics : this.analytics = new Analytics;
  };

  Analytics.prototype.ACTIVE_USER_THROTTLE_MS = 24 * 60 * 60 * 1000;

  Analytics.prototype.settings = null;

  Analytics.prototype.user = null;

  Analytics.prototype.eventQueue = [];

  Analytics.prototype._mixpanel = null;

  Analytics.prototype.initialize = function() {
    this.settings = Settings.getInstance();
    this.user = User.getInstance();
    this.listenTo(this.settings, 'change:mixpanelId', this.submitQueuedEvents);
    this.listenTo(this.user, 'change:isPro', this.updatePerson);
    return this.listenTo(this.settings, 'change:isMozbarOn change:isButtonOn', this.updatePerson);
  };

  Analytics.prototype.mixpanel = function() {
    return this._mixpanel != null ? this._mixpanel : this._mixpanel = Mixpanel.init('654003c6ddd03e88764138e600453a67', {
      request_options: {
        scheme: 'https'
      }
    });
  };

  Analytics.prototype.trackEvent = function(name, extraAttrs) {
    var attrs;
    attrs = this.getEventAttributes();
    if (!attrs.distinct_id) {
      this.eventQueue.push({
        name: name,
        attrs: extraAttrs
      });
      return;
    }
    if (extraAttrs) {
      attrs = _.extend(extraAttrs, attrs);
    }
    return this.mixpanel().track(name, attrs);
  };

  Analytics.prototype.trackNewInstall = function() {
    console.log('tracking new install!');
    return this.trackEvent('New Install');
  };

  Analytics.prototype.trackActiveUser = function() {
    var lastActiveUser;
    this.updatePerson();
    lastActiveUser = this.settings.get('lastMixpanelActiveUser');
    if (Date.now() - lastActiveUser < this.ACTIVE_USER_THROTTLE_MS) {
      return;
    }
    this.trackEvent('Active User');
    return this.settings.set('lastMixpanelActiveUser', Date.now());
  };

  Analytics.prototype.trackPanelView = function(panel) {
    return this.trackEvent('Panel View', {
      panel: panel,
      viewedOnboarding: this.hasUserSeenHighlight('show-info-panel')
    });
  };

  Analytics.prototype.trackToggleDockPosition = function() {
    this.trackEvent('Toggle Dock Position');
    return this.mixpanel().people.increment(this.settings.get('mixpanelId'), 'Toggle Dock Position');
  };

  Analytics.prototype.trackKeywordDifficulty = function() {
    this.trackEvent('Keyword Difficulty', {
      viewedOnboarding: this.hasUserSeenHighlight('activate-keyword-difficulty')
    });
    return this.mixpanel().people.increment(this.settings.get('mixpanelId'), 'Keyword Difficulty');
  };

  Analytics.prototype.trackExport = function() {
    this.trackEvent('SERP Export', {
      viewedOnboarding: this.hasUserSeenHighlight('export')
    });
    return this.mixpanel().people.increment(this.settings.get('mixpanelId'), 'SERP Export');
  };

  Analytics.prototype.trackInitiateOnboarding = function() {
    return this.trackEvent('Initiated Onboarding via Help');
  };

  Analytics.prototype.trackCloseOnboarding = function() {
    return this.trackEvent('Closed Onboarding');
  };

  Analytics.prototype.trackOnboardingComplete = function() {
    return this.trackEvent('Completed Onobarding');
  };

  Analytics.prototype.getEventAttributes = function() {
    return {
      distinct_id: this.settings.get('mixpanelId'),
      type: Page.isSerp() ? 'serp' : 'non-serp',
      isPro: this.getUserType(),
      isLightTheme: this.settings.get('isLightTheme'),
      isDockedOnBottom: this.settings.get('isDockedOnBottom'),
      browser: Browser.browserName(),
      os: Browser.osName(),
      pageOnboardingStep: this.settings.get('onboarding').pageStep,
      serpOnboardingStep: this.settings.get('onboarding').serpStep
    };
  };

  Analytics.prototype.updatePerson = function() {
    if (!this.settings.get('isButtonOn')) {
      return;
    }
    return this.mixpanel().people.set(this.settings.get('mixpanelId'), {
      type: this.getUserType(),
      isMozbarOn: this.settings.get('isMozbarOn'),
      isDockedOnBottom: this.settings.get('isDockedOnBottom'),
      $last_name: this.user.get('display_name'),
      browser: Browser.browserName(),
      os: Browser.osName(),
      pageOnboardingStep: this.settings.get('onboarding').pageStep,
      serpOnboardingStep: this.settings.get('onboarding').serpStep,
      extensionVersion: this.settings.get('extensionVersion')
    });
  };

  Analytics.prototype.getUserType = function() {
    if (this.user.get('isPro')) {
      return 'paid';
    } else {
      return 'free';
    }
  };

  Analytics.prototype.hasUserSeenHighlight = function(highlight) {
    var visited;
    visited = this.settings.get('onboarding').viewedHighlights;
    return visited.indexOf(highlight) !== -1;
  };

  Analytics.prototype.submitQueuedEvents = function() {
    var e, _i, _len, _ref1;
    if (!this.settings.get('mixpanelId')) {
      return;
    }
    _ref1 = this.eventQueue;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      e = _ref1[_i];
      this.trackEvent(e.name, e.attrs);
    }
    return this.eventQueue = [];
  };

  return Analytics;

})(Model);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./browser.coffee":5,"./page.coffee":18,"./settings.coffee":29,"./user.coffee":35,"mixpanel":163}],5:[function(require,module,exports){
(function (global){
var $, Browser, pageMod;

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

pageMod = require('sdk/page-mod');

module.exports = Browser = (function() {
  function Browser() {}

  Browser.get = function(file, callback) {
    if (typeof chrome !== "undefined" && chrome !== null) {
      $.get(chrome.extension.getURL(file), function(contents) {
        return callback.call(this, contents);
      });
      return;
    }
    return callback.call(this, self.options[file]);
  };

  Browser.browserName = function() {
    if (navigator.userAgent.indexOf('Chrome') !== -1) {
      return 'chrome';
    }
    if (navigator.userAgent.indexOf('Firefox') !== -1) {
      return 'firefox';
    }
    return 'unknown';
  };

  Browser.osName = function() {
    if (navigator.userAgent.indexOf('Macintosh') !== -1) {
      return 'os x';
    }
    if (navigator.userAgent.indexOf('Windows') !== -1) {
      return 'windows';
    }
    if (navigator.userAgent.indexOf('Linux') !== -1) {
      return 'linux';
    }
    return 'unknown';
  };

  Browser.isChrome = function() {
    return (typeof chrome !== "undefined" && chrome !== null ? chrome.runtime : void 0) != null;
  };

  Browser.isFirefox = function() {
    return (pageMod.PageMod != null) || ((typeof self !== "undefined" && self !== null ? self.port : void 0) != null);
  };

  Browser.sendMessage = function(message, data, response) {
    var _ref;
    if (typeof chrome !== "undefined" && chrome !== null) {
      if ((_ref = chrome.runtime) != null) {
        _ref.sendMessage({
          type: message,
          data: data
        }, response);
      }
    }
    if (this.isFirefox()) {
      if (response != null) {
        self.port.once("" + message + ":response", function(data) {
          return response(data);
        });
      }
      return self.port.emit(message, data);
    }
  };

  return Browser;

})();


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"sdk/page-mod":113}],6:[function(require,module,exports){
var ButtonMetrics, CACHE_DAYS, Page, UrlMetrics, mozCols, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Page = require('./page.coffee');

UrlMetrics = require('./url_metrics.coffee');

mozCols = require('./moz_cols.coffee');

CACHE_DAYS = 1;

module.exports = ButtonMetrics = (function(_super) {
  __extends(ButtonMetrics, _super);

  function ButtonMetrics() {
    _ref = ButtonMetrics.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  ButtonMetrics.prototype.initialize = function() {
    var _this = this;
    this.once('sync', function() {
      _this.isFetching = false;
      return _this.setCachedValue(Page.hostname(), _this.get('nicePda'));
    });
    return ButtonMetrics.__super__.initialize.apply(this, arguments);
  };

  ButtonMetrics.prototype.fetch = function(options) {
    var _this = this;
    if (this.isFetching || this.get('nicePda')) {
      return;
    }
    return this.getCachedValue(Page.hostname(), function(value) {
      if (value != null ? value.nicePda : void 0) {
        _this.set({
          nicePda: value.nicePda
        });
        return;
      }
      return ButtonMetrics.__super__.fetch.apply(_this, arguments);
    });
  };

  ButtonMetrics.prototype.getCols = function() {
    return mozCols.getBits(['pda']);
  };

  ButtonMetrics.prototype.getCachedValue = function(key, callback) {
    return typeof chrome !== "undefined" && chrome !== null ? chrome.storage.local.get('buttonMetrics', function(results) {
      var _ref1, _ref2;
      if (!(Date.now() < (results != null ? (_ref1 = results.buttonMetrics) != null ? (_ref2 = _ref1[key]) != null ? _ref2.expires : void 0 : void 0 : void 0))) {
        return callback(null);
      }
      return callback(results.buttonMetrics[key].value);
    }) : void 0;
  };

  ButtonMetrics.prototype.setCachedValue = function(key, value) {
    return typeof chrome !== "undefined" && chrome !== null ? chrome.storage.local.get('buttonMetrics', function(results) {
      var buttonMetrics, data, now, _i, _len;
      now = new Date();
      buttonMetrics = (results != null ? results.buttonMetrics : void 0) || {};
      for (data = _i = 0, _len = buttonMetrics.length; _i < _len; data = ++_i) {
        key = buttonMetrics[data];
        if (now > data.expires) {
          delete buttonMetrics[key];
        }
      }
      buttonMetrics[key] = {
        value: {
          nicePda: value
        },
        expires: now.setDate(now.getDate() + CACHE_DAYS)
      };
      return typeof chrome !== "undefined" && chrome !== null ? chrome.storage.local.set({
        buttonMetrics: buttonMetrics
      }) : void 0;
    }) : void 0;
  };

  return ButtonMetrics;

})(UrlMetrics);


},{"./moz_cols.coffee":15,"./page.coffee":18,"./url_metrics.coffee":34}],7:[function(require,module,exports){
(function (global){
var Backbone, Cities, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Backbone = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null);

module.exports = Cities = (function(_super) {
  __extends(Cities, _super);

  function Cities() {
    _ref = Cities.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  Cities.prototype.region = '';

  Cities.prototype.url = function() {
    return "https://d2eeipcrcdle6.cloudfront.net/mozbar/cities/" + this.region + ".json";
  };

  Cities.prototype.parse = function(resp) {
    var city, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = resp.length; _i < _len; _i++) {
      city = resp[_i];
      _results.push({
        name: city
      });
    }
    return _results;
  };

  return Cities;

})(Backbone.Collection);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],8:[function(require,module,exports){
(function (global){
var FacebookStats, Model, Page, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

Model = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null).Model;

Page = require('./page.coffee');

module.exports = FacebookStats = (function(_super) {
  __extends(FacebookStats, _super);

  function FacebookStats() {
    _ref = FacebookStats.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  FacebookStats.prototype.defaults = {
    site: 'facebook',
    tooltip: 'Facebook Activity',
    count: '--'
  };

  FacebookStats.prototype.url = function() {
    return "https://api.facebook.com/method/links.getStats?" + ("urls=" + (Page.href()) + "&format=json");
  };

  FacebookStats.prototype.parse = function(resp) {
    var _ref1;
    return _.extend(resp[0] || {}, {
      count: (_ref1 = resp[0]) != null ? _ref1.total_count.toLocaleString() : void 0
    });
  };

  FacebookStats.prototype.validate = function(attrs) {
    if (attrs.count === this.defaults.count) {
      return 'Data not loaded!';
    }
  };

  return FacebookStats;

})(Model);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./page.coffee":18}],9:[function(require,module,exports){
(function (global){
var Geolocation, Model, Page, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

Model = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null).Model;

Page = require('./page.coffee');

module.exports = Geolocation = (function(_super) {
  __extends(Geolocation, _super);

  function Geolocation() {
    _ref = Geolocation.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  Geolocation.instance = null;

  Geolocation.getInstance = function() {
    return this.instance != null ? this.instance : this.instance = new Geolocation;
  };

  Geolocation.prototype.defaults = {
    hostname: Page.hostname(),
    ip: null,
    country_code: null,
    country_name: null
  };

  Geolocation.prototype.url = function() {
    return "//mozbar.moz.com/" + (this.get('hostname'));
  };

  Geolocation.prototype.validate = function(attrs) {
    if (_.isNull(attrs.ip)) {
      return 'Data not loaded!';
    }
  };

  return Geolocation;

})(Model);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./page.coffee":18}],10:[function(require,module,exports){
var GoogleDomains;

module.exports = GoogleDomains = (function() {
  function GoogleDomains() {}

  GoogleDomains.getDomain = function(country) {
    return this.domains[country] || ("http://www.google.com/search?cr=country" + country);
  };

  GoogleDomains.domains = {
    AF: "http://www.google.com.af/search?",
    DZ: "http://www.google.dz/search?",
    AS: "http://www.google.as/search?",
    AI: "http://www.google.com.ai/search?",
    AG: "http://www.google.com.ag/search?",
    AR: "http://www.google.com.ar/search?",
    AM: "http://www.google.am/search?",
    AU: "http://www.google.com.au/search?",
    AT: "http://www.google.at/search?",
    AZ: "http://www.google.az/search?",
    BS: "http://www.google.bs/search?",
    BH: "http://www.google.com.bh/search?",
    BD: "http://www.google.com.bd/search?",
    BY: "http://www.google.by/search?",
    BE: "http://www.google.be/search?",
    BZ: "http://www.google.com.bz/search?",
    BO: "http://www.google.com.bo/search?",
    BA: "http://www.google.ba/search?",
    BR: "http://www.google.com.br/search?",
    BN: "http://www.google.com.bn/search?",
    BG: "http://www.google.bg/search?",
    BI: "http://www.google.bi/search?",
    CA: "http://www.google.ca/search?",
    CL: "http://www.google.cl/search?",
    CN: "http://www.google.cn/search?",
    CO: "http://www.google.com.co/search?",
    CD: "http://www.google.cd/search?",
    CK: "http://www.google.co.ck/search?",
    CR: "http://www.google.co.cr/search?",
    HR: "http://www.google.hr/search?",
    CU: "http://www.google.com.cu/search?",
    CZ: "http://www.google.cz/search?",
    CI: "http://www.google.ci/search?",
    DK: "http://www.google.dk/search?",
    DM: "http://www.google.dm/search?",
    DO: "http://www.google.com.do/search?",
    EC: "http://www.google.com.ec/search?",
    EG: "http://www.google.com.eg/search?",
    SV: "http://www.google.com.sv/search?",
    EE: "http://www.google.ee/search?",
    FI: "http://www.google.fi/search?",
    FR: "http://www.google.fr/search?",
    GE: "http://www.google.ge/search?",
    DE: "http://www.google.de/search?",
    GH: "http://www.google.com.gh/search?",
    GI: "http://www.google.com.gi/search?",
    GR: "http://www.google.gr/search?",
    GT: "http://www.google.com.gt/search?",
    HN: "http://www.google.hn/search?",
    HK: "http://www.google.com.hk/search?",
    HU: "http://www.google.hu/search?",
    IS: "http://www.google.is/search?",
    IN: "http://www.google.in/search?",
    ID: "http://www.google.co.id/search?",
    IE: "http://www.google.ie/search?",
    IL: "http://www.google.co.il/search?",
    IT: "http://www.google.it/search?",
    JM: "http://www.google.com.jm/search?",
    JP: "http://www.google.co.jp/search?",
    JO: "http://www.google.jo/search?",
    KE: "http://www.google.kz/search?",
    KI: "http://www.google.co.ke/search?",
    KR: "http://www.google.co.kr/search?",
    LA: "http://www.google.la/search?",
    LV: "http://www.google.lv/search?",
    LB: "http://www.google.com.lb/search?",
    LS: "http://www.google.com.ly/search?",
    LI: "http://www.google.li/search?",
    LT: "http://www.google.lt/search?",
    LU: "http://www.google.lu/search?",
    MO: "http://www.google.mk/search?",
    MG: "http://www.google.com.my/search?",
    MV: "http://www.google.com.mt/search?",
    MH: "http://www.google.mu/search?",
    MX: "http://www.google.com.mx/search?",
    FM: "http://www.google.fm/search?",
    MD: "http://www.google.md/search?",
    MA: "http://www.google.co.ma/search?",
    NR: "http://www.google.nr/search?",
    NP: "http://www.google.com.np/search?",
    NL: "http://www.google.nl/search?",
    NZ: "http://www.google.co.nz/search?",
    NG: "http://www.google.com.ng/search?",
    NO: "http://www.google.no/search?",
    OM: "http://www.google.com.om/search?",
    PK: "http://www.google.com.pk/search?",
    PA: "http://www.google.com.pa/search?",
    PY: "http://www.google.com.py/search?",
    PE: "http://www.google.com.pe/search?",
    PH: "http://www.google.com.ph/search?",
    PL: "http://www.google.pl/search?",
    PT: "http://www.google.pt/search?",
    PR: "http://www.google.com.pr/search?",
    QA: "http://www.google.com.qa/search?",
    RO: "http://www.google.ro/search?",
    RU: "http://www.google.ru/search?",
    SH: "http://www.google.sh/search?",
    WS: "http://www.google.as/search?",
    SA: "http://www.google.com.sa/search?",
    SN: "http://www.google.sn/search?",
    YU: "http://www.google.rs/search?",
    SC: "http://www.google.sc/search?",
    SG: "http://www.google.com.sg/search?",
    SK: "http://www.google.sk/search?",
    SI: "http://www.google.si/search?",
    ZA: "http://www.google.co.za/search?",
    ES: "http://www.google.es/search?",
    LK: "http://www.google.lk/search?",
    SE: "http://www.google.se/search?",
    CH: "http://www.google.ch/search?",
    TW: "http://www.google.com.tw/search?",
    TH: "http://www.google.co.th/search?",
    TK: "http://www.google.tk/search?",
    TO: "http://www.google.to/search?",
    TT: "http://www.google.tt/search?",
    TN: "http://www.google.tn/search?",
    TR: "http://www.google.com.tr/search?",
    TM: "http://www.google.tm/search?",
    UA: "http://www.google.com.ua/search?",
    AE: "http://www.google.ae/search?",
    GB: "http://www.google.co.uk/search?",
    US: "http://www.google.com/search?gl=us",
    UY: "http://www.google.com.uy/search?",
    UZ: "http://www.google.co.uz/search?",
    VE: "http://www.google.co.ve/search?",
    VN: "http://www.google.com.vn/search?",
    ZM: "http://www.google.co.zm/search?",
    ZW: "http://www.google.co.zw/search?"
  };

  return GoogleDomains;

})();


},{}],11:[function(require,module,exports){
(function (global){
var GooglePlusStats, Model, Page, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

Model = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null).Model;

Page = require('./page.coffee');

module.exports = GooglePlusStats = (function(_super) {
  __extends(GooglePlusStats, _super);

  function GooglePlusStats() {
    _ref = GooglePlusStats.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  GooglePlusStats.prototype.defaults = {
    site: 'google-plus',
    tooltip: 'Google +',
    count: '--'
  };

  GooglePlusStats.prototype.url = function() {
    return "https://clients6.google.com/rpc";
  };

  GooglePlusStats.prototype.fetch = function(opts) {
    return GooglePlusStats.__super__.fetch.call(this, _.extend(opts || {}, {
      type: 'post',
      contentType: 'application/json-rpc',
      data: JSON.stringify({
        method: 'pos.plusones.get',
        id: 'p',
        jsonrpc: '2.0',
        key: 'p',
        apiVersion: 'v1',
        params: {
          nolog: true,
          id: Page.href(),
          source: 'widget',
          userId: '@viewer',
          groupId: '@self'
        }
      })
    }));
  };

  GooglePlusStats.prototype.parse = function(resp) {
    return {
      count: resp.result.metadata.globalCounts.count.toLocaleString()
    };
  };

  GooglePlusStats.prototype.validate = function(attrs) {
    if (attrs.count === this.defaults.count) {
      return 'Data not loaded!';
    }
  };

  return GooglePlusStats;

})(Model);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./page.coffee":18}],12:[function(require,module,exports){
(function (global){
var HttpStatusList, Model, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Model = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null).Model;

module.exports = HttpStatusList = (function(_super) {
  __extends(HttpStatusList, _super);

  function HttpStatusList() {
    _ref = HttpStatusList.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  HttpStatusList.prototype.defaults = {
    isOk: false,
    status: null,
    statusCode: null,
    url: null
  };

  HttpStatusList.prototype.initialize = function(attrs, options) {
    HttpStatusList.__super__.initialize.apply(this, arguments);
    this.updateAttributes();
    return this.listenTo(this, 'change', this.updateAttributes);
  };

  HttpStatusList.prototype.updateAttributes = function() {
    var code;
    code = this.get('status').match(/^HTTP\/\d+\.\d+ (\d+)/)[1];
    return this.set({
      isOk: code === '200',
      statusCode: code
    });
  };

  return HttpStatusList;

})(Model);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],13:[function(require,module,exports){
(function (global){
var Collection, HttpStatus, HttpStatusList, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Collection = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null).Collection;

HttpStatus = require('./http_status.coffee');

module.exports = HttpStatusList = (function(_super) {
  __extends(HttpStatusList, _super);

  function HttpStatusList() {
    _ref = HttpStatusList.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  HttpStatusList.prototype.model = HttpStatus;

  HttpStatusList.prototype.sync = function(method, model, options) {
    var _ref1;
    if (method !== 'read') {
      throw new Error('Not implemented');
    }
    return typeof chrome !== "undefined" && chrome !== null ? (_ref1 = chrome.runtime) != null ? _ref1.sendMessage({
      type: 'status-history'
    }, function(response) {
      return options.success.call(model, response);
    }) : void 0 : void 0;
  };

  HttpStatusList.prototype.isValid = function() {
    return this.length > 0;
  };

  return HttpStatusList;

})(Collection);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./http_status.coffee":12}],14:[function(require,module,exports){
(function (global){
var $, KeywordDifficulty, Model, Page, SerpResultsMetrics, User, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

Model = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null).Model;

Page = require('./page.coffee');

SerpResultsMetrics = require('./serp_results_metrics.coffee');

User = require('./user.coffee');

module.exports = KeywordDifficulty = (function(_super) {
  __extends(KeywordDifficulty, _super);

  function KeywordDifficulty() {
    _ref = KeywordDifficulty.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  KeywordDifficulty.prototype.defaults = {
    isLoaded: false,
    difficulty: '--',
    volume: '--',
    isPro: false
  };

  KeywordDifficulty.prototype.serpResultsMetrics = null;

  KeywordDifficulty.prototype.searchResultUrls = [];

  KeywordDifficulty.prototype.user = User.getInstance();

  KeywordDifficulty.prototype.initialize = function() {
    var _this = this;
    return this.user.on('change:isPro', function() {
      return _this.set({
        isPro: _this.user.get('isPro')
      });
    });
  };

  KeywordDifficulty.prototype.fetch = function() {
    this.serpResultsMetrics = SerpResultsMetrics.getInstance();
    this.listenTo(this.serpResultsMetrics, 'change', this.updateDifficulty);
    this.fetchDifficulty();
    return this.set({
      isLoaded: true,
      isPro: this.user.get('isPro')
    });
  };

  KeywordDifficulty.prototype.fetchDifficulty = function() {
    var start;
    start = Page.getStartIndex();
    if (start === 0 || start === 10) {
      this.addSearchResultUrls($(document));
    }
    if (start >= 10) {
      this.fetchSearchPage(0);
      if (start !== 10) {
        this.fetchSearchPage(10);
      }
    }
    if (start === 0 && this.searchResultUrls.length < 20) {
      this.fetchSearchPage(10);
      if (this.searchResultUrls.length < 10) {
        this.fetchSearchPage(20);
      }
    }
    return this.updateDifficulty();
  };

  KeywordDifficulty.prototype.updateDifficulty = function() {
    var metrics;
    if (!(this.searchResultUrls.length >= 20)) {
      return;
    }
    if (!this.serpResultsMetrics.isLoaded(this.searchResultUrls)) {
      return;
    }
    metrics = this.serpResultsMetrics.findMetricsByUrls(this.searchResultUrls);
    metrics = _.sortBy(metrics, function(model) {
      return model.get('upa') * -1;
    });
    return this.set({
      difficulty: metrics[5].get('niceUpa')
    });
  };

  KeywordDifficulty.prototype.fetchSearchPage = function(start) {
    var _this = this;
    return $.get("//www.google.com/search?q=" + (Page.getSearchTerm()) + "&start=" + start, function(results) {
      return _this.addSearchResultUrls($(results));
    });
  };

  KeywordDifficulty.prototype.addSearchResultUrls = function($doc) {
    var serpConfig,
      _this = this;
    serpConfig = Page.getSerpConfig();
    return $doc.find(serpConfig.selector).each(function(i, el) {
      var metrics, pageUrl;
      pageUrl = ($(el)).find(serpConfig.href).attr('href');
      _this.searchResultUrls.push(pageUrl);
      metrics = _this.serpResultsMetrics.getPageMetrics(pageUrl);
      if (!metrics.isValid()) {
        return metrics.fetch();
      }
    });
  };

  KeywordDifficulty.prototype.reset = function() {
    return this.set(_.extend(this.defaults, {
      isPro: this.user.get('isPro')
    }));
  };

  return KeywordDifficulty;

})(Model);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./page.coffee":18,"./serp_results_metrics.coffee":27,"./user.coffee":35}],15:[function(require,module,exports){
(function (global){
var _;

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

module.exports = {
  flags: {
    ut: 1,
    uu: 4,
    ufq: 8,
    upl: 16,
    ueid: 32,
    feid: 64,
    peid: 128,
    ujid: 256,
    uifq: 512,
    uipl: 1024,
    uid: 2048,
    fid: 4096,
    pid: 8192,
    umrp: 16384,
    umrr: 16384,
    fmrp: 32768,
    fmrr: 32768,
    pmrp: 65536,
    pmrr: 65536,
    utrp: 131072,
    utrr: 131072,
    ftrp: 262144,
    ftrr: 262144,
    ptrp: 524288,
    ptrr: 524288,
    uemrp: 1048576,
    uemrr: 1048576,
    fejp: 2097152,
    fejr: 2097152,
    pejp: 4194304,
    pejr: 4194304,
    fjp: 8388608,
    fjr: 8388608,
    pjp: 16777216,
    pjr: 16777216,
    us: 536870912,
    fuid: 4294967296,
    puid: 8589934592,
    fipl: 17179869184,
    upa: 34359738368,
    pda: 68719476736,
    ulc: 144115188075855872,
    fspsc: 67108864
  },
  getBits: function(cols) {
    var col, val, _i, _len, _ref;
    val = 0;
    _ref = _.uniq(cols);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      col = _ref[_i];
      val += this.flags[col];
    }
    return val;
  }
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],16:[function(require,module,exports){
(function (global){
var Analytics, Dispatcher, Model, Onboarding, Page, Settings, User, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Model = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null).Model;

Analytics = require('./analytics.coffee');

User = require('./user.coffee');

Page = require('./page.coffee');

Dispatcher = require('./../views/event_dispatcher.coffee');

Settings = require('./settings.coffee');

module.exports = Onboarding = (function(_super) {
  __extends(Onboarding, _super);

  function Onboarding() {
    _ref = Onboarding.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  Onboarding.onboarding = null;

  Onboarding.getInstance = function() {
    return this.onboarding != null ? this.onboarding : this.onboarding = new Onboarding;
  };

  Onboarding.prototype.settings = Settings.getInstance();

  Onboarding.prototype.defaults = {
    pageStep: null,
    serpStep: null,
    pageHighlights: [],
    serpHighlights: [],
    pageTourComplete: false,
    serpTourComplete: false,
    viewedHighlights: [],
    sharedHighlights: []
  };

  Onboarding.prototype.serpSteps = ['serp-hotspots', 'serp-page-intro-address-bar', 'complete'];

  Onboarding.prototype.pageSteps = ['page-hotspots', 'page-serp-intro-address-bar', 'complete'];

  Onboarding.prototype.serpHighlights = ['link-analysis', 'export', 'lock', 'activate-keyword-difficulty', 'search-profile'];

  Onboarding.prototype.pageHighlights = ['show-info-panel', 'show-links-panel'];

  Onboarding.prototype.sharedHighlights = ['settings', 'help', 'close'];

  Onboarding.prototype.initialize = function() {
    var _this = this;
    this.dispatcher = Dispatcher.getInstance();
    this.user = User.getInstance();
    this.listenTo(this.settings, 'change:onboarding', this.fetch);
    this.listenTo(this.dispatcher, 'onboarding:hide-highlight', this.hideHighlight);
    this.listenTo(this, 'change:pageStep change:serpStep', this.stepChanged);
    return this.listenTo(this, 'change:pageHighlights change:serpHighlights', function() {
      return _this.highlightsChanged();
    });
  };

  Onboarding.prototype.sync = function(method) {
    switch (method) {
      case 'create':
      case 'update':
      case 'patch':
        this.settings.set('onboarding', this.toJSON());
        return this.settings.save();
      case 'read':
        return this.set(this.settings.get('onboarding'));
      default:
        throw new Error("" + method + " not implemented.");
    }
  };

  Onboarding.prototype.nextStep = function() {
    var currentIndex, nextStep, setting, step, steps;
    if (Page.isSerp()) {
      setting = 'serpStep';
      steps = this.serpSteps;
    } else {
      setting = 'pageStep';
      steps = this.pageSteps;
    }
    step = this.get(setting);
    currentIndex = steps.indexOf(step);
    if (currentIndex === steps.length - 1) {
      return;
    }
    nextStep = steps[currentIndex + 1];
    if (nextStep === 'page-serp-intro-address-bar') {
      this.set({
        pageTourComplete: true
      });
      if (this.get('serpTourComplete')) {
        nextStep = 'complete';
      }
    }
    if (nextStep === 'serp-page-intro-address-bar') {
      this.set({
        serpTourComplete: true
      });
      if (this.get('pageTourComplete')) {
        nextStep = 'complete';
      }
    }
    this.set(setting, nextStep);
    if (this.get('pageStep') === 'complete' && this.get('pageTourComplete') && this.get('serpStep') === 'complete' && this.get('serpTourComplete')) {
      Analytics.getInstance().trackOnboardingComplete();
    }
    return this.save();
  };

  Onboarding.prototype.stepChanged = function() {
    var step;
    step = Page.isSerp() ? this.get('serpStep') : this.get('pageStep');
    this.updateAddressBarHighlight(step);
    if (this.get('serpStep') === 'intro' && this.get('pageStep') === 'intro') {
      return this.restart();
    }
  };

  Onboarding.prototype.highlightsChanged = function() {
    var highlights;
    highlights = this.get('serpHighlights');
    if (_.isEqual(highlights, ['activate-keyword-difficulty']) && !this.user.get('isPro')) {
      this.nextStep();
    }
    return this.dispatcher.trigger('onboardingHighlights:change');
  };

  Onboarding.prototype.updateAddressBarHighlight = function(step) {
    var show;
    show = /address-bar/.test(step) ? 'show' : 'hide';
    return this.dispatcher.trigger("address-bar-highlight:" + show);
  };

  Onboarding.prototype.getHighlights = function() {
    var name;
    name = Page.isSerp() ? 'serp' : 'page';
    return this.get("" + name + "Highlights").concat(this.get('sharedHighlights'));
  };

  Onboarding.prototype.removeHighlights = function(highlights) {
    var allHighlights, name, visited;
    name = Page.isSerp() ? 'serp' : 'page';
    allHighlights = this.sharedHighlights.concat(this.serpHighlights, this.pageHighlights);
    highlights = _.intersection(highlights, allHighlights);
    visited = this.get('viewedHighlights');
    visited = visited.concat(highlights);
    this.set('viewedHighlights', _.uniq(visited));
    this.set("" + name + "Highlights", _.difference(this.get("" + name + "Highlights"), highlights));
    this.set('sharedHighlights', _.difference(this.get('sharedHighlights'), highlights));
    return this.save();
  };

  Onboarding.prototype.hasUserSeenHighlight = function(highlight) {
    return this.get('viewedHighlights').indexOf(highlight) !== -1;
  };

  Onboarding.prototype.isOnboardingComplete = function() {
    return this.get('pageStep') === 'complete' && this.get('pageTourComplete') && this.get('serpStep') === 'complete' && this.get('serpTourComplete');
  };

  Onboarding.prototype.hideHighlight = function() {
    var highlights, name, step;
    name = Page.isSerp() ? 'serp' : 'page';
    step = this.get("" + name + "Step");
    highlights = this.getHighlights();
    if (highlights.length === 0) {
      this.nextStep();
    }
    if (_.isEqual(highlights, ['lock']) && this.user.get('isPro')) {
      this.nextStep();
    }
    if (_.isEqual(highlights, ['activate-keyword-difficulty']) && !this.user.get('isPro')) {
      return this.nextStep();
    }
  };

  Onboarding.prototype.restart = function() {
    this.set({
      pageStep: this.pageSteps[0],
      serpStep: this.serpSteps[0],
      pageHighlights: this.pageHighlights,
      serpHighlights: this.serpHighlights,
      sharedHighlights: this.sharedHighlights,
      pageTourComplete: false,
      serpTourComplete: false
    });
    return this.save();
  };

  Onboarding.prototype.close = function() {
    this.set({
      pageStep: 'complete',
      serpStep: 'complete',
      pageHighlights: [],
      serpHighlights: [],
      sharedHighlights: []
    });
    return this.save();
  };

  return Onboarding;

})(Model);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../views/event_dispatcher.coffee":45,"./analytics.coffee":4,"./page.coffee":18,"./settings.coffee":29,"./user.coffee":35}],17:[function(require,module,exports){
(function (global){
var Backbone, OnboardingTipModel, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Backbone = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null);

module.exports = OnboardingTipModel = (function(_super) {
  __extends(OnboardingTipModel, _super);

  function OnboardingTipModel() {
    _ref = OnboardingTipModel.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  OnboardingTipModel.prototype.defaults = {
    text: '',
    top: 0,
    left: 0,
    placement: 'below'
  };

  return OnboardingTipModel;

})(Backbone.Model);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],18:[function(require,module,exports){
(function (global){
var $, BLACKLIST_URLS, Page, SERP_CONFIG, _;

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

SERP_CONFIG = {
  'google': {
    selector: '.g .rc',
    href: 'a.entryTitle[href], h3 a[href], a.l',
    searchBox: '.srp form[action="/search"] .sfsbc',
    description: 'div.s .st'
  },
  'yahoo': {
    selector: 'div#web > ol > li',
    href: 'span.url',
    description: 'div.abstr'
  },
  'bing': {
    selector: 'li.b_algo',
    href: 'h2 a[href]',
    description: 'p'
  }
};

BLACKLIST_URLS = [/\:\/\/.+\.google\..+\/maps/, /\:\/\/seomoz\.zendesk\.com/, /\:\/\/tools\.answerdash\.com/, /\:\/\/docs\.google\.com/, /\:\/\/drive\.google\.com/, /\:\/\/mail\.google\.com/, /\:\/\/.+\.myworkday\.com/, /\:\/\/moz.com\/researchtools\/ose/];

module.exports = Page = (function() {
  function Page() {}

  Page.el = null;

  Page.url = function() {
    var el, _ref;
    if (this.el !== null) {
      return this.el;
    }
    el = document.createElement('a');
    if ((_ref = window.location.protocol) === 'chrome-extension:' || _ref === 'data:') {
      el.href = window.location.hash.substr(1);
    } else {
      el.href = window.location.href;
    }
    return this.el = el;
  };

  Page.href = function() {
    return this.url().href;
  };

  Page.hostname = function() {
    return this.url().hostname;
  };

  Page.pathname = function() {
    return this.url().pathname;
  };

  Page.isSerp = function() {
    return this.getSerpEngine() != null;
  };

  Page.getSerpEngine = function() {
    switch (false) {
      case !(this.hostname() === 'www.bing.com' && this.pathname() === '/search'):
        return 'bing';
      case !/search\.yahoo\./.test(this.hostname()):
        return 'yahoo';
      case !(/(www|encrypted)\.google\..+/.test(this.hostname()) && /\/(search|webhp)?$/.test(this.pathname())):
        return 'google';
    }
  };

  Page.getSerpConfig = function() {
    return SERP_CONFIG[this.getSerpEngine()];
  };

  Page.getSearchTerm = function() {
    var term;
    term = this.getParameter('[qp]');
    if (!_.isUndefined(term)) {
      return decodeURIComponent(term).replace(/\+/g, ' ');
    }
  };

  Page.getStartIndex = function() {
    if (this.getSerpEngine() !== 'google') {
      return null;
    }
    return this.getParameter('start') || 0;
  };

  Page.getParameter = function(param) {
    var params, _ref;
    params = window.location.hash || window.location.search;
    return (_ref = (new RegExp("[\?\&\#]" + param + "\=([^&]*)")).exec(params)) != null ? _ref[1] : void 0;
  };

  Page.readMetaTag = function(name) {
    return ($("meta[name='" + name + "']")).prop('content') || ($("meta[property='" + name + "']")).prop('content') || ($("meta[name='" + name + "']")).attr('value') || ($("meta[property='" + name + "']")).attr('value');
  };

  Page.isBlacklisted = function() {
    var urlRe, _i, _len;
    for (_i = 0, _len = BLACKLIST_URLS.length; _i < _len; _i++) {
      urlRe = BLACKLIST_URLS[_i];
      if (urlRe.test(this.href())) {
        return true;
      }
    }
    return false;
  };

  return Page;

})();


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],19:[function(require,module,exports){
(function (global){
var $, Collection, Geolocation, PageAttributes, PageElement, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

Collection = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null).Collection;

PageElement = require('./page_element.coffee');

Geolocation = require('./geolocation.coffee');

module.exports = PageAttributes = (function(_super) {
  __extends(PageAttributes, _super);

  function PageAttributes() {
    _ref = PageAttributes.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  PageAttributes.prototype.geolocation = Geolocation.getInstance();

  PageAttributes.prototype.initialize = function() {
    return this.listenTo(this.geolocation, 'change', this.updateLocation);
  };

  PageAttributes.prototype.isValid = function() {
    return this.models.length > 0;
  };

  PageAttributes.prototype.sync = function(method) {
    var loadTime;
    if (method !== 'read') {
      throw new Error('Not implemented');
    }
    if (!this.geolocation.isValid()) {
      this.geolocation.fetch();
    }
    loadTime = (performance.timing.loadEventEnd - performance.timing.responseEnd) / 1000;
    this.reset([
      new PageElement({
        tag: 'Meta Robots',
        selector: 'meta[name="robots"]',
        attribute: 'content'
      }), new PageElement({
        tag: 'Rel="canonical"',
        selector: 'link[rel="canonical"]',
        attribute: 'href'
      }), new PageElement({
        tag: 'Page Load Time',
        content: "" + loadTime + " seconds",
        url: 'http://developers.google.com/speed/pagespeed/insights/?url=' + window.top.document.location.href
      }), new PageElement({
        tag: 'Google Cache URL',
        url: "http://google.com/search?q=cache:" + window.top.document.location.href
      }), new PageElement({
        tag: 'IP Address',
        content: ''
      }), new PageElement({
        tag: 'Country',
        content: ''
      })
    ]);
    return this.updateLocation();
  };

  PageAttributes.prototype.updateLocation = function() {
    var _ref1, _ref2;
    if ((_ref1 = this.findWhere({
      tag: 'Country'
    })) != null) {
      _ref1.set('content', this.geolocation.get('country_name'));
    }
    return (_ref2 = this.findWhere({
      tag: 'IP Address'
    })) != null ? _ref2.set('content', this.geolocation.get('ip')) : void 0;
  };

  return PageAttributes;

})(Collection);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./geolocation.coffee":9,"./page_element.coffee":20}],20:[function(require,module,exports){
(function (global){
var $, Model, PageElement, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

Model = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null).Model;

module.exports = PageElement = (function(_super) {
  __extends(PageElement, _super);

  function PageElement() {
    _ref = PageElement.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  PageElement.prototype.defaults = {
    tag: '',
    content: '',
    contentClass: '',
    url: '',
    selector: null,
    metaName: null,
    length: '--',
    showLength: true,
    multipleError: false,
    shouldOnlyBeOne: false,
    attribute: null,
    truncate: null,
    concatenate: false
  };

  PageElement.prototype.initialize = function() {
    this.updateAttributes();
    return this.listenTo(this, 'change', this.updateAttributes);
  };

  PageElement.prototype.updateAttributes = function() {
    var $el, attrs, item, texts;
    attrs = _.clone(this.attributes);
    if (attrs.selector) {
      $el = $(attrs.selector);
    }
    if (attrs.metaName != null) {
      $el = ($('meta[name]')).filter(function() {
        return this.name.toLowerCase() === attrs.metaName;
      });
    }
    if ($el != null) {
      if (attrs.concatenate != null) {
        texts = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = $el.length; _i < _len; _i++) {
            item = $el[_i];
            if (attrs.attribute != null) {
              _results.push(($(item)).attr(attrs.attribute));
            } else {
              _results.push(($(item)).text());
            }
          }
          return _results;
        })();
        attrs.content = texts.join(' \u2022 ');
      } else if (attrs.attribute != null) {
        attrs.content = $el.attr(attrs.attribute);
      } else {
        attrs.content = $el.text();
      }
      attrs.content = $.trim(attrs.content);
      attrs.multipleError = attrs.shouldOnlyBeOne && $el.length > 1;
    }
    if (!attrs.content) {
      attrs.content = attrs.url;
    }
    attrs.content = attrs.content.replace(/\s+/g, ' ');
    attrs.length = attrs.content.length.toLocaleString();
    if (attrs.length === '0' || ($el != null ? $el.length : void 0) === 0) {
      attrs.length = '--';
    }
    if (($el != null ? $el.length : void 0) === 0) {
      attrs.content = 'Not found';
    }
    if ((attrs.truncate != null) && attrs.content.length > attrs.truncate) {
      attrs.content = attrs.content.substr(0, attrs.truncate) + '...';
    }
    return this.set(attrs);
  };

  return PageElement;

})(Model);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],21:[function(require,module,exports){
(function (global){
var $, Collection, Geolocation, PageElement, PageElements, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

Collection = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null).Collection;

PageElement = require('./page_element.coffee');

Geolocation = require('./geolocation.coffee');

module.exports = PageElements = (function(_super) {
  __extends(PageElements, _super);

  function PageElements() {
    _ref = PageElements.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  PageElements.prototype.geolocation = Geolocation.getInstance();

  PageElements.prototype.initialize = function() {
    return this.listenTo(this.geolocation, 'change', this.updateLocation);
  };

  PageElements.prototype.isValid = function() {
    return this.models.length > 0;
  };

  PageElements.prototype.sync = function(method) {
    var codeLen, doc, textToCodeRatio;
    if (method !== 'read') {
      throw new Error('Not implemented');
    }
    if (!this.geolocation.isValid()) {
      this.geolocation.fetch();
    }
    doc = window.top.document;
    codeLen = doc.getElementsByTagName('html')[0].innerHTML.length;
    textToCodeRatio = ((($('html')).text().length / codeLen) * 100).toFixed(2);
    this.reset([
      new PageElement({
        tag: 'URL',
        content: doc.location.href,
        contentClass: 'flag us'
      }), new PageElement({
        tag: 'Page Title',
        selector: 'title'
      }), new PageElement({
        tag: 'Meta Description',
        metaName: 'description',
        attribute: 'content',
        shouldOnlyBeOne: true
      }), new PageElement({
        tag: 'Meta Keywords',
        metaName: 'keywords',
        attribute: 'content',
        shouldOnlyBeOne: true
      }), new PageElement({
        tag: 'H1',
        selector: 'h1',
        concatenate: true
      }), new PageElement({
        tag: 'H2',
        selector: 'h2',
        concatenate: true
      }), new PageElement({
        tag: 'Bold/Strong',
        selector: 'b,strong',
        concatenate: true
      }), new PageElement({
        tag: 'Italic/em',
        selector: 'i,em',
        concatenate: true
      }), new PageElement({
        tag: 'Alt Text',
        selector: 'img[alt][alt!=""]',
        attribute: 'alt',
        concatenate: true
      })
    ]);
    return this.updateLocation();
  };

  PageElements.prototype.updateLocation = function() {
    var code, _ref1, _ref2;
    code = (_ref1 = this.geolocation.get('country_code')) != null ? _ref1.toLowerCase() : void 0;
    return (_ref2 = this.findWhere({
      tag: 'URL'
    })) != null ? _ref2.set('contentClass', "flag " + code) : void 0;
  };

  return PageElements;

})(Collection);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./geolocation.coffee":9,"./page_element.coffee":20}],22:[function(require,module,exports){
(function (global){
var Model, Profile, Settings, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

Model = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null).Model;

Settings = require('./settings.coffee');

module.exports = Profile = (function(_super) {
  __extends(Profile, _super);

  function Profile() {
    _ref = Profile.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  Profile.prototype.settings = Settings.getInstance();

  Profile.prototype.defaults = {
    name: '',
    engine: 'google',
    disablePersonalization: false,
    country: 'US',
    region: '',
    city: ''
  };

  Profile.prototype.sync = function(method) {
    var maxId, p, profile, profiles,
      _this = this;
    profiles = _.clone(this.settings.get('profiles'));
    profile = _.find(profiles, function(p) {
      return p.id === _this.get('id');
    });
    switch (method) {
      case 'update':
        _.extend(profile, this.attributes);
        return this.saveProfiles(profiles);
      case 'create':
        maxId = _.max((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = profiles.length; _i < _len; _i++) {
            p = profiles[_i];
            _results.push(p.id);
          }
          return _results;
        })());
        this.set('id', maxId + 1);
        profiles.push(this.attributes);
        return this.saveProfiles(profiles);
      case 'delete':
        profiles = _.without(profiles, profile);
        return this.saveProfiles(profiles);
      default:
        throw new Error("{#method} not implemented");
    }
  };

  Profile.prototype.saveProfiles = function(profiles) {
    this.settings.set('profiles', profiles);
    return this.settings.save();
  };

  return Profile;

})(Model);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./settings.coffee":29}],23:[function(require,module,exports){
(function (global){
var Collection, Profile, Profiles, Settings, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Collection = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null).Collection;

Profile = require('./profile.coffee');

Settings = require('./settings.coffee');

module.exports = Profiles = (function(_super) {
  __extends(Profiles, _super);

  function Profiles() {
    _ref = Profiles.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  Profiles.prototype.settings = Settings.getInstance();

  Profiles.prototype.model = Profile;

  Profiles.prototype.initialize = function() {
    this.fetch();
    return this.listenTo(this.settings, 'change:profiles', this.fetch);
  };

  Profiles.prototype.sync = function(method) {
    switch (method) {
      case 'read':
        return this.set(this.settings.get('profiles'));
    }
  };

  return Profiles;

})(Collection);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./profile.coffee":22,"./settings.coffee":29}],24:[function(require,module,exports){
(function (global){
var Backbone, Regions, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Backbone = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null);

module.exports = Regions = (function(_super) {
  __extends(Regions, _super);

  function Regions() {
    _ref = Regions.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  Regions.prototype.country = 'US';

  Regions.prototype.url = function() {
    return "https://d2eeipcrcdle6.cloudfront.net/mozbar/regions/" + this.country + ".json";
  };

  return Regions;

})(Backbone.Collection);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],25:[function(require,module,exports){
(function (global){
var $, Model, Page, Semantics, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

Model = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null).Model;

Page = require('./page.coffee');

module.exports = Semantics = (function(_super) {
  var microformats2Classes;

  __extends(Semantics, _super);

  function Semantics() {
    _ref = Semantics.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  microformats2Classes = ['h-adr', 'h-card', 'h-entry', 'h-event', 'h-feed', 'h-geo', 'h-item', 'h-listing', 'h-product', 'h-recipe', 'h-resume', 'h-review', 'h-review-aggregate'];

  Semantics.prototype.defaults = {
    hasSchema: null,
    hasTwitter: null,
    pageUrl: Page.href(),
    richSnippetToolUrl: 'https://developers.google.com/webmasters/structured-data/testing-tool' + ("?url=" + (encodeURIComponent(Page.href()))),
    openGraphToolUrl: 'https://developers.facebook.com/tools/debug/og/object?q=' + encodeURIComponent(Page.href())
  };

  Semantics.prototype.url = function() {
    return this.get('richSnippetToolUrl');
  };

  Semantics.prototype.sync = function(method) {
    if (method !== 'read') {
      throw new Error('Not implemented');
    }
    return this.set({
      description: ($('meta[name="description"]')).prop('content'),
      hasSchema: ($('[itemscope][itemtype^="http://schema.org/"]')).length,
      hasOpenGraph: Page.readMetaTag('og:title') || Page.readMetaTag('og:type') || Page.readMetaTag('og:image') || Page.readMetaTag('og:url') || Page.readMetaTag('og:description') || Page.readMetaTag('og:audio') || Page.readMetaTag('og:video'),
      hasTwitter: Page.readMetaTag('twitter:card'),
      hasMicroformats: ($('.vcard')).length || _.find(this.microformats2Classes, function(className) {
        return ($("." + className)).length;
      })
    });
  };

  Semantics.prototype.validate = function(attrs) {
    if (_.isNull(attrs.hasSchema)) {
      return 'Data not loaded';
    }
  };

  return Semantics;

})(Model);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./page.coffee":18}],26:[function(require,module,exports){
(function (global){
var $, Model, Page, SerpAttributes, SerpResultsMetrics, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

Model = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null).Model;

Page = require('./page.coffee');

SerpResultsMetrics = require('./serp_results_metrics.coffee');

module.exports = SerpAttributes = (function(_super) {
  __extends(SerpAttributes, _super);

  function SerpAttributes() {
    _ref = SerpAttributes.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  SerpAttributes.prototype.$el = null;

  SerpAttributes.prototype.defaults = {
    el: null,
    url: null,
    title: null,
    description: null,
    metrics: null
  };

  SerpAttributes.prototype.initialize = function(attributes) {
    var metrics, url;
    SerpAttributes.__super__.initialize.apply(this, arguments);
    if (!this.get('el')) {
      throw new Error('Required attribute $el not set!');
    }
    this.$el = $(this.get('el'));
    url = this.getUrl();
    metrics = SerpResultsMetrics.getInstance().getPageMetrics(url);
    metrics.set({
      position: attributes.position
    });
    return this.set({
      url: url,
      title: this.getTitle(),
      description: this.getDescription(),
      metrics: metrics
    });
  };

  SerpAttributes.prototype.getUrl = function() {
    var $href;
    $href = this.$el.find(Page.getSerpConfig().href);
    switch (Page.getSerpEngine()) {
      case 'google':
      case 'bing':
        return $href.attr('href');
      case 'yahoo':
        return $href.text();
    }
  };

  SerpAttributes.prototype.getTitle = function() {
    return this.$el.find(Page.getSerpConfig().href).text();
  };

  SerpAttributes.prototype.getDescription = function() {
    var $desc;
    $desc = this.$el.find(Page.getSerpConfig().description);
    switch (Page.getSerpEngine()) {
      case 'google':
        return $desc.clone().children('.f').remove().end().text();
      default:
        return $desc.text();
    }
  };

  return SerpAttributes;

})(Model);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./page.coffee":18,"./serp_results_metrics.coffee":27}],27:[function(require,module,exports){
(function (global){
var $, Collection, Page, SerpResultsMetrics, UrlMetrics, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

Collection = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null).Collection;

Page = require('./page.coffee');

UrlMetrics = require('./url_metrics.coffee');

module.exports = SerpResultsMetrics = (function(_super) {
  __extends(SerpResultsMetrics, _super);

  function SerpResultsMetrics() {
    _ref = SerpResultsMetrics.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  SerpResultsMetrics.serpResultsMetrics = null;

  SerpResultsMetrics.getInstance = function() {
    return this.serpResultsMetrics != null ? this.serpResultsMetrics : this.serpResultsMetrics = new SerpResultsMetrics;
  };

  SerpResultsMetrics.prototype.getPageMetrics = function(url) {
    var metrics;
    metrics = this.findWhere({
      pageUrl: url
    });
    return metrics != null ? metrics : metrics = this.add(new UrlMetrics({
      pageUrl: url
    }));
  };

  SerpResultsMetrics.prototype.isValid = function(urls) {
    var models;
    models = this.getMetricsForUrls(urls);
    return _.isUndefined(_.find(models, function(model) {
      return !model.isValid();
    }));
  };

  SerpResultsMetrics.prototype.isLoaded = function(urls) {
    var models;
    models = this.getMetricsForUrls(urls);
    return _.isUndefined(_.find(models, function(model) {
      return !model.isLoaded;
    }));
  };

  SerpResultsMetrics.prototype.getMetricsForUrls = function(urls) {
    var models;
    return models = urls ? this.findMetricsByUrls(urls) : this.models;
  };

  SerpResultsMetrics.prototype.findMetricsByUrls = function(urls) {
    var model, _i, _len, _ref1, _ref2, _results;
    _ref1 = this.models;
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      model = _ref1[_i];
      if (_ref2 = model.get('pageUrl'), __indexOf.call(urls, _ref2) >= 0) {
        _results.push(model);
      }
    }
    return _results;
  };

  return SerpResultsMetrics;

})(Collection);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./page.coffee":18,"./url_metrics.coffee":34}],28:[function(require,module,exports){
(function (global){
var Model, Profiles, SerpToobar, Settings, User, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

Model = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null).Model;

User = require('./user.coffee');

Settings = require('./settings.coffee');

Profiles = require('./profiles.coffee');

module.exports = SerpToobar = (function(_super) {
  __extends(SerpToobar, _super);

  function SerpToobar() {
    _ref = SerpToobar.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  SerpToobar.prototype.settings = Settings.getInstance();

  SerpToobar.prototype.user = User.getInstance();

  SerpToobar.prototype.profiles = new Profiles;

  SerpToobar.prototype.initialize = function() {
    var _this = this;
    this.updateProfile();
    this.listenTo(this.settings, 'change:selectedProfileId', this.updateProfile);
    return this.listenTo(this.user, 'change', function() {
      return _this.trigger('change');
    });
  };

  SerpToobar.prototype.updateProfile = function() {
    var profile;
    profile = this.profiles.get(this.settings.get('selectedProfileId'));
    if (profile == null) {
      profile = this.profiles.at(0);
    }
    return this.set('profile', profile);
  };

  SerpToobar.prototype.toJSON = function() {
    return _.extend(_.clone(this.attributes), {
      user: this.user.toJSON(),
      profile: this.get('profile').toJSON()
    });
  };

  return SerpToobar;

})(Model);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./profiles.coffee":23,"./settings.coffee":29,"./user.coffee":35}],29:[function(require,module,exports){
(function (global){
var Backbone, SETTINGS_VERSION, Settings, SimpleStorage, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

Backbone = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null);

SimpleStorage = require('sdk/simple-storage');

SETTINGS_VERSION = 1;

module.exports = Settings = (function(_super) {
  __extends(Settings, _super);

  function Settings() {
    _ref = Settings.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  Settings.settings = null;

  Settings.savedAttributes = null;

  Settings.getInstance = function() {
    return this.settings != null ? this.settings : this.settings = new Settings;
  };

  Settings.prototype.defaults = {
    version: SETTINGS_VERSION,
    isMozbarOn: null,
    isButtonOn: null,
    isLightTheme: false,
    isDockedOnBottom: false,
    mixpanelId: null,
    lastMixpanelActiveUser: 0,
    selectedProfileId: 1,
    profiles: [
      {
        id: 1,
        name: 'Google US (non-personalized)',
        engine: 'google',
        disablePersonalization: true,
        country: 'US',
        region: '',
        city: ''
      }, {
        id: 2,
        name: 'Bing US',
        engine: 'bing',
        disablePersonalization: false,
        country: 'US',
        region: '',
        city: ''
      }, {
        id: 3,
        name: 'Yahoo US',
        engine: 'yahoo',
        disablePersonalization: false,
        country: 'US',
        region: '',
        city: ''
      }
    ],
    metricsCols: ['ftrp', 'fspsc'],
    user: {
      access_id: '',
      expires: 0,
      level: 'member'
    },
    onboarding: {
      pageStep: 'legacy-user',
      serpStep: 'legacy-user',
      pageHighlightButtons: [],
      serpHighlightButtons: []
    },
    isNewInstall: false
  };

  Settings.prototype.initialize = function() {
    var _ref1,
      _this = this;
    this.fetch();
    if (typeof chrome !== "undefined" && chrome !== null) {
      chrome.storage.onChanged.addListener(function() {
        return _this.fetch();
      });
    }
    return typeof self !== "undefined" && self !== null ? (_ref1 = self.port) != null ? _ref1.on('settingsChanged', function(attributes) {
      return _this.set(attributes);
    }) : void 0 : void 0;
  };

  Settings.prototype.onNewInstall = function() {
    this.set({
      isMozbarOn: true,
      isButtonOn: true,
      isLightTheme: true,
      onboarding: {
        pageStep: 'intro',
        serpStep: 'intro'
      }
    });
    return this.save();
  };

  Settings.prototype.toggleMozbar = function() {
    switch (false) {
      case !this.get('isMozbarOn'):
        this.set({
          isMozbarOn: false
        });
        break;
      case !this.get('isButtonOn'):
        this.set({
          isButtonOn: false
        });
        break;
      default:
        this.set({
          isButtonOn: true,
          isMozbarOn: true
        });
    }
    this.resetPanelState();
    return this.save();
  };

  Settings.prototype.toggleDockPosition = function() {
    this.set('isDockedOnBottom', !this.get('isDockedOnBottom'));
    return this.save();
  };

  Settings.prototype.resetPanelState = function() {
    return this.set({
      selectedPanel: '',
      highlightLinks: [],
      highlightKeyword: '',
      infoPanelTab: 'page-elements'
    });
  };

  Settings.prototype.sync = function(method) {
    var key, keys, value, _ref1, _ref2,
      _this = this;
    switch (method) {
      case 'create':
      case 'update':
      case 'patch':
        if (_.isEqual(this.attributes, this.savedAttributes)) {
          return;
        }
        if (typeof chrome !== "undefined" && chrome !== null) {
          chrome.storage.sync.set(this.attributes);
        }
        if ((SimpleStorage != null ? SimpleStorage.storage : void 0) != null) {
          _ref1 = this.attributes;
          for (key in _ref1) {
            value = _ref1[key];
            SimpleStorage.storage[key] = value;
          }
        }
        return typeof self !== "undefined" && self !== null ? (_ref2 = self.port) != null ? _ref2.emit('settingsChanged', this.attributes) : void 0 : void 0;
      case 'read':
        if (typeof chrome !== "undefined" && chrome !== null) {
          chrome.storage.sync.get(this.attributes, function(attrs) {
            return _this.updateAttributes(attrs);
          });
        }
        if (SimpleStorage.storage != null) {
          return this.updateAttributes(SimpleStorage.storage);
        }
        break;
      case 'delete':
        keys = (function() {
          var _results;
          _results = [];
          for (key in this.attributes) {
            _results.push(key);
          }
          return _results;
        }).call(this);
        return typeof chrome !== "undefined" && chrome !== null ? chrome.storage.sync.remove(keys) : void 0;
    }
  };

  Settings.prototype.updateAttributes = function(attrs) {
    this.savedAttributes = JSON.parse(JSON.stringify(attrs));
    this.set(this.updateSettings(attrs));
    if (!_.isEqual(this.attributes, this.savedAttributes)) {
      return this.save();
    }
  };

  Settings.prototype.updateSettings = function(attrs) {
    if (attrs.mixpanelId == null) {
      attrs.mixpanelId = this.generateUniqueId();
    }
    if (_.isNull(attrs.isButtonOn) || _.isUndefined(attrs.isButtonOn)) {
      attrs.isButtonOn = attrs.isMozbarOn;
    }
    if (_.isNull(attrs.version)) {
      attrs.metricsCols.push('fspsc');
    }
    attrs.version = SETTINGS_VERSION;
    return attrs;
  };

  Settings.prototype.generateUniqueId = function() {
    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
  };

  return Settings;

})(Backbone.Model);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"sdk/simple-storage":113}],30:[function(require,module,exports){
(function (global){
var Browser, Model, TabSettings, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

Model = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null).Model;

Browser = require('./browser.coffee');

module.exports = TabSettings = (function(_super) {
  __extends(TabSettings, _super);

  function TabSettings() {
    _ref = TabSettings.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  TabSettings.prototype.defaults = {
    highlightLinks: null,
    highlightKeyword: ''
  };

  TabSettings.prototype.sync = function(method, model, options) {
    switch (method) {
      case 'create':
      case 'update':
      case 'patch':
        return Browser.sendMessage('setTabSettings', this.toJSON());
      case 'read':
        return Browser.sendMessage('getTabSettings', null, function(response) {
          if (response == null) {
            response = {
              highlightLinks: [],
              highlightKeyword: ''
            };
          }
          return options.success.call(model, response);
        });
    }
  };

  TabSettings.prototype.toggleHighlightLink = function(type, isOn) {
    var links;
    links = this.get('highlightLinks') || [];
    if (isOn && links.indexOf(type) === -1) {
      links = links.concat(type);
    }
    if (!isOn) {
      links = _.without(links, type);
    }
    return this.set('highlightLinks', links);
  };

  TabSettings.prototype.isValid = function() {
    return this.get('highlightLinks') !== null;
  };

  return TabSettings;

})(Model);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./browser.coffee":5}],31:[function(require,module,exports){
(function (global){
var Backbone, Tooltip, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Backbone = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null);

module.exports = Tooltip = (function(_super) {
  __extends(Tooltip, _super);

  function Tooltip() {
    _ref = Tooltip.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  Tooltip.prototype.defaults = {
    text: '',
    top: 0,
    left: 0,
    placement: 'below'
  };

  return Tooltip;

})(Backbone.Model);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],32:[function(require,module,exports){
(function (global){
var $, Model, Page, Twitter, TwitterUser, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

Model = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null).Model;

Page = require('./page.coffee');

TwitterUser = require('./twitter_user.coffee');

module.exports = Twitter = (function(_super) {
  __extends(Twitter, _super);

  function Twitter() {
    _ref = Twitter.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  Twitter.prototype.defaults = {
    isLoaded: false,
    isSupported: true,
    cardType: null,
    image: null,
    description: null,
    title: null
  };

  Twitter.prototype.creator = new TwitterUser;

  Twitter.prototype.site = new TwitterUser;

  Twitter.prototype.supportedCardTypes = ['summary', 'summary_large_image', 'product', 'photo', 'gallery', 'player'];

  Twitter.prototype.initialize = function() {
    var _this = this;
    this.listenTo(this.creator, 'change', function() {
      return _this.trigger('change');
    });
    return this.listenTo(this.site, 'change', function() {
      return _this.trigger('change');
    });
  };

  Twitter.prototype.sync = function(method, model, options) {
    var cardType, isSupported;
    if (method !== 'read') {
      throw new Error('Not supported');
    }
    this.site.set('id', Page.readMetaTag('twitter:site'));
    this.site.fetch();
    this.creator.set('id', Page.readMetaTag('twitter:creator'));
    this.creator.fetch();
    cardType = Page.readMetaTag('twitter:card');
    isSupported = __indexOf.call(this.supportedCardTypes, cardType) >= 0;
    return options.success({
      isLoaded: true,
      hasTwitter: Page.readMetaTag('twitter:card'),
      cardType: Page.readMetaTag('twitter:card'),
      image: Page.readMetaTag('twitter:image') || Page.readMetaTag('twitter:image:src') || Page.readMetaTag('og:image'),
      description: Page.readMetaTag('twitter:description') || Page.readMetaTag('og:description'),
      title: Page.readMetaTag('twitter:title') || Page.readMetaTag('og:title'),
      label1: Page.readMetaTag('twitter:label1'),
      data1: Page.readMetaTag('twitter:data1'),
      label2: Page.readMetaTag('twitter:label2'),
      data2: Page.readMetaTag('twitter:data2'),
      image0: Page.readMetaTag('twitter:image0'),
      image1: Page.readMetaTag('twitter:image1'),
      image2: Page.readMetaTag('twitter:image2'),
      image3: Page.readMetaTag('twitter:image3'),
      player: Page.readMetaTag('twitter:player')
    });
  };

  Twitter.prototype.validate = function(attrs) {
    if (!attrs.isLoaded) {
      return 'Data not loaded';
    }
  };

  Twitter.prototype.toJSON = function() {
    return _.clone(_.extend(this.attributes, {
      site: this.site.toJSON(),
      creator: this.creator.toJSON()
    }));
  };

  return Twitter;

})(Model);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./page.coffee":18,"./twitter_user.coffee":33}],33:[function(require,module,exports){
(function (global){
var $, Model, TwitterUser, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

Model = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null).Model;

module.exports = TwitterUser = (function(_super) {
  __extends(TwitterUser, _super);

  function TwitterUser() {
    _ref = TwitterUser.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  TwitterUser.prototype.defaults = {
    handle: null,
    name: null,
    image: null
  };

  TwitterUser.prototype.urlRoot = 'https://twitter.com/';

  TwitterUser.prototype.initialize = function() {
    var _this = this;
    return this.listenTo(this, 'change:id', function() {
      var id;
      if (!_this.get('id')) {
        return;
      }
      id = _this.get('id').replace(/^\@/, '');
      return _this.set({
        id: id,
        handle: "@" + id
      });
    });
  };

  TwitterUser.prototype.fetch = function(options) {
    if (!this.has('id')) {
      return;
    }
    return TwitterUser.__super__.fetch.call(this, _.extend({
      dataType: 'html'
    }, options));
  };

  TwitterUser.prototype.parse = function(resp) {
    var $resp;
    $resp = $(resp);
    return {
      image: $resp.find('.profile-picture .avatar').prop('src'),
      name: $resp.find('.profile-card-inner .fullname .profile-field').text()
    };
  };

  return TwitterUser;

})(Model);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],34:[function(require,module,exports){
(function (global){
var Analytics, Backbone, Browser, Settings, UrlMetrics, User, mozCols, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

Backbone = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null);

Analytics = require('./analytics.coffee');

Browser = require('./browser.coffee');

Settings = require('./settings.coffee');

User = require('./user.coffee');

mozCols = require('./moz_cols.coffee');

module.exports = UrlMetrics = (function(_super) {
  __extends(UrlMetrics, _super);

  function UrlMetrics() {
    _ref = UrlMetrics.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  UrlMetrics.urlMetrics = null;

  UrlMetrics.getInstance = function() {
    return this.urlMetrics != null ? this.urlMetrics : this.urlMetrics = new UrlMetrics();
  };

  UrlMetrics.prototype.user = User.getInstance();

  UrlMetrics.prototype.analytics = Analytics.getInstance();

  UrlMetrics.prototype.settings = Settings.getInstance();

  UrlMetrics.prototype.defaults = {
    rootDomain: document.location.hostname,
    pageUrl: document.location.href,
    upa: '--',
    umrp: '--',
    utrp: '--',
    niceUid: '--',
    niceUipl: '--',
    pda: '--',
    nicePuid: '--',
    nicePid: '--',
    niceFuid: '--',
    niceFipl: '--',
    niceFspsc: '--',
    position: null
  };

  UrlMetrics.prototype.initialize = function(opts) {
    var _this = this;
    this.updateRootDomain();
    this.listenTo(this, 'change:pageUrl', this.updateRootDomain);
    this.listenTo(this, 'error', function() {
      return _this.isLoaded = true;
    });
    UrlMetrics.__super__.initialize.apply(this, arguments);
    this.listenTo(this.user, 'change', function() {
      return _this.fetch();
    });
    this.listenTo(this.settings, 'change:metricsCols', function() {
      return _this.fetch();
    });
    return this.listenTo(this, 'change', function() {
      return Browser.sendMessage('metricsChanged', _this.toJSON());
    });
  };

  UrlMetrics.prototype.fetch = function(options) {
    if (!this.user.isValid()) {
      this.user.fetch(options);
      return;
    }
    if (this.isFetching || this.isLoaded) {
      return;
    }
    this.isFetching = true;
    return UrlMetrics.__super__.fetch.apply(this, arguments);
  };

  UrlMetrics.prototype.fetchRootSpamScore = function() {
    var cols,
      _this = this;
    cols = mozCols.getBits(['fspsc']);
    return $.get("https://lsapi.seomoz.com/linkscape/url-metrics/" + ("" + (this.get('rootDomain')) + "?Cols=" + cols + "&" + (this.user.authQS())), function(resp) {
      return _this.set({
        fspsc: resp.fspsc != null ? resp.fspsc - 1 : void 0,
        niceFspsc: resp.fspsc != null ? "" + (resp.fspsc - 1) + "/17" : void 0,
        noFspsc: resp.fspsc === 0
      });
    });
  };

  UrlMetrics.prototype.validate = function(attrs) {
    if (attrs.upa === this.defaults.upa) {
      return 'Data not loaded';
    }
  };

  UrlMetrics.prototype.updateRootDomain = function() {
    var el;
    el = document.createElement('a');
    el.href = this.get('pageUrl');
    return this.set('rootDomain', el.hostname);
  };

  UrlMetrics.prototype.url = function() {
    var pageUrl;
    pageUrl = encodeURIComponent(this.get('pageUrl').replace(/^http[s]*:\/\//, ''));
    return "https://lsapi.seomoz.com/linkscape/url-metrics/" + ("" + pageUrl + "?Cols=" + (this.getCols()) + "&" + (this.user.authQS()));
  };

  UrlMetrics.prototype.parse = function(resp) {
    var _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    this.isFetching = false;
    this.isLoaded = true;
    if (resp.fspsc === 0) {
      this.fetchRootSpamScore();
    }
    return _.extend(resp, {
      niceUeid: (_ref1 = resp.ueid) != null ? _ref1.toLocaleString() : void 0,
      niceFeid: (_ref2 = resp.feid) != null ? _ref2.toLocaleString() : void 0,
      nicePeid: (_ref3 = resp.peid) != null ? _ref3.toLocaleString() : void 0,
      niceUid: (_ref4 = resp.uid) != null ? _ref4.toLocaleString() : void 0,
      nicePid: (_ref5 = resp.pid) != null ? _ref5.toLocaleString() : void 0,
      niceUipl: (_ref6 = resp.uipl) != null ? _ref6.toLocaleString() : void 0,
      umrp: (_ref7 = resp.umrp) != null ? _ref7.toFixed(2) : void 0,
      fmrp: (_ref8 = resp.fmrp) != null ? _ref8.toFixed(2) : void 0,
      pmrp: (_ref9 = resp.pmrp) != null ? _ref9.toFixed(2) : void 0,
      pmrpPct: Math.round(resp.pmrp * 10),
      utrp: (_ref10 = resp.utrp) != null ? _ref10.toFixed(2) : void 0,
      ftrp: (_ref11 = resp.ftrp) != null ? _ref11.toFixed(2) : void 0,
      ptrp: (_ref12 = resp.ptrp) != null ? _ref12.toFixed(2) : void 0,
      ptrpPct: Math.round(resp.ptrp * 10),
      utrpPct: Math.round(resp.utrp * 10),
      umrpPct: Math.round(resp.umrp * 10),
      niceFipl: (_ref13 = resp.fipl) != null ? _ref13.toLocaleString() : void 0,
      niceFuid: (_ref14 = resp.fuid) != null ? _ref14.toLocaleString() : void 0,
      nicePuid: (_ref15 = resp.puid) != null ? _ref15.toLocaleString() : void 0,
      niceUpa: Math.round(resp.upa),
      nicePda: Math.round(resp.pda),
      fspsc: resp.fspsc != null ? resp.fspsc - 1 : void 0,
      niceFspsc: resp.fspsc != null ? "" + (resp.fspsc - 1) + "/17" : void 0,
      noFspsc: resp.fspsc === 0
    });
  };

  UrlMetrics.prototype.getCols = function() {
    var cols;
    cols = ['upa', 'uid', 'pda', 'ueid', 'fmrp'];
    if (this.user.get('isPro')) {
      cols = cols.concat(['uipl', 'puid', 'pid', 'fuid', 'fipl', 'feid', 'peid']);
    }
    cols = cols.concat(_.without(this.settings.get('metricsCols'), 'links'));
    return mozCols.getBits(cols);
  };

  UrlMetrics.prototype.toJSON = function() {
    return _.clone(_.extend(this.attributes, {
      user: this.user.toJSON(),
      bar1on: this.attributes.fspsc > 0 ? 'on' : void 0,
      bar2on: this.attributes.fspsc > 6 ? 'on' : void 0,
      bar3on: this.attributes.fspsc > 12 ? 'on' : void 0
    }));
  };

  return UrlMetrics;

})(Backbone.Model);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./analytics.coffee":4,"./browser.coffee":5,"./moz_cols.coffee":15,"./settings.coffee":29,"./user.coffee":35}],35:[function(require,module,exports){
(function (global){
var $, Backbone, Page, Settings, User, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

Backbone = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null);

Page = require('./page.coffee');

Settings = require('./settings.coffee');

module.exports = User = (function(_super) {
  __extends(User, _super);

  function User() {
    _ref = User.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  User.user = null;

  User.getInstance = function() {
    return this.user != null ? this.user : this.user = new User;
  };

  User.prototype.settings = Settings.getInstance();

  User.prototype.url = 'https://moz.com/users/level?src=mozbar';

  User.prototype.fetched = false;

  User.prototype.initialize = function() {
    var _this = this;
    this.listenTo(this, 'change:level', this.updateProFlag);
    return this.listenTo(this.settings, 'change:user', function() {
      return _this.fetch();
    });
  };

  User.prototype.fetch = function(options) {
    var _this = this;
    if (!this.settings.get('isButtonOn')) {
      return;
    }
    this.set(this.settings.get('user'));
    if (this.isValid() && Page.hostname().indexOf('moz.com') === -1) {
      return;
    }
    if (this.fetched) {
      return;
    }
    this.fetched = true;
    if (options == null) {
      options = {};
    }
    options.success = function() {
      return _this.save();
    };
    return User.__super__.fetch.call(this, options);
  };

  User.prototype.save = function() {
    this.settings.set('user', this.toJSON());
    return this.settings.save();
  };

  User.prototype.updateProFlag = function() {
    return this.set('isPro', this.get('level') !== 'member');
  };

  User.prototype.parse = function(resp) {
    return _.extend(resp, {
      access_id: decodeURIComponent(resp.access_id),
      signature: decodeURIComponent(resp.signature),
      isPro: resp.level !== 'member'
    });
  };

  User.prototype.validate = function(attrs) {
    if (new Date((attrs.expires || 0) * 1000) < Date.now()) {
      return 'User expired';
    }
  };

  User.prototype.authQS = function() {
    return $.param({
      AccessID: this.get('access_id'),
      Expires: this.get('expires'),
      Signature: this.get('signature')
    });
  };

  return User;

})(Backbone.Model);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./page.coffee":18,"./settings.coffee":29}],36:[function(require,module,exports){
var AddressBarHighlight, BaseElement, Dispatcher, Page, template, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BaseElement = require('./base_element.coffee');

Page = require('./../models/page.coffee');

Dispatcher = require('./event_dispatcher.coffee');

template = require('./../../templates/address_bar_highlight.hbs');

module.exports = AddressBarHighlight = (function(_super) {
  __extends(AddressBarHighlight, _super);

  function AddressBarHighlight() {
    _ref = AddressBarHighlight.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  AddressBarHighlight.prototype.id = 'mozbar-address-bar-highlight-wGA7MhRhQ3WS';

  AddressBarHighlight.prototype.className = 'mozbar-address-bar-highlight-wGA7MhRhQ3WS';

  AddressBarHighlight.prototype.elementCssClass = 'address-bar-highlight';

  AddressBarHighlight.prototype.elementTemplate = template;

  AddressBarHighlight.prototype.initialize = function() {
    var dispatcher,
      _this = this;
    dispatcher = Dispatcher.getInstance();
    dispatcher.on('address-bar-highlight:show', function() {
      return _this.render();
    });
    return dispatcher.on('address-bar-highlight:hide', function() {
      return _this.remove();
    });
  };

  return AddressBarHighlight;

})(BaseElement);


},{"./../../templates/address_bar_highlight.hbs":80,"./../models/page.coffee":18,"./base_element.coffee":38,"./event_dispatcher.coffee":45}],37:[function(require,module,exports){
(function (global){
var $, BaseDialog, BaseElement, Overlay, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

BaseElement = require('./base_element.coffee');

Overlay = require('./overlay.coffee');

module.exports = BaseDialog = (function(_super) {
  __extends(BaseDialog, _super);

  function BaseDialog() {
    _ref = BaseDialog.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  BaseDialog.prototype.elementCssClass = 'dialog';

  BaseDialog.prototype.elementViewClass = null;

  BaseDialog.prototype.overlay = null;

  BaseDialog.prototype.id = 'mozbar-help-dialog-wGA7MhRhQ3WS';

  BaseDialog.prototype.initialize = function(options) {
    var _this = this;
    this.options = options;
    BaseDialog.__super__.initialize.apply(this, arguments);
    this.overlay = new Overlay();
    return this.overlay.on('clicked', function() {
      return _this.overlayClicked();
    });
  };

  BaseDialog.prototype.render = function() {
    BaseDialog.__super__.render.apply(this, arguments);
    return this.overlay.render();
  };

  BaseDialog.prototype.setElementRoot = function(elementRoot) {
    var _ref1;
    this.elementRoot = elementRoot;
    BaseDialog.__super__.setElementRoot.apply(this, arguments);
    if ((_ref1 = this.options) != null ? _ref1.arrow : void 0) {
      return this.$elementRoot.addClass("arrow-" + this.options.arrow);
    }
  };

  BaseDialog.prototype.overlayClicked = function() {
    return this.remove();
  };

  BaseDialog.prototype.remove = function() {
    BaseDialog.__super__.remove.apply(this, arguments);
    return this.overlay.remove();
  };

  return BaseDialog;

})(BaseElement);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./base_element.coffee":38,"./overlay.coffee":60}],38:[function(require,module,exports){
(function (global){
var $, BaseElement, BaseView, Browser, Handlebars, Settings, template, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

Settings = require('./../models/settings.coffee');

Handlebars = require('handlebars');

Browser = require('./../models/browser.coffee');

BaseView = require('./base_view.coffee');

template = require('./../../templates/base_element.hbs');

module.exports = BaseElement = (function(_super) {
  __extends(BaseElement, _super);

  function BaseElement() {
    _ref = BaseElement.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  BaseElement.prototype.settings = Settings.getInstance();

  BaseElement.prototype.tagName = 'iframe';

  BaseElement.prototype.className = 'mozbar-wGA7MhRhQ3WS';

  BaseElement.prototype.elementTemplate = null;

  BaseElement.prototype.elementCssClass = null;

  BaseElement.prototype.elementViewClass = null;

  BaseElement.prototype.elementViewModel = null;

  BaseElement.prototype.elementView = null;

  BaseElement.prototype.elementRoot = null;

  BaseElement.prototype.$elementRoot = null;

  BaseElement.prototype.initialize = function(options) {
    var _this = this;
    return this.settings.on('change:isLightTheme', function() {
      return _this.updateTheme();
    });
  };

  BaseElement.prototype.parentElement = function() {
    return $('body');
  };

  BaseElement.prototype.addToDOM = function() {
    return this.$el.appendTo(this.parentElement());
  };

  BaseElement.prototype.render = function() {
    var el, html,
      _this = this;
    if (this.isInDOM()) {
      return;
    }
    el = this.addToDOM();
    this.setElement(el);
    html = template({
      elementCssClass: this.elementCssClass,
      html: new Handlebars.SafeString(typeof this.elementTemplate === "function" ? this.elementTemplate(this.templateOptions()) : void 0)
    });
    this.el.onload = function() {
      return _this.frameLoaded();
    };
    return this.$el.prop({
      frameBorder: 0,
      scrolling: 'no',
      allowTransparency: true,
      srcdoc: html
    });
  };

  BaseElement.prototype.templateOptions = function() {};

  BaseElement.prototype.frameLoaded = function() {
    var _this = this;
    this.setElementRoot(this.el.contentDocument.body);
    this.updateTheme();
    Browser.get('styles/toolbar.css', function(css) {
      var style;
      style = _this.el.contentDocument.createElement('style');
      style.type = 'text/css';
      style.appendChild(_this.el.contentDocument.createTextNode(css));
      return ($('head', _this.el.contentDocument)).append(style);
    });
    if (this.elementViewClass != null) {
      this.elementView = new this.elementViewClass({
        el: this.elementRoot,
        model: this.elementViewModel,
        host: this
      });
      return this.elementView.render();
    }
  };

  BaseElement.prototype.setElementRoot = function(elementRoot) {
    this.elementRoot = elementRoot;
    return this.$elementRoot = $(this.elementRoot);
  };

  BaseElement.prototype.updateTheme = function() {
    var _ref1;
    return (_ref1 = this.$elementRoot) != null ? _ref1.toggleClass('light', this.settings.get('isLightTheme')) : void 0;
  };

  BaseElement.prototype.remove = function() {
    var _ref1,
      _this = this;
    if (((_ref1 = this.elementView) != null ? _ref1.remove : void 0) != null) {
      return this.elementView.remove(function() {
        _this;
        return BaseElement.__super__.remove.apply(_this, arguments);
      });
    } else {
      return BaseElement.__super__.remove.apply(this, arguments);
    }
  };

  return BaseElement;

})(BaseView);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../templates/base_element.hbs":81,"./../models/browser.coffee":5,"./../models/settings.coffee":29,"./base_view.coffee":40,"handlebars":160}],39:[function(require,module,exports){
(function (global){
var BasePanelTab, BaseView, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

BaseView = require('./base_view.coffee');

module.exports = BasePanelTab = (function(_super) {
  __extends(BasePanelTab, _super);

  function BasePanelTab() {
    _ref = BasePanelTab.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  BasePanelTab.prototype.tableHeight = null;

  BasePanelTab.prototype.className = null;

  BasePanelTab.prototype.template = null;

  BasePanelTab.prototype.setTableHeight = function(height) {
    this.tableHeight = height;
    return this.$el.find('.scrollable').height(this.tableHeight).perfectScrollbar('update');
  };

  BasePanelTab.prototype.getTableHeight = function() {
    return this.tableHeight;
  };

  BasePanelTab.prototype.render = function() {
    if (!this.model.isValid()) {
      this.model.fetch();
    }
    this.$el.html(this.template(_.extend(this.model.toJSON(), {
      className: this.className
    })));
    if (this.tableHeight != null) {
      this.$el.find('.scrollable').height(this.tableHeight);
    }
    if (this.tableHeight == null) {
      this.tableHeight = this.$el.find('.scrollable').height();
    }
    return this.$el.find('.scrollable').perfectScrollbar();
  };

  return BasePanelTab;

})(BaseView);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./base_view.coffee":40}],40:[function(require,module,exports){
(function (global){
var $, Backbone, BaseView, Dispatcher, Onboarding, Page, Settings, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

Backbone = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null);

Backbone.$ = $;

Dispatcher = require('./event_dispatcher.coffee');

Onboarding = require('./../models/onboarding.coffee');

Settings = require('./../models/settings.coffee');

Page = require('./../models/page.coffee');

module.exports = BaseView = (function(_super) {
  __extends(BaseView, _super);

  function BaseView() {
    _ref = BaseView.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  BaseView.prototype.dispatcher = Dispatcher.getInstance();

  BaseView.prototype.settings = Settings.getInstance();

  BaseView.prototype.tooltipPlacement = 'below';

  BaseView.prototype.host = null;

  BaseView.prototype.timeout = null;

  BaseView.prototype.initialize = function(options) {
    var tipSelector,
      _this = this;
    if (options != null) {
      this.setHost(options.host);
    }
    tipSelector = '[data-tooltip]';
    this.$el.on("mouseenter.baseViewEvents" + this.cid, tipSelector, function(e) {
      return _this.startTooltipTimeout(e);
    });
    this.$el.on("mouseleave.baseViewEvents" + this.cid, tipSelector, function(e) {
      return _this.hideTooltip(e);
    });
    this.onboarding = Onboarding.getInstance();
    this.listenTo(this.onboarding, 'change:serpHighlights', this.showOnboardingHighlights);
    this.listenTo(this.onboarding, 'change:pageHighlights', this.showOnboardingHighlights);
    return this.listenTo(this.onboarding, 'change:sharedHighlights', this.showOnboardingHighlights);
  };

  BaseView.prototype.render = function() {
    return this.showOnboardingHighlights();
  };

  BaseView.prototype.setHost = function(host) {
    this.host = host;
  };

  BaseView.prototype.isInDOM = function() {
    return $.contains(document.documentElement, this.el);
  };

  BaseView.prototype.startTooltipTimeout = function(e) {
    var $container, $parent, $target, eventName, lean, left, offset, opts, parentOffset, showHighlight, text, top,
      _this = this;
    e.stopPropagation();
    $target = $(e.currentTarget);
    $container = $target.closest('.tooltip-container');
    $parent = $(e.currentTarget.ownerDocument.defaultView.frameElement);
    showHighlight = $target.hasClass('highlight');
    text = showHighlight ? $target.find('.onboarding-text').html() : $target.data('tooltip');
    if (!text) {
      return;
    }
    offset = $target.offset();
    parentOffset = $parent.offset();
    if (this.tooltipPlacement === 'below') {
      top = parentOffset.top;
      top += $container.length ? $container.height() : $parent.height();
    } else {
      top = parentOffset.top;
      if ($container.length) {
        top += $container.offset().top;
      }
    }
    top -= ($(window)).scrollTop();
    left = offset.left + parentOffset.left + ($target.outerWidth() / 2);
    if (showHighlight) {
      if (offset.left < 300) {
        left += 100;
        lean = 'lean-left';
      }
      if (offset.left > 600) {
        left -= 100;
        lean = 'lean-right';
      }
      if (offset.left > ($(window)).width() - 100) {
        left -= 50;
        lean = 'lean-far-right';
      }
    }
    opts = {
      top: top,
      left: left,
      text: text,
      placement: this.tooltipPlacement,
      lean: lean || ''
    };
    eventName = showHighlight ? 'onboarding:show-highlight' : 'tooltip:start-timeout';
    this.dispatcher.trigger(eventName, opts);
    if (showHighlight) {
      return this.timeout = setTimeout(function() {
        return _this.onboarding.removeHighlights($target.attr('class').split(' '));
      }, 50);
    }
  };

  BaseView.prototype.showOnboardingHighlights = function() {
    var button, buttons, _i, _len, _results;
    this.$el.find('.btn').removeClass('highlight');
    buttons = this.onboarding.getHighlights();
    if (!(buttons && buttons.length)) {
      return;
    }
    _results = [];
    for (_i = 0, _len = buttons.length; _i < _len; _i++) {
      button = buttons[_i];
      _results.push(this.$el.find(".btn." + button).addClass('highlight'));
    }
    return _results;
  };

  BaseView.prototype.hideTooltip = function() {
    this.dispatcher.trigger('tooltip:hide');
    return clearTimeout(this.timeout);
  };

  BaseView.prototype.remove = function(complete) {
    var _ref1;
    if ((_ref1 = this.$el) != null) {
      _ref1.off(".baseViewEvents" + this.cid);
    }
    if (this.$el) {
      BaseView.__super__.remove.apply(this, arguments);
    }
    return typeof complete === "function" ? complete() : void 0;
  };

  return BaseView;

})(Backbone.View);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../models/onboarding.coffee":16,"./../models/page.coffee":18,"./../models/settings.coffee":29,"./event_dispatcher.coffee":45}],41:[function(require,module,exports){
(function (global){
var Analytics, BAR_BORDER_PCT, BAR_HEIGHT_PCT, Browser, ChromeButton, Events, Settings, TabSettings, data, pageMod, ui;

Events = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null).Events;

Analytics = require('./../models/analytics.coffee');

Browser = require('./../models/browser.coffee');

Settings = require('./../models/settings.coffee');

TabSettings = require('./../models/tab_settings.coffee');

data = require('sdk/self').data;

pageMod = require('sdk/page-mod');

ui = require('sdk/ui');

BAR_HEIGHT_PCT = 20;

BAR_BORDER_PCT = 5;

module.exports = ChromeButton = (function() {
  function ChromeButton() {}

  ChromeButton.settings = null;

  ChromeButton.tabs = {};

  ChromeButton.onIcons = {
    19: 'images/mozicon_19x19.png',
    38: 'images/mozicon_38x38.png'
  };

  ChromeButton.offIcons = {
    19: 'images/mozicon_off_19x19.png',
    38: 'images/mozicon_off_38x38.png'
  };

  ChromeButton.firefoxWidget = null;

  ChromeButton.firefoxWorkers = [];

  ChromeButton.initialize = function() {
    var _ref,
      _this = this;
    this.settings = Settings.getInstance();
    if (typeof chrome !== "undefined" && chrome !== null) {
      if ((_ref = chrome.runtime.onStartup) != null) {
        _ref.addListener(function() {
          _this.settings.resetPanelState();
          return _this.settings.save();
        });
      }
    }
    this.settings.on('change:isButtonOn change:isMozbarOn', function() {
      return _this.render();
    });
    if (ui.ActionButton != null) {
      this.settings.resetPanelState();
      this.settings.save();
      this.settings.on('change', function() {
        return _this.settingsChanged(null, _this.settings.toJSON());
      });
    }
    if (Browser.isChrome()) {
      this.initializeChromeListeners();
    }
    this.firefoxWidget = typeof ui.ActionButton === "function" ? ui.ActionButton({
      id: 'mozbar-button',
      label: 'Show/Hide Mozbar',
      icon: data != null ? data.url(this.offIcons['19']) : void 0,
      onClick: function() {
        return _this.settings.toggleMozbar();
      }
    }) : void 0;
    if (typeof pageMod.PageMod === "function") {
      pageMod.PageMod({
        include: '*',
        attachTo: ['existing', 'top'],
        contentScriptFile: [data.url('scripts/jquery.js'), data.url('scripts/underscore.js'), data.url('scripts/backbone.js'), data.url('scripts/perfect-scrollbar.js'), data.url('scripts/jquery.mousewheel.js'), data.url('scripts/jquery.highlight.js'), data.url('scripts/raven.js'), data.url('scripts/content_page.js')],
        contentStyleFile: [data.url('styles/content_page.css')],
        contentScriptOptions: {
          'styles/toolbar.css': data.load('styles/toolbar.css')
        },
        onAttach: function(worker) {
          return _this.attachWorker(worker);
        }
      });
    }
    return this;
  };

  ChromeButton.initializeChromeListeners = function() {
    var filter,
      _this = this;
    chrome.runtime.onInstalled.addListener(function(reason) {
      _this.settings.set({
        extensionVersion: chrome.app.getDetails().version
      });
      if (reason.reason === 'update') {
        return _this.settings.save();
      }
      _this.settings.onNewInstall();
      return Analytics.getInstance().trackNewInstall();
    });
    chrome.browserAction.onClicked.addListener(function() {
      return _this.settings.toggleMozbar();
    });
    chrome.runtime.onMessage.addListener(function(request, sender, response) {
      return _this.messageReceived(request, sender, response);
    });
    filter = {
      urls: ['<all_urls>'],
      types: ['main_frame']
    };
    chrome.webRequest.onBeforeRequest.addListener(function(details) {
      return _this.beforeRequest(details);
    }, filter);
    chrome.webRequest.onHeadersReceived.addListener(function(details) {
      return _this.headersReceived(details);
    }, filter);
    chrome.webRequest.onBeforeRedirect.addListener(function(details) {
      return _this.beforeRedirect(details);
    }, filter);
    return chrome.webRequest.onCompleted.addListener(function(details) {
      return _this.completed(details);
    }, filter);
  };

  ChromeButton.initializeTab = function(id) {
    var _base;
    return (_base = this.tabs)[id] != null ? (_base = this.tabs)[id] : _base[id] = {
      tabSettings: new TabSettings,
      redirect: false
    };
  };

  ChromeButton.attachWorker = function(worker) {
    var _this = this;
    this.firefoxWorkers.push(worker);
    this.initializeTab(worker.tab.id);
    worker.on('detach', function() {
      var i, w, _i, _len, _ref, _results;
      _ref = _this.firefoxWorkers;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        w = _ref[i];
        if (w === worker) {
          _results.push(_this.firefoxWorkers.splice(i, 1));
        }
      }
      return _results;
    });
    worker.port.emit('settingsChanged', this.settings.toJSON());
    worker.port.on('settingsChanged', function(attributes) {
      return _this.settingsChanged(worker, attributes);
    });
    worker.port.on('setTabSettings', function(data) {
      return _this.setTabSettings(worker.tab.id, data);
    });
    return worker.port.on('getTabSettings', function() {
      return worker.port.emit('getTabSettings:response', _this.getTabSettings(worker.tab.id));
    });
  };

  ChromeButton.settingsChanged = function(fromWorker, attributes) {
    var worker, _i, _len, _ref, _results;
    this.settings.set(attributes);
    this.settings.save();
    _ref = this.firefoxWorkers;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      worker = _ref[_i];
      if (worker !== fromWorker) {
        _results.push(worker.port.emit('settingsChanged', attributes));
      }
    }
    return _results;
  };

  ChromeButton.render = function() {
    var _this = this;
    return typeof chrome !== "undefined" && chrome !== null ? chrome.tabs.query({}, function(tabs) {
      var tab, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = tabs.length; _i < _len; _i++) {
        tab = tabs[_i];
        _results.push(_this.renderTabId(tab.id));
      }
      return _results;
    }) : void 0;
  };

  ChromeButton.renderTabId = function(tabId) {
    var icons, isButtonOn, isMozbarOn, title, _ref, _ref1;
    isMozbarOn = this.settings.get('isMozbarOn');
    isButtonOn = this.settings.get('isButtonOn');
    icons = isButtonOn ? {
      path: this.onIcons
    } : {
      path: this.offIcons
    };
    title = 'MozBar from Moz\n(Ctrl+Shift+Alt+M)';
    if ((_ref = this.firefoxWidget) != null) {
      _ref.icon = data != null ? data.url(icons.path['19']) : void 0;
    }
    if (isButtonOn && !isMozbarOn && !_.isUndefined((_ref1 = this.tabs[tabId]) != null ? _ref1.da : void 0)) {
      icons = {
        imageData: this.getNumberIcons(this.tabs[tabId].da)
      };
      title = 'Domain Authority for this domain';
    }
    if (typeof chrome !== "undefined" && chrome !== null) {
      chrome.browserAction.setIcon(_.extend(icons, {
        tabId: tabId
      }));
    }
    return typeof chrome !== "undefined" && chrome !== null ? chrome.browserAction.setTitle({
      tabId: tabId,
      title: title
    }) : void 0;
  };

  ChromeButton.messageReceived = function(request, sender, response) {
    switch (request.type) {
      case 'status-history':
        return response(this.tabs[sender.tab.id].statuses);
      case 'setTabSettings':
        return this.setTabSettings(sender.tab.id, request.data);
      case 'getTabSettings':
        return response(this.getTabSettings(sender.tab.id));
      case 'metricsChanged':
        this.initializeTab(sender.tab.id);
        this.tabs[sender.tab.id].da = request.data.nicePda;
        return this.renderTabId(sender.tab.id);
    }
  };

  ChromeButton.beforeRequest = function(details) {
    this.initializeTab(details.tabId);
    if (!this.tabs[details.tabId].redirect) {
      return this.tabs[details.tabId].statuses = [];
    }
  };

  ChromeButton.beforeRedirect = function(details) {
    return this.tabs[details.tabId].redirect = true;
  };

  ChromeButton.headersReceived = function(details) {
    this.initializeTab(details.tabId);
    if (!this.tabs[details.tabId].redirect) {
      this.tabs[details.tabId].statuses = [];
    }
    return this.tabs[details.tabId].statuses.push({
      status: details.statusLine,
      url: details.url
    });
  };

  ChromeButton.completed = function(details) {
    this.initializeTab(details.tabId);
    return this.tabs[details.tabId].redirect = false;
  };

  ChromeButton.setTabSettings = function(id, data) {
    var _ref;
    return (_ref = this.tabs[id]) != null ? _ref.tabSettings.set(data) : void 0;
  };

  ChromeButton.getTabSettings = function(id) {
    var _ref;
    return (_ref = this.tabs[id]) != null ? _ref.tabSettings.toJSON() : void 0;
  };

  ChromeButton.getNumberIcons = function(n) {
    return {
      19: this.createNumberIcon(n, 19, 19).getContext('2d').getImageData(0, 0, 19, 19),
      38: this.createNumberIcon(n, 38, 38).getContext('2d').getImageData(0, 0, 38, 38)
    };
  };

  ChromeButton.createNumberIcon = function(n, width, height) {
    var barHeight, barWidth, barX, barY, border, canvas, context, fontSize;
    border = Math.round(height * (BAR_BORDER_PCT / 100));
    barHeight = (BAR_HEIGHT_PCT / 100) * height;
    barX = border;
    barY = height - barHeight - border;
    barWidth = width - (border * 2);
    canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    context = canvas.getContext('2d');
    context.fillStyle = '#4e5c5f';
    context.fillRect(0, 0, width, height);
    context.fillStyle = '#e6e8e8';
    context.fillRect(barX, barY, barWidth, barHeight);
    context.fillStyle = '#4dbdeb';
    context.fillRect(barX, barY, barWidth * (n / 100), barHeight);
    fontSize = width === 19 ? 10 : 20;
    context.font = "bold " + fontSize + "px Open Sans, sans-serif";
    context.fillStyle = '#e6e8e8';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(n, width / 2, (height - barHeight) / 2);
    return canvas;
  };

  return ChromeButton;

})();


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../models/analytics.coffee":4,"./../models/browser.coffee":5,"./../models/settings.coffee":29,"./../models/tab_settings.coffee":30,"sdk/page-mod":113,"sdk/self":113,"sdk/ui":113}],42:[function(require,module,exports){
var BaseView, ButtonNotification, UrlMetrics, browserButton, template, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BaseView = require('./base_view.coffee');

template = require('./../../templates/button_notification.hbs');

browserButton = require('./browser_button.coffee');

UrlMetrics = require('./../models/url_metrics.coffee');

module.exports = ButtonNotification = (function(_super) {
  __extends(ButtonNotification, _super);

  function ButtonNotification() {
    _ref = ButtonNotification.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  ButtonNotification.prototype.events = {
    'click .close': 'close'
  };

  ButtonNotification.prototype.render = function() {
    var icon, img, pda, urlMetrics;
    this.$el.html(template());
    urlMetrics = UrlMetrics.getInstance();
    pda = urlMetrics.get('nicePda');
    if (pda == null) {
      pda = 100;
    }
    img = this.$el.find('.icon')[0];
    icon = browserButton.createNumberIcon(pda, 19, 19);
    return img.src = icon.toDataURL();
  };

  ButtonNotification.prototype.close = function() {
    this.host.remove();
    return false;
  };

  return ButtonNotification;

})(BaseView);


},{"./../../templates/button_notification.hbs":82,"./../models/url_metrics.coffee":34,"./base_view.coffee":40,"./browser_button.coffee":41}],43:[function(require,module,exports){
(function (global){
var $, BaseElement, ButtonNotification, ButtonNotificationElement, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

BaseElement = require('./base_element.coffee');

ButtonNotification = require('./button_notification.coffee');

module.exports = ButtonNotificationElement = (function(_super) {
  __extends(ButtonNotificationElement, _super);

  function ButtonNotificationElement() {
    _ref = ButtonNotificationElement.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  ButtonNotificationElement.prototype.DISPLAY_MS = 2500;

  ButtonNotificationElement.prototype.elementCssClass = 'button-notification';

  ButtonNotificationElement.prototype.elementViewClass = ButtonNotification;

  ButtonNotificationElement.prototype.id = 'mozbar-button-notification-wGA7MhRhQ3WS';

  ButtonNotificationElement.prototype.render = function() {
    var _this = this;
    ButtonNotificationElement.__super__.render.apply(this, arguments);
    return setTimeout(function() {
      return _this.$elementRoot.closest('html, body').animate({
        opacity: 0
      }, 500, function() {
        return _this.remove();
      });
    }, this.DISPLAY_MS);
  };

  return ButtonNotificationElement;

})(BaseElement);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./base_element.coffee":38,"./button_notification.coffee":42}],44:[function(require,module,exports){
(function (global){
var $, AddressBarHighlight, Analytics, ButtonMetrics, ButtonNotificationElement, ContentPage, Dispatcher, Highlighter, KeywordDifficultyElement, MozbarElement, OnboardingDialog, OnboardingTipElement, Page, SerpAttributes, SerpElement, Settings, TooltipElement, User;

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

Analytics = require('./../models/analytics.coffee');

AddressBarHighlight = require('./address_bar_highlight.coffee');

ButtonNotificationElement = require('./button_notification_element.coffee');

Dispatcher = require('./event_dispatcher.coffee');

Highlighter = require('./highlighter.coffee');

MozbarElement = require('./mozbar_element.coffee');

Page = require('./../models/page.coffee');

User = require('./../models/user.coffee');

SerpAttributes = require('./../models/serp_attributes.coffee');

SerpElement = require('./serp_element.coffee');

TooltipElement = require('./tooltip_element.coffee');

OnboardingTipElement = require('./onboarding_tip_element.coffee');

OnboardingDialog = require('./onboarding_dialog.coffee');

KeywordDifficultyElement = require('./keyword_difficulty_element.coffee');

Settings = require('./../models/settings.coffee');

ButtonMetrics = require('./../models/button_metrics.coffee');

require('./../helpers/handlebars_helpers.coffee');

require('./../helpers/handlebars_partials.coffee');

module.exports = ContentPage = (function() {
  function ContentPage() {}

  ContentPage.settings = Settings.getInstance();

  ContentPage.analytics = Analytics.getInstance();

  ContentPage.dispatcher = Dispatcher.getInstance();

  ContentPage.mozbar = null;

  ContentPage.serpItems = [];

  ContentPage.domChangedTimer = null;

  ContentPage.tooltip = new TooltipElement;

  ContentPage.onboardingTip = new OnboardingTipElement;

  ContentPage.keywordDifficulty = null;

  ContentPage.user = null;

  ContentPage.buttonMetrics = null;

  ContentPage.wasButtonOn = null;

  ContentPage.wasMozbarOn = null;

  ContentPage.initialize = function() {
    var _this = this;
    Highlighter.initialize();
    ($(document)).on('keydown', function(e) {
      return _this.keydown(e);
    });
    this.mozbarOnChanged();
    this.settings.on('change:isMozbarOn', function() {
      return _this.mozbarOnChanged();
    });
    if (Page.isSerp()) {
      document.addEventListener('DOMNodeInserted', function() {
        return _this.domNodeInserted();
      });
    }
    this.user = User.getInstance();
    this.user.on('change', function() {
      return _this.userChanged();
    });
    return this;
  };

  ContentPage.mozbarOnChanged = function() {
    var isMozbarOn;
    isMozbarOn = this.settings.get('isMozbarOn');
    if (this.wasMozbarOn == null) {
      this.wasMozbarOn = isMozbarOn;
    }
    if (this.wasMozbarOn !== isMozbarOn && !isMozbarOn) {
      setTimeout(function() {
        return (new ButtonNotificationElement).render();
      }, 200);
    }
    if (this.settings.get('isButtonOn') && !isMozbarOn) {
      if (this.buttonMetrics == null) {
        this.buttonMetrics = new ButtonMetrics();
      }
      this.buttonMetrics.fetch();
    }
    this.wasMozbarOn = isMozbarOn;
    return this.render();
  };

  ContentPage.keydown = function(e) {
    if (e.which === 77 && e.ctrlKey && e.shiftKey && e.altKey) {
      return this.settings.toggleMozbar();
    }
  };

  ContentPage.domNodeInserted = function() {
    var _this = this;
    clearTimeout(this.domChangedTimer);
    if (!this.settings.get('isMozbarOn') || Page.isBlacklisted()) {
      return;
    }
    return this.domChangedTimer = setTimeout(function() {
      _this.renderSerpItems();
      if (Page.getSerpEngine() === 'google') {
        return _this.renderKeywordDifficulty();
      }
    }, 100);
  };

  ContentPage.render = function() {
    if (this.settings.get('isButtonOn')) {
      this.analytics.trackActiveUser();
    }
    if (!this.settings.get('isMozbarOn') || Page.isBlacklisted()) {
      this.remove();
      return;
    }
    if (this.mozbar == null) {
      this.mozbar = new MozbarElement({
        id: 'mozbar-wGA7MhRhQ3WS'
      });
    }
    this.mozbar.render();
    this.addressBarHighlight = new AddressBarHighlight();
    this.onboardingDialog = new OnboardingDialog();
    if (Page.isSerp()) {
      this.renderSerpItems();
    }
    this.renderKeywordDifficulty();
    return this.analytics.trackActiveUser();
  };

  ContentPage.renderSerpItems = function() {
    var item,
      _this = this;
    this.serpItems = (function() {
      var _i, _len, _ref, _results;
      _ref = this.serpItems;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (item.isInDOM()) {
          _results.push(item);
        }
      }
      return _results;
    }).call(this);
    return ($(Page.getSerpConfig().selector)).not(':has(.mozbar-serp-item-wGA7MhRhQ3WS)').each(function(i, el) {
      var model, serpElement;
      model = new SerpAttributes({
        el: el,
        position: i + 1
      });
      serpElement = new SerpElement({
        model: model
      });
      serpElement.render();
      return _this.serpItems.push(serpElement);
    });
  };

  ContentPage.renderKeywordDifficulty = function() {
    if (!this.settings.get('isMozbarOn')) {
      return;
    }
    if (Page.getSerpEngine() !== 'google') {
      return;
    }
    if (this.keywordDifficulty == null) {
      this.keywordDifficulty = new KeywordDifficultyElement;
    }
    if (this.keywordDifficulty.isInDOM()) {
      return;
    }
    if (!this.keywordDifficulty.parentElement().length) {
      return;
    }
    return this.keywordDifficulty.render();
  };

  ContentPage.userChanged = function() {
    var _ref;
    if (this.user.get('isPro')) {
      return this.renderKeywordDifficulty();
    } else {
      return (_ref = this.keywordDifficulty) != null ? _ref.remove() : void 0;
    }
  };

  ContentPage.remove = function() {
    var item, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4;
    if ((_ref = this.mozbar) != null) {
      _ref.remove();
    }
    this.mozbar = null;
    _ref1 = this.serpItems;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      item = _ref1[_i];
      item.remove();
    }
    this.serpItems = [];
    if ((_ref2 = this.keywordDifficulty) != null) {
      _ref2.remove();
    }
    if ((_ref3 = this.addressBarHighlight) != null) {
      _ref3.remove();
    }
    return (_ref4 = this.onboardingDialog) != null ? _ref4.remove() : void 0;
  };

  return ContentPage;

})();


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../helpers/handlebars_helpers.coffee":2,"./../helpers/handlebars_partials.coffee":3,"./../models/analytics.coffee":4,"./../models/button_metrics.coffee":6,"./../models/page.coffee":18,"./../models/serp_attributes.coffee":26,"./../models/settings.coffee":29,"./../models/user.coffee":35,"./address_bar_highlight.coffee":36,"./button_notification_element.coffee":43,"./event_dispatcher.coffee":45,"./highlighter.coffee":48,"./keyword_difficulty_element.coffee":53,"./mozbar_element.coffee":55,"./onboarding_dialog.coffee":56,"./onboarding_tip_element.coffee":58,"./serp_element.coffee":70,"./tooltip_element.coffee":78}],45:[function(require,module,exports){
(function (global){
var Backbone, EventDispatcher, _;

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

Backbone = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null);

module.exports = EventDispatcher = (function() {
  function EventDispatcher() {}

  EventDispatcher.eventDispatcher = null;

  EventDispatcher.getInstance = function() {
    return this.eventDispatcher != null ? this.eventDispatcher : this.eventDispatcher = new EventDispatcher();
  };

  _.extend(EventDispatcher.prototype, Backbone.Events);

  return EventDispatcher;

})();


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],46:[function(require,module,exports){
var BaseDialog, HelpDialog, HelpView, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

HelpView = require('./help_view.coffee');

BaseDialog = require('./base_dialog.coffee');

module.exports = HelpDialog = (function(_super) {
  __extends(HelpDialog, _super);

  function HelpDialog() {
    _ref = HelpDialog.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  HelpDialog.prototype.elementCssClass = 'dialog help-dialog';

  HelpDialog.prototype.elementViewClass = HelpView;

  HelpDialog.prototype.overlay = null;

  HelpDialog.prototype.id = 'mozbar-help-dialog-wGA7MhRhQ3WS';

  HelpDialog.prototype.render = function() {
    HelpDialog.__super__.render.apply(this, arguments);
    return this.$el.css({
      top: this.options.top,
      bottom: this.options.bottom,
      left: this.options.left - this.$el.width() + 20
    });
  };

  return HelpDialog;

})(BaseDialog);


},{"./base_dialog.coffee":37,"./help_view.coffee":47}],47:[function(require,module,exports){
(function (global){
var $, Analytics, BaseView, HelpView, Onboarding, template, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

Analytics = require('./../models/analytics.coffee');

BaseView = require('./base_view.coffee');

Onboarding = require('./../models/onboarding.coffee');

template = require('./../../templates/help_dialog.hbs');

module.exports = HelpView = (function(_super) {
  __extends(HelpView, _super);

  function HelpView() {
    _ref = HelpView.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  HelpView.prototype.events = {
    'click .tour': 'showTour'
  };

  HelpView.prototype.render = function() {
    this.$el.html(template);
    return ($('#mozbar-help-dialog-wGA7MhRhQ3WS')).hide().slideDown('fast');
  };

  HelpView.prototype.showTour = function() {
    this.close();
    Onboarding.getInstance().restart();
    return Analytics.getInstance().trackInitiateOnboarding();
  };

  HelpView.prototype.close = function() {
    this.host.remove();
    return false;
  };

  HelpView.prototype.remove = function(callback) {
    var _this = this;
    return ($('#mozbar-help-dialog-wGA7MhRhQ3WS')).slideUp('fast', function() {
      HelpView.__super__.remove.apply(_this, arguments);
      return callback != null ? callback.apply(_this) : void 0;
    });
  };

  return HelpView;

})(BaseView);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../templates/help_dialog.hbs":83,"./../models/analytics.coffee":4,"./../models/onboarding.coffee":16,"./base_view.coffee":40}],48:[function(require,module,exports){
(function (global){
var $, Dispatcher, Highlighter;

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

Dispatcher = require('./event_dispatcher.coffee');

module.exports = Highlighter = (function() {
  function Highlighter() {}

  Highlighter.dispatcher = Dispatcher.getInstance();

  Highlighter.highlightOpts = {
    className: 'mozbar-highlight-keyword-wGA7MhRhQ3WS'
  };

  Highlighter.initialize = function() {
    var _this = this;
    this.dispatcher.on('highlight-links:change', function(type, isOn) {
      return _this.highlightLinksChange(type, isOn);
    });
    return this.dispatcher.on('highlight-keyword:change', function(keyword) {
      return _this.highlightKeyword(keyword);
    });
  };

  Highlighter.highlightLinksChange = function(type, isOn) {
    if (isOn) {
      return this.highlight(type);
    } else {
      return this.unhighlight(type);
    }
  };

  Highlighter.highlight = function(type) {
    if (type !== 'keyword') {
      return this.getElements(type).addClass("mozbar-highlight-" + type + "-wGA7MhRhQ3WS");
    }
  };

  Highlighter.unhighlight = function(type) {
    if (type === 'keyword') {
      return this.unhighlightKeyword();
    } else {
      return this.getElements(type).removeClass("mozbar-highlight-" + type + "-wGA7MhRhQ3WS");
    }
  };

  Highlighter.getElements = function(type) {
    var links;
    links = [];
    switch (type) {
      case 'followed':
        links = this.hasMetaNoFollow() ? $() : $('a:not([rel*=follow])');
        break;
      case 'no-followed':
        links = this.hasMetaNoFollow() ? $('a') : $('a[rel*=nofollow]');
        break;
      case 'external':
        links = ($('a[href^="http"]')).not("a[href*='" + document.location.host + "']");
        break;
      case 'internal':
        links = ($("a[href*='" + document.location.host + "']")).add('a:not([href^="http"])');
    }
    return links;
  };

  Highlighter.hasMetaNoFollow = function() {
    var meta;
    meta = ($('meta[name]')).filter(function() {
      return this.name.toLowerCase() === 'robots' && this.content.toLowerCase().indexOf('nofollow') > -1;
    });
    return meta.length > 0;
  };

  Highlighter.highlightKeyword = function(keyword) {
    this.unhighlightKeyword();
    ($('body')).highlight(keyword, this.highlightOpts);
    return ($('#mozbar-wGA7MhRhQ3WS')).unhighlight(this.highlightOpts);
  };

  Highlighter.unhighlightKeyword = function() {
    return ($('body')).unhighlight(this.highlightOpts);
  };

  return Highlighter;

})();


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./event_dispatcher.coffee":45}],49:[function(require,module,exports){
(function (global){
var BasePanelTab, HttpStatus, View, template, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

View = (typeof window !== "undefined" ? window.Backbone : typeof global !== "undefined" ? global.Backbone : null).View;

BasePanelTab = require('./base_panel_tab.coffee');

template = require('./../../templates/http_status_tab.hbs');

module.exports = HttpStatus = (function(_super) {
  __extends(HttpStatus, _super);

  function HttpStatus() {
    _ref = HttpStatus.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  HttpStatus.prototype.template = template;

  return HttpStatus;

})(BasePanelTab);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../templates/http_status_tab.hbs":84,"./base_panel_tab.coffee":39}],50:[function(require,module,exports){
var BasePanelTab, InboundLinks, template, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BasePanelTab = require('./base_panel_tab.coffee');

template = require('./../../templates/inbound_links.hbs');

module.exports = InboundLinks = (function(_super) {
  __extends(InboundLinks, _super);

  function InboundLinks() {
    _ref = InboundLinks.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  InboundLinks.prototype.className = 'inbound-links';

  InboundLinks.prototype.template = template;

  return InboundLinks;

})(BasePanelTab);


},{"./../../templates/inbound_links.hbs":85,"./base_panel_tab.coffee":39}],51:[function(require,module,exports){
(function (global){
var $, Analytics, Browser, HttpStatus, HttpStatusList, InboundLinks, InfoPanel, PageAttributes, PageAttributesModel, PageElements, PageElementsModel, PanelView, Semantics, SemanticsModel, UrlMetrics, template, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

Analytics = require('./../models/analytics.coffee');

Browser = require('./../models/browser.coffee');

PanelView = require('./panel_view.coffee');

PageAttributes = require('./page_attributes.coffee');

PageElements = require('./page_elements.coffee');

HttpStatus = require('./http_status.coffee');

HttpStatusList = require('./../models/http_status_list.coffee');

InboundLinks = require('./inbound_links.coffee');

Semantics = require('./semantics.coffee');

PageElementsModel = require('./../models/page_elements.coffee');

PageAttributesModel = require('./../models/page_attributes.coffee');

UrlMetrics = require('./../models/url_metrics.coffee');

SemanticsModel = require('./../models/semantics.coffee');

template = require('./../../templates/info_panel.hbs');

module.exports = InfoPanel = (function(_super) {
  __extends(InfoPanel, _super);

  function InfoPanel() {
    _ref = InfoPanel.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  InfoPanel.prototype.PANEL_HEIGHT = 350;

  InfoPanel.prototype.EXPANDED_PANEL_MARGIN = 50;

  InfoPanel.prototype.className = 'info-panel';

  InfoPanel.prototype.analytics = Analytics.getInstance();

  InfoPanel.prototype.isFullScreen = false;

  InfoPanel.prototype.selectedTab = 'page-elements';

  InfoPanel.prototype.tabs = {};

  InfoPanel.prototype.tableHeight = 0;

  InfoPanel.prototype.events = {
    'click .tabs li': 'tabClicked',
    'click .expand': 'toggleFullScreen',
    'mousedown .gutter': 'startDrag'
  };

  InfoPanel.prototype.initialize = function(options) {
    var k, tab, _ref1, _results;
    InfoPanel.__super__.initialize.apply(this, arguments);
    this.tabs = {
      'page-elements': new PageElements({
        model: new PageElementsModel
      }),
      'general-attributes': new PageAttributes({
        model: new PageAttributesModel
      }),
      'inbound-links': new InboundLinks({
        model: UrlMetrics.getInstance()
      }),
      'semantics': new Semantics({
        model: new SemanticsModel
      }),
      'http-status': new HttpStatus({
        model: new HttpStatusList
      })
    };
    this.listenTo(this.model, 'change', this.render);
    _ref1 = this.tabs;
    _results = [];
    for (k in _ref1) {
      tab = _ref1[k];
      _results.push(this.listenTo(tab.model, 'change sync', this.render));
    }
    return _results;
  };

  InfoPanel.prototype.tabClicked = function(event) {
    this.selectedTab = ($(event.currentTarget)).data('tab');
    this.trackPanelView();
    return this.render();
  };

  InfoPanel.prototype.trackPanelView = function() {
    return this.analytics.trackPanelView(this.selectedTab);
  };

  InfoPanel.prototype.render = function() {
    var _ref1, _ref2;
    if (!this.isOpen) {
      return;
    }
    if (!this.model.isValid()) {
      this.model.fetch();
    }
    this.$el.html(template((_ref1 = this.model.at(0)) != null ? _ref1.toJSON() : void 0));
    this.$el.find(".tabs li[data-tab=" + this.selectedTab + "]").addClass('active');
    if (Browser.browserName() === 'firefox') {
      this.$el.find('li[data-tab="http-status"]').hide();
    }
    this.tabs[this.selectedTab].setElement(this.$el.find('.tab'));
    this.tabs[this.selectedTab].render();
    if (!this.tableHeight) {
      this.tableHeight = (_ref2 = this.tabs[this.selectedTab]) != null ? _ref2.getTableHeight() : void 0;
    }
    this.tabs[this.selectedTab].setTableHeight(this.tableHeight);
    return this.$el.find('.scrollable').perfectScrollbar();
  };

  InfoPanel.prototype.open = function(complete) {
    InfoPanel.__super__.open.apply(this, arguments);
    return this.render();
  };

  InfoPanel.prototype.toggleFullScreen = function() {
    var $tbody, change, newHeight,
      _this = this;
    this.isFullScreen = !this.isFullScreen;
    newHeight = this.isFullScreen ? ($(window)).innerHeight() - this.EXPANDED_PANEL_MARGIN : this.PANEL_HEIGHT;
    change = (this.$el.height() - newHeight).toString();
    change = change.replace(/-/, '+=').replace(/^\d/, '-=$&');
    $tbody = this.$el.find('table tbody');
    $tbody.animate({
      height: change
    }, this.host.PANEL_SWING_DURATION, 'swing', function() {
      return _this.tabs[_this.selectedTab].setTableHeight($tbody.height());
    });
    return this.updatePanelHeight(newHeight);
  };

  InfoPanel.prototype.startDrag = function(e) {
    var $documents, startingHeight, startingTableHeight, startingY,
      _this = this;
    startingHeight = this.$el.height();
    startingTableHeight = this.tabs[this.selectedTab].getTableHeight();
    startingY = e.pageY;
    $documents = ($(document)).add(($('#mozbar-wGA7MhRhQ3WS')).contents());
    return $documents.on('mousemove', function(e) {
      var delta;
      delta = e.pageY - startingY;
      _this.$el.height(startingHeight + delta);
      _this.tabs[_this.selectedTab].setTableHeight(startingTableHeight + delta);
      _this.host.setPanelHeight(startingHeight + delta);
      return $documents.on('mouseup', function(e) {
        return $documents.off('mousemove');
      });
    });
  };

  return InfoPanel;

})(PanelView);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../templates/info_panel.hbs":86,"./../models/analytics.coffee":4,"./../models/browser.coffee":5,"./../models/http_status_list.coffee":13,"./../models/page_attributes.coffee":19,"./../models/page_elements.coffee":21,"./../models/semantics.coffee":25,"./../models/url_metrics.coffee":34,"./http_status.coffee":49,"./inbound_links.coffee":50,"./page_attributes.coffee":61,"./page_elements.coffee":62,"./panel_view.coffee":64,"./semantics.coffee":69}],52:[function(require,module,exports){
(function (global){
var $, Analytics, BaseView, Dispatcher, KeywordDifficulty, template, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

Analytics = require('./../models/analytics.coffee');

Dispatcher = require('./event_dispatcher.coffee');

BaseView = require('./base_view.coffee');

template = require('./../../templates/keyword_difficulty.hbs');

module.exports = KeywordDifficulty = (function(_super) {
  __extends(KeywordDifficulty, _super);

  function KeywordDifficulty() {
    _ref = KeywordDifficulty.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  KeywordDifficulty.prototype.analytics = Analytics.getInstance();

  KeywordDifficulty.prototype.events = {
    'click .activate-keyword-difficulty': 'showDifficulty'
  };

  KeywordDifficulty.prototype.initialize = function(options) {
    var _this = this;
    KeywordDifficulty.__super__.initialize.apply(this, arguments);
    this.listenTo(this.model, 'change', this.render);
    return ($(window)).on('hashchange', function() {
      return _this.model.reset();
    });
  };

  KeywordDifficulty.prototype.render = function() {
    var _this = this;
    this.$el.html(template(this.model.toJSON()));
    this.$el.find('.logged-out').click(function() {
      return _this.analytics.trackEvent('KWD/Trial CTA Clicked');
    });
    return KeywordDifficulty.__super__.render.apply(this, arguments);
  };

  KeywordDifficulty.prototype.showDifficulty = function() {
    this.hideTooltip();
    this.model.fetch();
    return this.analytics.trackKeywordDifficulty();
  };

  return KeywordDifficulty;

})(BaseView);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../templates/keyword_difficulty.hbs":87,"./../models/analytics.coffee":4,"./base_view.coffee":40,"./event_dispatcher.coffee":45}],53:[function(require,module,exports){
(function (global){
var $, BaseElement, KeywordDifficulty, KeywordDifficultyElement, KeywordDifficultyModel, Page, template, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

BaseElement = require('./base_element.coffee');

template = require('./../../templates/keyword_difficulty.hbs');

KeywordDifficulty = require('./keyword_difficulty.coffee');

KeywordDifficultyModel = require('./../models/keyword_difficulty.coffee');

Page = require('./../models/page.coffee');

module.exports = KeywordDifficultyElement = (function(_super) {
  __extends(KeywordDifficultyElement, _super);

  function KeywordDifficultyElement() {
    _ref = KeywordDifficultyElement.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  KeywordDifficultyElement.prototype.id = 'mozbar-keyword-difficulty-wGA7MhRhQ3WS';

  KeywordDifficultyElement.prototype.elementTemplate = template;

  KeywordDifficultyElement.prototype.elementCssClass = 'keyword-difficulty';

  KeywordDifficultyElement.prototype.elementViewClass = KeywordDifficulty;

  KeywordDifficultyElement.prototype.elementViewModel = new KeywordDifficultyModel;

  KeywordDifficultyElement.prototype.parentElement = function() {
    return $(Page.getSerpConfig().searchBox);
  };

  KeywordDifficultyElement.prototype.addToDOM = function() {
    this.parentElement().css({
      width: 190,
      position: 'relative'
    });
    return this.$el.appendTo(this.parentElement());
  };

  return KeywordDifficultyElement;

})(BaseElement);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../templates/keyword_difficulty.hbs":87,"./../models/keyword_difficulty.coffee":14,"./../models/page.coffee":18,"./base_element.coffee":38,"./keyword_difficulty.coffee":52}],54:[function(require,module,exports){
(function (global){
var $, Analytics, Dispatcher, LinksPanel, PanelView, linksPanel, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

Analytics = require('./../models/analytics.coffee');

PanelView = require('./panel_view.coffee');

linksPanel = require('./../../templates/links_panel.hbs');

Dispatcher = require('./event_dispatcher.coffee');

module.exports = LinksPanel = (function(_super) {
  __extends(LinksPanel, _super);

  function LinksPanel() {
    _ref = LinksPanel.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  LinksPanel.prototype.PANEL_HEIGHT = 50;

  LinksPanel.prototype.analytics = Analytics.getInstance();

  LinksPanel.prototype.dispatcher = Dispatcher.getInstance();

  LinksPanel.prototype.isOpen = false;

  LinksPanel.prototype.el = linksPanel();

  LinksPanel.prototype.events = {
    'click .link-type': 'toggleHighlight',
    'keyup .search input': 'highlightKeyword'
  };

  LinksPanel.prototype.initialize = function(options) {
    LinksPanel.__super__.initialize.apply(this, arguments);
    return this.listenTo(this.model, 'change', this.updateFromTabSettings);
  };

  LinksPanel.prototype.updateFromTabSettings = function() {
    var $keywordEl, keyword, links, type, _i, _len;
    links = this.model.get('highlightLinks') || [];
    for (_i = 0, _len = links.length; _i < _len; _i++) {
      type = links[_i];
      this.toggleState(type, true);
    }
    $keywordEl = this.$el.find('.search input');
    keyword = this.model.get('highlightKeyword');
    if ($keywordEl.val() === '' && keyword !== '') {
      $keywordEl.val(keyword);
      if (links.indexOf('keyword') > -1) {
        return this.highlightKeyword();
      }
    }
  };

  LinksPanel.prototype.toggleHighlight = function(e) {
    var $input, $target, isOn, type;
    $target = $(e.currentTarget);
    type = $target.data('type');
    isOn = !$target.hasClass('active');
    this.toggleState(type, isOn);
    this.model.toggleHighlightLink(type, isOn);
    this.model.save();
    if (isOn && type === 'keyword') {
      $input = this.$el.find('.search input');
      if ($input.val() === '') {
        $input.focus();
      }
      return this.highlightKeyword();
    }
  };

  LinksPanel.prototype.toggleState = function(type, isOn) {
    this.$el.find(".link-type." + type).toggleClass('active', isOn);
    return this.dispatcher.trigger('highlight-links:change', type, isOn);
  };

  LinksPanel.prototype.highlightKeyword = function() {
    var isOn, keyword;
    isOn = this.$el.find('.link-type.keyword').hasClass('active');
    if (!isOn) {
      this.toggleState('keyword', true);
    }
    keyword = this.$el.find('.search input').val();
    this.dispatcher.trigger('highlight-keyword:change', keyword);
    this.model.toggleHighlightLink('keyword', isOn);
    this.model.set('highlightKeyword', keyword);
    return this.model.save();
  };

  LinksPanel.prototype.trackPanelView = function() {
    return this.analytics.trackPanelView('links-panel');
  };

  LinksPanel.prototype.getLinkTypes = function() {
    return this.$el.find('.link-type').map(function() {
      return ($(this)).attr('data-type');
    });
  };

  return LinksPanel;

})(PanelView);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../templates/links_panel.hbs":88,"./../models/analytics.coffee":4,"./event_dispatcher.coffee":45,"./panel_view.coffee":64}],55:[function(require,module,exports){
(function (global){
var $, BaseElement, HelpDialog, MozbarElement, ProfilesDropDown, SettingsDialog, Toolbar, User, toolbarTemplate, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

BaseElement = require('./base_element.coffee');

ProfilesDropDown = require('./profiles_drop_down.coffee');

SettingsDialog = require('./settings_dialog.coffee');

HelpDialog = require('./help_dialog.coffee');

Toolbar = require('./toolbar.coffee');

toolbarTemplate = require('./../../templates/toolbar.hbs');

User = require('./../models/user.coffee');

module.exports = MozbarElement = (function(_super) {
  __extends(MozbarElement, _super);

  function MozbarElement() {
    _ref = MozbarElement.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  MozbarElement.prototype.TOOLBAR_HEIGHT = 43;

  MozbarElement.prototype.PANEL_SWING_DURATION = 300;

  MozbarElement.prototype.elementViewClass = Toolbar;

  MozbarElement.prototype.elementTemplate = toolbarTemplate;

  MozbarElement.prototype.profilesDropDown = null;

  MozbarElement.prototype.profilesDialog = null;

  MozbarElement.prototype.settingsDialog = null;

  MozbarElement.prototype.helpDialog = null;

  MozbarElement.prototype.user = null;

  MozbarElement.prototype.topElements = null;

  MozbarElement.prototype.initialize = function() {
    var _this = this;
    MozbarElement.__super__.initialize.apply(this, arguments);
    this.settings.on('change:isDockedOnBottom', function() {
      return _this.toggleDockPosition();
    });
    this.user = User.getInstance();
    return this.listenTo(this.user, 'change:isPro', this.render);
  };

  MozbarElement.prototype.render = function() {
    var isDockedOnBottom,
      _this = this;
    MozbarElement.__super__.render.apply(this, arguments);
    isDockedOnBottom = this.settings.get('isDockedOnBottom');
    this.$el.toggleClass('bottom', isDockedOnBottom);
    if (!isDockedOnBottom) {
      ($('body')).addClass('mozbar-margin-wGA7MhRhQ3WS');
      return setTimeout(function() {
        return _this.updateFixedTop(_this.TOOLBAR_HEIGHT);
      }, 20);
    }
  };

  MozbarElement.prototype.templateOptions = function() {
    return {
      user: User.getInstance()
    };
  };

  MozbarElement.prototype.setElementRoot = function() {
    MozbarElement.__super__.setElementRoot.apply(this, arguments);
    return this.updatePanelOrder();
  };

  MozbarElement.prototype.updateFixedTop = function(height) {
    if (this.topElements == null) {
      this.topElements = ($('body *')).filter(function() {
        var style;
        style = window.getComputedStyle(this);
        return style.position === 'fixed' && style.top === '0px' && !/^mozbar/.test(this.id);
      });
    }
    return this.topElements.each(function() {
      return this.style.setProperty('top', "" + height + "px", 'important');
    });
  };

  MozbarElement.prototype.updatePanelHeight = function(panelHeight, complete) {
    var newHeight;
    newHeight = this.calculateMobarHeight(panelHeight);
    if (this.$el.height() === newHeight) {
      if (complete != null) {
        complete.apply(this.el);
      }
      return;
    }
    ($('.mozbar-margin-wGA7MhRhQ3WS')).animate({
      'margin-top': newHeight
    }, this.PANEL_SWING_DURATION);
    return this.$el.animate({
      height: newHeight
    }, this.PANEL_SWING_DURATION, 'swing', complete);
  };

  MozbarElement.prototype.setPanelHeight = function(panelHeight) {
    var newHeight;
    newHeight = this.calculateMobarHeight(panelHeight);
    ($('.mozbar-margin-wGA7MhRhQ3WS')).css({
      'margin-top': newHeight
    });
    return this.$el.height(newHeight);
  };

  MozbarElement.prototype.calculateMobarHeight = function(panelHeight) {
    return panelHeight + this.elementView.toolbarHeight();
  };

  MozbarElement.prototype.toggleProfilesDropDown = function(options) {
    var _ref1;
    if ((_ref1 = this.profilesDropDown) != null ? _ref1.isInDOM() : void 0) {
      this.profilesDropDown.remove();
      this.profilesDropDown = null;
      return;
    }
    this.profilesDropDown = new ProfilesDropDown(options);
    return this.profilesDropDown.render();
  };

  MozbarElement.prototype.toggleSettingsDialog = function(options) {
    var _ref1;
    if ((_ref1 = this.settingsDialog) != null ? _ref1.isInDOM() : void 0) {
      this.settingsDialog.remove();
      this.settingsDialog = null;
      return;
    }
    this.settingsDialog = new SettingsDialog(options);
    return this.settingsDialog.render();
  };

  MozbarElement.prototype.toggleHelpDialog = function(options) {
    var _ref1;
    if ((_ref1 = this.helpDialog) != null ? _ref1.isInDOM() : void 0) {
      this.helpDialog.remove();
      this.helpDialog = null;
      return;
    }
    this.helpDialog = new HelpDialog(options);
    return this.helpDialog.render();
  };

  MozbarElement.prototype.toggleDockPosition = function() {
    var isDockedOnBottom, margin, top,
      _this = this;
    isDockedOnBottom = this.settings.get('isDockedOnBottom');
    if (isDockedOnBottom) {
      top = ($(window)).height() - this.TOOLBAR_HEIGHT;
      margin = 0;
    } else {
      top = 0;
      margin = this.TOOLBAR_HEIGHT;
    }
    return this.elementView.closeAllPanels(function() {
      _this.$el.css({
        top: _this.$el.position().top,
        bottom: 'auto'
      }).animate({
        top: top
      }, function() {
        return _this.$el.css({
          top: '',
          bottom: ''
        }).toggleClass('bottom', isDockedOnBottom);
      });
      ($('body')).animate({
        'margin-top': margin
      }, function() {
        ($('body')).css('margin-top', '').toggleClass('mozbar-margin-wGA7MhRhQ3WS', !isDockedOnBottom);
        return _this.updateFixedTop(0);
      });
      return _this.updatePanelOrder();
    });
  };

  MozbarElement.prototype.updatePanelOrder = function() {
    if (this.settings.get('isDockedOnBottom')) {
      return this.$elementRoot.find('.toolbar').before(this.$elementRoot.find('.panel'));
    } else {
      return this.$elementRoot.find('.toolbar').after(this.$elementRoot.find('.panel'));
    }
  };

  MozbarElement.prototype.remove = function() {
    ($('body')).removeClass('mozbar-margin-wGA7MhRhQ3WS').css({
      'margin-top': ''
    });
    this.updateFixedTop(0);
    return MozbarElement.__super__.remove.apply(this, arguments);
  };

  return MozbarElement;

})(BaseElement);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../templates/toolbar.hbs":110,"./../models/user.coffee":35,"./base_element.coffee":38,"./help_dialog.coffee":46,"./profiles_drop_down.coffee":67,"./settings_dialog.coffee":73,"./toolbar.coffee":76}],56:[function(require,module,exports){
(function (global){
var $, BaseDialog, OnboardingDialog, OnboardingModel, OnbordingView, Page, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

BaseDialog = require('./base_dialog.coffee');

OnbordingView = require('./onboarding_view.coffee');

OnboardingModel = require('./../models/onboarding.coffee');

Page = require('./../models/page.coffee');

module.exports = OnboardingDialog = (function(_super) {
  __extends(OnboardingDialog, _super);

  function OnboardingDialog() {
    _ref = OnboardingDialog.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  OnboardingDialog.prototype.elementCssClass = 'dialog onboarding-dialog';

  OnboardingDialog.prototype.elementViewClass = OnbordingView;

  OnboardingDialog.prototype.id = 'mozbar-onboarding-dialog-wGA7MhRhQ3WS';

  OnboardingDialog.prototype.initialize = function() {
    var _this = this;
    OnboardingDialog.__super__.initialize.apply(this, arguments);
    this.model = this.elementViewModel = OnboardingModel.getInstance();
    this.model.on('change:pageStep change:serpStep', function() {
      return _this.onboardingStepChanged();
    });
    this.model.fetch();
    return this.render();
  };

  OnboardingDialog.prototype.render = function() {
    if (!this.isInOnboarding()) {
      return this.remove();
    }
    OnboardingDialog.__super__.render.apply(this, arguments);
    return this.onboardingStepChanged();
  };

  OnboardingDialog.prototype.isInOnboarding = function() {
    var setting, step;
    setting = Page.isSerp() ? 'serpStep' : 'pageStep';
    step = this.model.get(setting);
    return step !== 'legacy-user' && step !== 'closed' && step !== 'complete';
  };

  OnboardingDialog.prototype.onboardingStepChanged = function() {
    var setting, step;
    setting = Page.isSerp() ? 'serpStep' : 'pageStep';
    step = this.model.get(setting);
    this.$el.css({
      top: '',
      right: ''
    });
    switch (step) {
      case 'page-hotspots-intro':
      case 'serp-hotspots-intro':
        this.show();
        return this.overlay.setOpacity(0);
      case 'page-hotspots':
      case 'serp-hotspots':
        this.overlay.$el.hide();
        return this.$el.css({
          top: ($(window)).height() - 100,
          right: -80
        });
      case 'legacy-user':
      case 'closed':
      case 'complete':
        return this.remove();
      default:
        return this.show();
    }
  };

  OnboardingDialog.prototype.hide = function() {
    this.$el.hide();
    return this.overlay.$el.hide();
  };

  OnboardingDialog.prototype.show = function() {
    if (!this.isInDOM()) {
      return this.render();
    }
    this.$el.css({
      top: '',
      left: ''
    });
    this.$el.show();
    return this.overlay.$el.show();
  };

  OnboardingDialog.prototype.overlayClicked = function() {
    return this.model.nextStep();
  };

  OnboardingDialog.prototype.frameLoaded = function() {
    var isHidden;
    isHidden = this.$el.is(':hidden');
    OnboardingDialog.__super__.frameLoaded.apply(this, arguments);
    if (isHidden) {
      return this.hide();
    }
  };

  return OnboardingDialog;

})(BaseDialog);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../models/onboarding.coffee":16,"./../models/page.coffee":18,"./base_dialog.coffee":37,"./onboarding_view.coffee":59}],57:[function(require,module,exports){
var BaseView, OnboardingTip, template, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BaseView = require('./base_view.coffee');

template = require('./../../templates/onboarding_tip.hbs');

module.exports = OnboardingTip = (function(_super) {
  __extends(OnboardingTip, _super);

  function OnboardingTip() {
    _ref = OnboardingTip.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  OnboardingTip.prototype.initialize = function(opts) {
    OnboardingTip.__super__.initialize.apply(this, arguments);
    return this.listenTo(this.model, 'change', this.render);
  };

  OnboardingTip.prototype.render = function() {
    return this.$el.html(template(this.model.toJSON()));
  };

  return OnboardingTip;

})(BaseView);


},{"./../../templates/onboarding_tip.hbs":90,"./base_view.coffee":40}],58:[function(require,module,exports){
(function (global){
var $, BaseElement, Dispatcher, OnboardingTip, OnboardingTipElement, OnboardingTipModel, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

BaseElement = require('./base_element.coffee');

Dispatcher = require('./event_dispatcher.coffee');

OnboardingTip = require('./onboarding_tip.coffee');

OnboardingTipModel = require('./../models/onboarding_tip.coffee');

module.exports = OnboardingTipElement = (function(_super) {
  __extends(OnboardingTipElement, _super);

  function OnboardingTipElement() {
    _ref = OnboardingTipElement.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  OnboardingTipElement.prototype.ONBOARDING_TIP_WIDTH = 610;

  OnboardingTipElement.prototype.ONBOARDING_TIP_HEIGHT = 210;

  OnboardingTipElement.prototype.dispatcher = Dispatcher.getInstance();

  OnboardingTipElement.prototype.elementCssClass = 'onboarding-tip';

  OnboardingTipElement.prototype.elementViewClass = OnboardingTip;

  OnboardingTipElement.prototype.elementViewModel = new OnboardingTipModel;

  OnboardingTipElement.prototype.top = 0;

  OnboardingTipElement.prototype.left = 0;

  OnboardingTipElement.prototype.id = 'mozbar-onboarding-tip-wGA7MhRhQ3WS';

  OnboardingTipElement.prototype.initialize = function() {
    OnboardingTipElement.__super__.initialize.apply(this, arguments);
    this.listenTo(this.dispatcher, 'onboarding:show-highlight', this.show);
    return this.listenTo(this.dispatcher, 'tooltip:hide', this.tooltipHide);
  };

  OnboardingTipElement.prototype.show = function(opts) {
    var _this = this;
    this.elementViewModel.set(opts);
    this.top = opts.top;
    if (opts.placement === 'above') {
      this.top -= this.ONBOARDING_TIP_HEIGHT;
    }
    this.left = opts.left;
    this.render();
    this.$el.show();
    this.updatePosition();
    this.hideReceived = false;
    clearTimeout(this.timeout);
    return this.timeout = setTimeout((function() {
      return _this.timeoutExpired();
    }), 2000);
  };

  OnboardingTipElement.prototype.renderShadow = function(shadow, css) {
    OnboardingTipElement.__super__.renderShadow.apply(this, arguments);
    return this.updatePosition();
  };

  OnboardingTipElement.prototype.updatePosition = function() {
    return this.$el.css({
      top: this.top,
      left: this.left - this.$el.width() / 2
    });
  };

  OnboardingTipElement.prototype.tooltipHide = function() {
    this.hideReceived = true;
    if (!this.timeout) {
      return this.hide();
    }
  };

  OnboardingTipElement.prototype.timeoutExpired = function() {
    this.timeout = null;
    if (this.hideReceived) {
      return this.hide();
    }
  };

  OnboardingTipElement.prototype.hide = function() {
    var _this = this;
    clearTimeout(this.timeout);
    return this.$el.fadeOut('fast', function() {
      return _this.dispatcher.trigger('onboarding:hide-highlight');
    });
  };

  return OnboardingTipElement;

})(BaseElement);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../models/onboarding_tip.coffee":17,"./base_element.coffee":38,"./event_dispatcher.coffee":45,"./onboarding_tip.coffee":57}],59:[function(require,module,exports){
(function (global){
var $, Analytics, BaseView, Dispatcher, OnboardingView, Page, Settings, template, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

Analytics = require('./../models/analytics.coffee');

BaseView = require('./base_view.coffee');

Page = require('./../models/page.coffee');

Settings = require('./../models/settings.coffee');

template = require('./../../templates/onboarding_dialog.hbs');

Dispatcher = require('./event_dispatcher.coffee');

module.exports = OnboardingView = (function(_super) {
  __extends(OnboardingView, _super);

  function OnboardingView() {
    _ref = OnboardingView.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  OnboardingView.prototype.events = {
    'click .close': 'close',
    'click .next-step': 'nextStep',
    'click .content': 'contentClicked',
    'click': 'nextStep'
  };

  OnboardingView.prototype.render = function() {
    this.analytics = Analytics.getInstance();
    this.dispatcher = Dispatcher.getInstance();
    this.settings = Settings.getInstance();
    this.listenTo(this.model, 'change:pageStep change:serpStep', this.updateStep);
    this.$el.html(template);
    this.updateStep();
    return ($('#mozbar-onboarding-dialog-wGA7MhRhQ3WS')).hide().fadeIn('fast');
  };

  OnboardingView.prototype.updateStep = function() {
    var setting, step;
    setting = Page.isSerp() ? 'serpStep' : 'pageStep';
    step = this.model.get(setting);
    if (this.host.isInDOM()) {
      this.$el.find('.content').hide();
      this.$el.find("." + step).show();
    }
    return false;
  };

  OnboardingView.prototype.nextStep = function() {
    this.model.nextStep();
    return false;
  };

  OnboardingView.prototype.contentClicked = function(e) {
    if (e.target.href && e.target.href !== '#') {
      top.window.location.href = e.target.href;
    }
    return false;
  };

  OnboardingView.prototype.remove = function(callback) {
    var _this = this;
    this.stopListening(this.settings);
    this.stopListening(this.dispatcher);
    return ($('#mozbar-onboarding-dialog-wGA7MhRhQ3WS')).fadeOut('fast', function() {
      OnboardingView.__super__.remove.apply(_this, arguments);
      return callback != null ? callback.apply(_this) : void 0;
    });
  };

  OnboardingView.prototype.close = function() {
    this.model.close();
    this.analytics.trackCloseOnboarding();
    return false;
  };

  return OnboardingView;

})(BaseView);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../templates/onboarding_dialog.hbs":89,"./../models/analytics.coffee":4,"./../models/page.coffee":18,"./../models/settings.coffee":29,"./base_view.coffee":40,"./event_dispatcher.coffee":45}],60:[function(require,module,exports){
(function (global){
var $, BaseView, Overlay, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

BaseView = require('./base_view.coffee');

module.exports = Overlay = (function(_super) {
  __extends(Overlay, _super);

  function Overlay() {
    _ref = Overlay.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  Overlay.prototype.id = 'mozbar-dialog-overlay-wGA7MhRhQ3WS';

  Overlay.prototype.opacity = 0.6;

  Overlay.prototype.render = function() {
    var _this = this;
    if (this.isInDOM()) {
      return;
    }
    this.$el.appendTo('body').css({
      width: ($(window)).width(),
      height: ($(window)).height(),
      opacity: this.opacity
    });
    return this.$el.on('click', function() {
      return _this.clicked();
    });
  };

  Overlay.prototype.setOpacity = function(opacity) {
    return this.$el.css({
      opacity: opacity
    });
  };

  Overlay.prototype.clicked = function() {
    return this.trigger('clicked');
  };

  return Overlay;

})(BaseView);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./base_view.coffee":40}],61:[function(require,module,exports){
var BasePanelTab, PageAttributes, template, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BasePanelTab = require('./base_panel_tab.coffee');

template = require('./../../templates/page_elements.hbs');

module.exports = PageAttributes = (function(_super) {
  __extends(PageAttributes, _super);

  function PageAttributes() {
    _ref = PageAttributes.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  PageAttributes.prototype.className = 'page-attributes';

  PageAttributes.prototype.template = template;

  return PageAttributes;

})(BasePanelTab);


},{"./../../templates/page_elements.hbs":91,"./base_panel_tab.coffee":39}],62:[function(require,module,exports){
var BasePanelTab, PageElements, template, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BasePanelTab = require('./base_panel_tab.coffee');

template = require('./../../templates/page_elements.hbs');

module.exports = PageElements = (function(_super) {
  __extends(PageElements, _super);

  function PageElements() {
    _ref = PageElements.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  PageElements.prototype.className = 'page-elements';

  PageElements.prototype.template = template;

  return PageElements;

})(BasePanelTab);


},{"./../../templates/page_elements.hbs":91,"./base_panel_tab.coffee":39}],63:[function(require,module,exports){
(function (global){
var $, Analytics, BaseView, FacebookStats, GooglePlusStats, HttpStatusList, InfoPanel, LinksPanel, PageToolbar, Settings, SocialStats, TabSettings, template, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

Analytics = require('./../models/analytics.coffee');

Settings = require('./../models/settings.coffee');

TabSettings = require('./../models/tab_settings.coffee');

BaseView = require('./base_view.coffee');

HttpStatusList = require('./../models/http_status_list.coffee');

InfoPanel = require('./info_panel.coffee');

LinksPanel = require('./links_panel.coffee');

SocialStats = require('./social_stats.coffee');

FacebookStats = require('./../models/facebook_stats.coffee');

GooglePlusStats = require('./../models/google_plus_stats.coffee');

template = require('./../../templates/page_toolbar.hbs');

module.exports = PageToolbar = (function(_super) {
  __extends(PageToolbar, _super);

  function PageToolbar() {
    _ref = PageToolbar.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  PageToolbar.prototype.START_SCROLL_LENGTH = 40;

  PageToolbar.prototype.START_SCROLL_TIME = 100;

  PageToolbar.prototype.KEEP_SROLLING_LENGTH = 50;

  PageToolbar.prototype.KEEP_SCROLLING_TIME = 10;

  PageToolbar.prototype.KEEP_SCROLLING_DELAY = 300;

  PageToolbar.prototype.analytics = Analytics.getInstance();

  PageToolbar.prototype.settings = Settings.getInstance();

  PageToolbar.prototype.tabSettings = new TabSettings();

  PageToolbar.prototype.statusList = null;

  PageToolbar.prototype.scrollPos = 0;

  PageToolbar.prototype.overflow = 0;

  PageToolbar.prototype.timer = null;

  PageToolbar.prototype.intervalTimer = null;

  PageToolbar.prototype.currentPanel = null;

  PageToolbar.prototype.selectedPanel = null;

  PageToolbar.prototype.panels = null;

  PageToolbar.prototype.socialStats = null;

  PageToolbar.prototype.events = {
    'click .show-info-panel': 'toggleInfoPanel',
    'click .show-links-panel': 'toggleLinksPanel',
    'mousedown .left-arrow.enabled': 'scrollRight',
    'mousedown .right-arrow.enabled': 'scrollLeft',
    'mouseup .scroll-arrows': 'stopScrolling'
  };

  PageToolbar.prototype.initialize = function(opts) {
    var name, panel, panelEl, stats, _i, _len, _ref1, _ref2, _results,
      _this = this;
    PageToolbar.__super__.initialize.apply(this, arguments);
    this.statusList = new HttpStatusList;
    this.panels = {
      'info-panel': new InfoPanel({
        host: this.host,
        model: this.statusList
      }),
      'links-panel': new LinksPanel({
        host: this.host,
        model: this.tabSettings
      })
    };
    panelEl = this.$el.closest('.toolbar').siblings('.panel');
    _ref1 = this.panels;
    for (name in _ref1) {
      panel = _ref1[name];
      panelEl.append(panel.el);
    }
    this.socialStats = [
      new SocialStats({
        model: new FacebookStats
      }), new SocialStats({
        model: new GooglePlusStats
      })
    ];
    this.listenTo(this.model, 'change', this.render);
    this.listenTo(this.statusList, 'sync', this.render);
    this.listenTo(this.tabSettings, 'change', this.updateLinksButton);
    this.listenTo(this.settings, 'change:metricsCols', this.render);
    ($(window)).on('resize', function() {
      return _this.resize();
    });
    _ref2 = this.socialStats;
    _results = [];
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      stats = _ref2[_i];
      _results.push(this.listenTo(stats, 'render', this.resize));
    }
    return _results;
  };

  PageToolbar.prototype.render = function() {
    var $social, stats, _i, _len, _ref1, _ref2,
      _this = this;
    if (!this.model.isValid()) {
      this.model.fetch();
    }
    if (!this.statusList.isValid()) {
      this.statusList.fetch();
    }
    if (!this.tabSettings.isValid()) {
      this.tabSettings.fetch();
    }
    this.$el.html(template(_.extend({
      isOk: true,
      showLinks: __indexOf.call(this.settings.get('metricsCols'), 'links') >= 0
    }, this.model.toJSON(), (_ref1 = this.statusList.at(0)) != null ? _ref1.toJSON() : void 0)));
    this.$el.find('.learn-more').click(function() {
      return _this.analytics.trackEvent('Page Toolbar/Trial CTA Clicked');
    });
    $social = this.$el.find('.social-stats');
    _ref2 = this.socialStats;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      stats = _ref2[_i];
      stats.$el.appendTo($social);
      stats.render();
    }
    this.updateLinksButton();
    this.resize();
    return PageToolbar.__super__.render.apply(this, arguments);
  };

  PageToolbar.prototype.resize = function() {
    var $arrows, $contents, $rightPanelWidth, $viewport, margin, showArrows;
    $viewport = this.$el.find('.viewport');
    $contents = $viewport.find('.viewport-contents');
    $arrows = this.$el.find('.scroll-arrows');
    $rightPanelWidth = this.$el.find('.right-panel').width();
    if (typeof $viewport.width === "function") {
      $viewport.width(0);
    }
    margin = $viewport.offset().left - this.$el.offset().left;
    showArrows = $contents.width() + $rightPanelWidth > this.$el.width() - margin;
    $arrows.css({
      display: showArrows ? 'flex' : 'none'
    });
    if (showArrows) {
      margin += $arrows.outerWidth(true);
    }
    if (typeof $viewport.width === "function") {
      $viewport.width(this.$el.width() - margin - $rightPanelWidth);
    }
    return this.overflow = Math.max(0, $contents.width() - $viewport.width());
  };

  PageToolbar.prototype.scrollLeft = function() {
    return this.startScrolling(-1);
  };

  PageToolbar.prototype.scrollRight = function() {
    return this.startScrolling(1);
  };

  PageToolbar.prototype.startScrolling = function(direction) {
    var _this = this;
    this.scrollPos += this.START_SCROLL_LENGTH * direction;
    this.timer = setTimeout(function() {
      return _this.keepScrolling(direction);
    }, this.KEEP_SCROLLING_DELAY);
    return this.$el.find('.viewport-contents').animate({
      'margin-left': this.scrollPos
    }, {
      duration: this.START_SCROLL_TIME
    });
  };

  PageToolbar.prototype.keepScrolling = function(direction) {
    var $contents,
      _this = this;
    $contents = this.$el.find('.viewport-contents');
    return this.intervalTimer = setInterval(function() {
      if ((direction === 1 && _this.scrollPos >= 0) || (direction === -1 && _this.scrollPos <= _this.overflow * -1)) {
        _this.stopScrolling();
        return;
      }
      _this.scrollPos += direction * 2;
      return $contents.css({
        'margin-left': _this.scrollPos
      });
    }, this.KEEP_SCROLLING_TIME);
  };

  PageToolbar.prototype.stopScrolling = function() {
    clearInterval(this.intervalTimer);
    this.intervalTimer = null;
    clearTimeout(this.timer);
    this.timer = null;
    return this.updateScrollArrows();
  };

  PageToolbar.prototype.updateScrollArrows = function() {
    var $contents, margin;
    $contents = this.$el.find('.viewport-contents');
    margin = parseInt($contents.css('margin-left'));
    this.$el.find('.left-arrow').toggleClass('enabled', this.scrollPos < 0);
    this.$el.find('.right-arrow').toggleClass('enabled', this.scrollPos > this.overflow * -1);
    this.$el.find('.fade-out').toggle(margin < 0);
    return this.$el.find('.fade-in').toggle(margin > this.overflow * -1);
  };

  PageToolbar.prototype.toggleInfoPanel = function() {
    return this.togglePanel('info-panel');
  };

  PageToolbar.prototype.toggleLinksPanel = function() {
    return this.togglePanel('links-panel');
  };

  PageToolbar.prototype.togglePanel = function(name) {
    this.hideTooltip();
    if (this.selectedPanel === name) {
      this.closePanel(name);
      return;
    }
    this.openPanel(name);
    return this.panels[name].trackPanelView();
  };

  PageToolbar.prototype.openPanel = function(name) {
    var _this = this;
    this.clearPanelSelections();
    this.$el.find(".show-" + name).addClass('active');
    this.selectedPanel = name;
    if (this.currentPanel && this.currentPanel !== this.selectedPanel) {
      this.transitionStarted();
      this.panels[this.currentPanel].close(function() {
        return _this.openSelectedPanel();
      });
      return;
    }
    return this.openSelectedPanel();
  };

  PageToolbar.prototype.openSelectedPanel = function() {
    var _ref1,
      _this = this;
    this.transitionStarted();
    if ((_ref1 = this.panels[this.selectedPanel]) != null) {
      _ref1.open(function() {
        return _this.transitionComplete();
      });
    }
    return this.currentPanel = this.selectedPanel;
  };

  PageToolbar.prototype.closePanel = function(name) {
    var _ref1,
      _this = this;
    this.clearPanelSelections();
    this.selectedPanel = null;
    return (_ref1 = this.panels[name]) != null ? _ref1.close(function() {
      _this.currentPanel = null;
      return _this.transitionComplete();
    }) : void 0;
  };

  PageToolbar.prototype.closeAllPanels = function(done) {
    var _this = this;
    this.clearPanelSelections();
    return this.transitionComplete(function() {
      var _ref1;
      if (!_this.currentPanel) {
        done();
      }
      return (_ref1 = _this.panels[_this.currentPanel]) != null ? _ref1.close(function() {
        _this.currentPanel = _this.selectedPanel = null;
        return done();
      }) : void 0;
    });
  };

  PageToolbar.prototype.transitionStarted = function() {
    return this.inTransition = true;
  };

  PageToolbar.prototype.transitionComplete = function(done) {
    if (done) {
      if (this.inTransition) {
        this.transitionCompleteCallback = done;
      } else {
        done();
      }
      return;
    }
    if (typeof this.transitionCompleteCallback === "function") {
      this.transitionCompleteCallback();
    }
    this.transitionCompleteCallback = null;
    return this.inTransition = false;
  };

  PageToolbar.prototype.updateLinksButton = function() {
    var $button, links, type, types, _i, _len, _results;
    types = this.panels['links-panel'].getLinkTypes();
    links = this.tabSettings.get('highlightLinks') || [];
    $button = this.$el.find('.show-links-panel');
    _results = [];
    for (_i = 0, _len = types.length; _i < _len; _i++) {
      type = types[_i];
      _results.push($button.toggleClass(type, links.indexOf(type) > -1));
    }
    return _results;
  };

  PageToolbar.prototype.clearPanelSelections = function() {
    return this.$el.find('.btn').removeClass('active');
  };

  return PageToolbar;

})(BaseView);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../templates/page_toolbar.hbs":92,"./../models/analytics.coffee":4,"./../models/facebook_stats.coffee":8,"./../models/google_plus_stats.coffee":11,"./../models/http_status_list.coffee":13,"./../models/settings.coffee":29,"./../models/tab_settings.coffee":30,"./base_view.coffee":40,"./info_panel.coffee":51,"./links_panel.coffee":54,"./social_stats.coffee":75}],64:[function(require,module,exports){
var BaseView, PanelView, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BaseView = require('./base_view.coffee');

module.exports = PanelView = (function(_super) {
  __extends(PanelView, _super);

  function PanelView() {
    _ref = PanelView.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  PanelView.prototype.PANEL_HEIGHT = 50;

  PanelView.prototype.isOpen = false;

  PanelView.prototype.open = function(complete) {
    this.isOpen = true;
    return this.updatePanelHeight(this.PANEL_HEIGHT, complete);
  };

  PanelView.prototype.close = function(complete) {
    this.isOpen = false;
    return this.updatePanelHeight(0, complete);
  };

  PanelView.prototype.toggleOpen = function(complete) {
    if (this.isOpen) {
      return this.close(complete);
    } else {
      return this.open(complete);
    }
  };

  PanelView.prototype.updatePanelHeight = function(height, complete) {
    this.$el.animate({
      height: height
    }, this.host.PANEL_SWING_DURATION);
    return this.host.updatePanelHeight(height, complete);
  };

  return PanelView;

})(BaseView);


},{"./base_view.coffee":40}],65:[function(require,module,exports){
(function (global){
var $, BaseElement, Overlay, ProfileDialog, ProfileEdit, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

BaseElement = require('./base_element.coffee');

ProfileEdit = require('./profile_edit.coffee');

Overlay = require('./overlay.coffee');

module.exports = ProfileDialog = (function(_super) {
  __extends(ProfileDialog, _super);

  function ProfileDialog() {
    _ref = ProfileDialog.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  ProfileDialog.prototype.elementCssClass = 'profile-dialog';

  ProfileDialog.prototype.elementViewClass = ProfileEdit;

  ProfileDialog.prototype.overlay = null;

  ProfileDialog.prototype.id = 'mozbar-profile-dialog-wGA7MhRhQ3WS';

  ProfileDialog.prototype.initialize = function(opts) {
    var _this = this;
    this.elementViewModel = opts.model;
    this.overlay = new Overlay({
      onRemove: function() {
        return _this.remove();
      }
    });
    return ProfileDialog.__super__.initialize.apply(this, arguments);
  };

  ProfileDialog.prototype.render = function() {
    ProfileDialog.__super__.render.apply(this, arguments);
    return this.overlay.render();
  };

  ProfileDialog.prototype.remove = function() {
    ProfileDialog.__super__.remove.apply(this, arguments);
    return this.overlay.remove();
  };

  return ProfileDialog;

})(BaseElement);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./base_element.coffee":38,"./overlay.coffee":60,"./profile_edit.coffee":66}],66:[function(require,module,exports){
(function (global){
var BaseView, Cities, ProfileEdit, Regions, cityTemplate, regionTemplate, template, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

BaseView = require('./base_view.coffee');

Regions = require('./../models/regions.coffee');

Cities = require('./../models/cities.coffee');

template = require('./../../templates/profile_edit.hbs');

regionTemplate = require('./../../templates/profile_edit_regions.hbs');

cityTemplate = require('./../../templates/profile_edit_cities.hbs');

module.exports = ProfileEdit = (function(_super) {
  __extends(ProfileEdit, _super);

  function ProfileEdit() {
    _ref = ProfileEdit.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  ProfileEdit.prototype.regions = new Regions;

  ProfileEdit.prototype.cities = new Cities;

  ProfileEdit.prototype.events = {
    'click .cancel': 'close',
    'click .save': 'save',
    'click .delete': 'delete',
    'change .country': 'updateRegions',
    'change .region': 'updateCities',
    'keydown .profile-edit': 'dialogKeyDown'
  };

  ProfileEdit.prototype.initialize = function(options) {
    ProfileEdit.__super__.initialize.apply(this, arguments);
    this.listenTo(this.regions, 'reset', this.renderRegions);
    return this.listenTo(this.cities, 'reset', this.renderCities);
  };

  ProfileEdit.prototype.render = function() {
    this.$el.html(template(this.model.toJSON()));
    return this.updateRegions();
  };

  ProfileEdit.prototype.renderRegions = function() {
    this.$el.find('.region').html(regionTemplate(_.extend(this.model.toJSON(), {
      regions: this.regions.toJSON()
    }))).val(this.model.get('region'));
    return this.updateCities();
  };

  ProfileEdit.prototype.renderCities = function() {
    this.$el.find('.city').html(cityTemplate(_.extend(this.model.toJSON(), {
      cities: this.cities.toJSON()
    }))).val(this.model.get('city'));
    return this.updateFieldState();
  };

  ProfileEdit.prototype.updateRegions = function() {
    var country;
    country = this.$el.find('.country').val();
    this.regions.country = country;
    return this.regions.fetch({
      reset: true
    });
  };

  ProfileEdit.prototype.updateCities = function() {
    var region;
    region = this.$el.find('.region').val();
    this.cities.region = region;
    this.cities.fetch({
      reset: true
    });
    return this.updateFieldState();
  };

  ProfileEdit.prototype.updateFieldState = function() {
    var region;
    return region = this.$el.find('.city').get(0).disabled = !this.$el.find('.region').val();
  };

  ProfileEdit.prototype.dialogKeyDown = function(e) {
    return e.stopImmediatePropagation();
  };

  ProfileEdit.prototype.save = function() {
    this.model.set({
      engine: this.$el.find('.engine').val(),
      country: this.$el.find('.country').val(),
      region: this.$el.find('.region').val(),
      city: this.$el.find('.city').val(),
      name: this.$el.find('.name').val(),
      disablePersonalization: this.$el.find('.disable-personalization').is(':checked')
    });
    this.model.save();
    return this.close();
  };

  ProfileEdit.prototype["delete"] = function() {
    if (!confirm('Are you sure you want to delete this profile?')) {
      return;
    }
    this.model.destroy();
    return this.close();
  };

  ProfileEdit.prototype.close = function() {
    return this.host.remove();
  };

  return ProfileEdit;

})(BaseView);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../templates/profile_edit.hbs":101,"./../../templates/profile_edit_cities.hbs":102,"./../../templates/profile_edit_regions.hbs":103,"./../models/cities.coffee":7,"./../models/regions.coffee":24,"./base_view.coffee":40}],67:[function(require,module,exports){
(function (global){
var $, BaseElement, Profile, ProfileDialog, Profiles, ProfilesDropDown, ProfilesList, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

BaseElement = require('./base_element.coffee');

ProfilesList = require('./profiles_list.coffee');

ProfileDialog = require('./profile_dialog.coffee');

Profiles = require('./../models/profiles.coffee');

Profile = require('./../models/profile.coffee');

module.exports = ProfilesDropDown = (function(_super) {
  __extends(ProfilesDropDown, _super);

  function ProfilesDropDown() {
    _ref = ProfilesDropDown.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  ProfilesDropDown.prototype.elementCssClass = 'profiles-drop-down';

  ProfilesDropDown.prototype.elementViewClass = ProfilesList;

  ProfilesDropDown.prototype.elementViewModel = new Profiles;

  ProfilesDropDown.prototype.id = 'mozbar-profiles-drop-down-wGA7MhRhQ3WS';

  ProfilesDropDown.prototype.initialize = function(options) {
    this.options = options;
  };

  ProfilesDropDown.prototype.render = function() {
    var height, _ref1,
      _this = this;
    ProfilesDropDown.__super__.render.apply(this, arguments);
    height = ($(window)).height() - (this.options.top || this.options.bottom);
    this.$el.css({
      top: this.options.top,
      bottom: this.options.bottom,
      left: this.options.left,
      height: height
    });
    if ((_ref1 = this.options.opened) != null) {
      _ref1.apply(this);
    }
    return ($(window)).on('click.profiles-drop-down', function(e) {
      if (!_this.$el.is(e.target) && _this.$el.has(e.target).length === 0) {
        return _this.remove();
      }
    });
  };

  ProfilesDropDown.prototype.remove = function() {
    var _ref1;
    ProfilesDropDown.__super__.remove.apply(this, arguments);
    ($(window)).off('click.profiles-drop-down');
    return (_ref1 = this.options.closed) != null ? _ref1.apply(this) : void 0;
  };

  ProfilesDropDown.prototype.editProfile = function(profile) {
    var dialog;
    dialog = new ProfileDialog({
      model: profile || new Profile
    });
    return dialog.render();
  };

  return ProfilesDropDown;

})(BaseElement);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../models/profile.coffee":22,"./../models/profiles.coffee":23,"./base_element.coffee":38,"./profile_dialog.coffee":65,"./profiles_list.coffee":68}],68:[function(require,module,exports){
(function (global){
var $, BaseView, Page, ProfilesList, Settings, googleDomains, template, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

BaseView = require('./base_view.coffee');

Settings = require('./../models/settings.coffee');

template = require('./../../templates/profiles_list.hbs');

Page = require('./../models/page.coffee');

googleDomains = require('./../models/google_domains.coffee');

module.exports = ProfilesList = (function(_super) {
  __extends(ProfilesList, _super);

  function ProfilesList() {
    _ref = ProfilesList.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  ProfilesList.prototype.settings = Settings.getInstance();

  ProfilesList.prototype.events = {
    'click li[data-id]': 'selectProfile',
    'click .edit-profile, .add-new': 'editProfile'
  };

  ProfilesList.prototype.initialize = function(opts) {
    ProfilesList.__super__.initialize.apply(this, arguments);
    return this.listenTo(this.model, 'change', this.render);
  };

  ProfilesList.prototype.render = function() {
    this.$el.html(template(this.model.toJSON()));
    return this.$el.toggleClass('bottom', this.settings.get('isDockedOnBottom'));
  };

  ProfilesList.prototype.selectProfile = function(e) {
    var $target, id;
    $target = $(e.currentTarget);
    id = $target.data('id');
    this.settings.set({
      selectedProfileId: id
    });
    this.runProfile(this.model.get(id));
    this.settings.save();
    return this.host.remove();
  };

  ProfilesList.prototype.runProfile = function(profile) {
    var city, country, engine, key, params, place, qs, searchTerm, secret, url, uule;
    engine = profile.get('engine');
    country = profile.get('country');
    searchTerm = Page.getSearchTerm();
    params = {};
    url = '';
    qs = '';
    switch (engine) {
      case 'google':
        url = googleDomains.getDomain(country);
        place = '';
        city = profile.get('city');
        if (city) {
          place = "" + city + ",";
        }
        place += profile.get('region');
        params = {
          q: searchTerm,
          ie: 'UTF-8',
          oe: 'UTF-8',
          ip: '0.0.0.0',
          pws: profile.get('disablePersonalization') ? 0 : void 0
        };
        key = 'ABCDEFGHIJKLMNOPQRSTUVWKYZ';
        key += key.toLowerCase();
        key += '0123456789- ';
        secret = key.substr(place.length, 1);
        uule = "w+CAIQICI" + secret + (btoa(place));
        qs = "" + ($.param(params)) + "&uule=" + uule;
        break;
      case 'bing':
        url = "http://www.bing.com/search?";
        params.q = searchTerm;
        if (country) {
          params[' loc:'] = country;
        }
        break;
      case 'yahoo':
        url = 'http://search.yahoo.com/search?';
        params.p = searchTerm;
        if (country) {
          params.vc = country;
        }
    }
    if (!qs) {
      qs = $.param(params);
    }
    url += url.indexOf('?' > 0) ? '&' : '?';
    url += qs;
    if (Page.getSerpEngine() === engine) {
      return window.top.location.href = url;
    } else {
      return window.open(url);
    }
  };

  ProfilesList.prototype.editProfile = function(e) {
    var id;
    id = ($(e.currentTarget)).parent().data('id');
    this.host.editProfile(this.model.get(id));
    this.host.remove();
    return e.stopImmediatePropagation();
  };

  return ProfilesList;

})(BaseView);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../templates/profiles_list.hbs":104,"./../models/google_domains.coffee":10,"./../models/page.coffee":18,"./../models/settings.coffee":29,"./base_view.coffee":40}],69:[function(require,module,exports){
(function (global){
var $, BasePanelTab, Semantics, Twitter, TwitterCards, template, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

BasePanelTab = require('./base_panel_tab.coffee');

TwitterCards = require('./twitter_cards.coffee');

Twitter = require('./../models/twitter.coffee');

template = require('./../../templates/semantics.hbs');

module.exports = Semantics = (function(_super) {
  __extends(Semantics, _super);

  function Semantics() {
    _ref = Semantics.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  Semantics.prototype.className = 'semantics';

  Semantics.prototype.template = template;

  Semantics.prototype.twitterCards = null;

  Semantics.prototype.activeSnippet = 'schema';

  Semantics.prototype.events = {
    'click .snippet .content': 'snippetClicked'
  };

  Semantics.prototype.snippetClicked = function(e) {
    var $target;
    $target = $(e.currentTarget);
    this.activeSnippet = $target.data('show');
    return this.selectActiveSnippet();
  };

  Semantics.prototype.selectActiveSnippet = function() {
    this.$el.find('.content').removeClass('active');
    this.$el.find(".content." + this.activeSnippet).addClass('active');
    this.$el.find(".content[data-show='" + this.activeSnippet + "']").addClass('active');
    if (this.activeSnippet === 'twitter') {
      if (this.twitterCards == null) {
        this.twitterCards = new TwitterCards({
          model: new Twitter,
          el: this.$el.find('.preview .twitter')
        });
      }
      return this.twitterCards.render();
    }
  };

  Semantics.prototype.render = function() {
    Semantics.__super__.render.apply(this, arguments);
    return this.selectActiveSnippet();
  };

  return Semantics;

})(BasePanelTab);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../templates/semantics.hbs":105,"./../models/twitter.coffee":32,"./base_panel_tab.coffee":39,"./twitter_cards.coffee":79}],70:[function(require,module,exports){
(function (global){
var $, BaseElement, Page, SerpElement, SerpItem, SerpResultsMetrics, serpItemTemplate, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

BaseElement = require('./base_element.coffee');

SerpItem = require('./serp_item.coffee');

Page = require('./../models/page.coffee');

SerpResultsMetrics = require('./../models/serp_results_metrics.coffee');

serpItemTemplate = require('./../../templates/serp_item.hbs');

module.exports = SerpElement = (function(_super) {
  __extends(SerpElement, _super);

  function SerpElement() {
    _ref = SerpElement.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  SerpElement.prototype.className = 'mozbar-serp-item-wGA7MhRhQ3WS';

  SerpElement.prototype.elementTemplate = serpItemTemplate;

  SerpElement.prototype.elementCssClass = 'serp-item';

  SerpElement.prototype.elementViewClass = SerpItem;

  SerpElement.prototype.initialize = function(opts) {
    SerpElement.__super__.initialize.apply(this, arguments);
    return this.elementViewModel = this.model.get('metrics');
  };

  SerpElement.prototype.parentElement = function() {
    return this.model.get('el');
  };

  return SerpElement;

})(BaseElement);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../templates/serp_item.hbs":106,"./../models/page.coffee":18,"./../models/serp_results_metrics.coffee":27,"./base_element.coffee":38,"./serp_item.coffee":71}],71:[function(require,module,exports){
(function (global){
var $, BaseView, SerpItem, serpItem, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

BaseView = require('./base_view.coffee');

serpItem = require('./../../templates/serp_item.hbs');

module.exports = SerpItem = (function(_super) {
  __extends(SerpItem, _super);

  function SerpItem() {
    _ref = SerpItem.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  SerpItem.prototype.tooltipPlacement = 'above';

  SerpItem.prototype.initialize = function(opts) {
    SerpItem.__super__.initialize.apply(this, arguments);
    return this.listenTo(this.model, 'change', this.render);
  };

  SerpItem.prototype.render = function() {
    if (!this.model.isValid()) {
      this.model.fetch();
    }
    this.$el.html(serpItem(this.model.toJSON()));
    return this.showOnboardingHighlights();
  };

  return SerpItem;

})(BaseView);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../templates/serp_item.hbs":106,"./base_view.coffee":40}],72:[function(require,module,exports){
(function (global){
var $, Analytics, BaseView, Page, SerpAttributes, SerpToolbar, Settings, googleDomains, serpToolbar, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

Analytics = require('./../models/analytics.coffee');

Page = require('./../models/page.coffee');

BaseView = require('./base_view.coffee');

serpToolbar = require('./../../templates/serp_toolbar.hbs');

googleDomains = require('./../models/google_domains.coffee');

SerpAttributes = require('./../models/serp_attributes.coffee');

Settings = require('./../models/settings.coffee');

module.exports = SerpToolbar = (function(_super) {
  __extends(SerpToolbar, _super);

  function SerpToolbar() {
    _ref = SerpToolbar.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  SerpToolbar.prototype.analytics = Analytics.getInstance();

  SerpToolbar.prototype.settings = Settings.getInstance();

  SerpToolbar.prototype.events = {
    'click .search-profile': 'showProfileDropDown',
    'click .export': 'exportSerpResults'
  };

  SerpToolbar.prototype.initialize = function() {
    SerpToolbar.__super__.initialize.apply(this, arguments);
    return this.listenTo(this.model, 'change', this.render);
  };

  SerpToolbar.prototype.render = function() {
    var _this = this;
    this.$el.html(serpToolbar(this.model.toJSON()));
    return this.$el.find('.learn-more').click(function() {
      return _this.analytics.trackEvent('SERP Toolbar/Trial CTA Clicked');
    });
  };

  SerpToolbar.prototype.showProfileDropDown = function(e) {
    var $selectBox, isDockedOnBottom, offset;
    isDockedOnBottom = this.settings.get('isDockedOnBottom');
    $selectBox = this.$el.find('.search-profile');
    offset = $selectBox.offset();
    this.host.toggleProfilesDropDown({
      top: !isDockedOnBottom ? offset.top + $selectBox.height() : void 0,
      bottom: isDockedOnBottom ? offset.top + $selectBox.height() : void 0,
      left: offset.left,
      opened: function() {
        return $selectBox.find('.arrow').removeClass('arrow-down').addClass('arrow-up');
      },
      closed: function() {
        return $selectBox.find('.arrow').removeClass('arrow-up').addClass('arrow-down');
      }
    });
    return e.stopImmediatePropagation();
  };

  SerpToolbar.prototype.exportSerpResults = function() {
    var a, blob, data, doc, line, now, url, _i, _len,
      _this = this;
    now = new Date();
    data = ['---------------------------------------', 'Moz Toolbar SERP Report', "Keyword: " + (Page.getSearchTerm()), "Search Engine: " + (Page.getSerpEngine()), "Report Created: " + (now.toLocaleString()), '---------------------------------------', '', ['Position', 'URL', 'Title', 'Description', 'Page Authority', 'Total Links to Page', 'Total Linking Root Domains to Page', 'Domain Authority', 'Total Links to Root Domain', 'Total Linking Root Domains to Root Domains']];
    ($(Page.getSerpConfig().selector)).each(function(i, el) {
      var metrics, model;
      model = new SerpAttributes({
        el: el
      });
      metrics = model.get('metrics');
      return data.push([i, model.get('url'), _this.csvEncode(model.get('title')), _this.csvEncode(model.get('description')), metrics.get('upa'), metrics.get('uid'), metrics.get('uipl'), metrics.get('pda'), metrics.get('puid'), metrics.get('pid')]);
    });
    doc = '';
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      line = data[_i];
      doc += "" + (_.isArray(line) ? line.join(',') : line) + "\n";
    }
    a = document.createElement('a');
    blob = new Blob([doc], {
      type: 'text/csv'
    });
    url = URL.createObjectURL(blob);
    a.setAttribute('href', url);
    a.setAttribute('download', this.getCsvFilename());
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    return this.analytics.trackExport();
  };

  SerpToolbar.prototype.csvEncode = function(str) {
    str = str.replace(/\"/g, '""');
    if (str.indexOf(',') > -1 || str.indexOf('"') > -1) {
      str = '"' + str + '"';
    }
    return str;
  };

  SerpToolbar.prototype.getCsvFilename = function() {
    var filename, now;
    now = new Date();
    filename = "" + (Page.getSearchTerm()) + "-" + (Page.getSerpEngine()) + "-";
    filename += now.getFullYear() + '-';
    filename += this.twoDigits(now.getMonth() + 1) + '-';
    return filename += this.twoDigits(now.getDay() + 1) + '.csv';
  };

  SerpToolbar.prototype.twoDigits = function(num) {
    return (num < 10 ? '0' : '') + num;
  };

  return SerpToolbar;

})(BaseView);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../templates/serp_toolbar.hbs":107,"./../models/analytics.coffee":4,"./../models/google_domains.coffee":10,"./../models/page.coffee":18,"./../models/serp_attributes.coffee":26,"./../models/settings.coffee":29,"./base_view.coffee":40}],73:[function(require,module,exports){
var BaseDialog, SettingsDialog, SettingsEdit, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BaseDialog = require('./base_dialog.coffee');

SettingsEdit = require('./settings_edit.coffee');

module.exports = SettingsDialog = (function(_super) {
  __extends(SettingsDialog, _super);

  function SettingsDialog() {
    _ref = SettingsDialog.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  SettingsDialog.prototype.elementCssClass = 'dialog settings-dialog';

  SettingsDialog.prototype.elementViewClass = SettingsEdit;

  SettingsDialog.prototype.id = 'mozbar-settings-dialog-wGA7MhRhQ3WS';

  SettingsDialog.prototype.render = function() {
    SettingsDialog.__super__.render.apply(this, arguments);
    return this.$el.css({
      top: this.options.top,
      bottom: this.options.bottom,
      left: this.options.left - this.$el.width() + 20
    });
  };

  return SettingsDialog;

})(BaseDialog);


},{"./base_dialog.coffee":37,"./settings_edit.coffee":74}],74:[function(require,module,exports){
(function (global){
var $, BaseView, Page, Settings, SettingsEdit, User, template, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

BaseView = require('./base_view.coffee');

Page = require('./../models/page.coffee');

User = require('./../models/user.coffee');

Settings = require('./../models/settings.coffee');

template = require('./../../templates/settings_dialog.hbs');

module.exports = SettingsEdit = (function(_super) {
  __extends(SettingsEdit, _super);

  function SettingsEdit() {
    _ref = SettingsEdit.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  SettingsEdit.prototype.settings = Settings.getInstance();

  SettingsEdit.prototype.user = User.getInstance();

  SettingsEdit.prototype.events = {
    'click .metrics :checkbox': 'toggleCol',
    'click #lightdarkswitch': 'toggleLightDark'
  };

  SettingsEdit.prototype.render = function() {
    var cols, pageUrl;
    pageUrl = encodeURIComponent(Page.href().replace(/^http[s]*:\/\//, ''));
    this.$el.html(template(_.extend({
      pageUrl: pageUrl
    }, this.user.toJSON())));
    cols = this.settings.get('metricsCols');
    this.$el.find('.metrics :checkbox').each(function() {
      var $el;
      $el = $(this);
      return $el.prop('checked', cols.indexOf($el.data('col')) !== -1);
    });
    this.$el.find('#lightdarkswitch').prop('checked', this.settings.get('isLightTheme'));
    return ($('#mozbar-settings-dialog-wGA7MhRhQ3WS')).hide().slideDown('fast');
  };

  SettingsEdit.prototype.toggleCol = function() {
    var cols;
    cols = $.map(this.$el.find(':checked'), function(el) {
      return ($(el)).data('col');
    });
    this.settings.set('metricsCols', cols);
    return this.settings.save();
  };

  SettingsEdit.prototype.toggleLightDark = function() {
    this.settings.set('isLightTheme', this.$el.find('#lightdarkswitch').is(':checked'));
    return this.settings.save();
  };

  SettingsEdit.prototype.remove = function(complete) {
    var _this = this;
    return ($('#mozbar-settings-dialog-wGA7MhRhQ3WS')).slideUp('fast', function() {
      _this;
      return SettingsEdit.__super__.remove.call(_this, complete);
    });
  };

  return SettingsEdit;

})(BaseView);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../templates/settings_dialog.hbs":108,"./../models/page.coffee":18,"./../models/settings.coffee":29,"./../models/user.coffee":35,"./base_view.coffee":40}],75:[function(require,module,exports){
(function (global){
var BaseView, SocialStats, template, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

BaseView = require('./base_view.coffee');

template = require('./../../templates/social.hbs');

module.exports = SocialStats = (function(_super) {
  __extends(SocialStats, _super);

  function SocialStats() {
    _ref = SocialStats.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  SocialStats.prototype.initialize = function(opts) {
    SocialStats.__super__.initialize.apply(this, arguments);
    return this.listenTo(this.model, 'change', this.render);
  };

  SocialStats.prototype.render = function() {
    if (!this.model.isValid()) {
      this.model.fetch();
    }
    this.$el.html(template(this.model.toJSON()));
    return this.trigger('render');
  };

  return SocialStats;

})(BaseView);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../templates/social.hbs":109,"./base_view.coffee":40}],76:[function(require,module,exports){
(function (global){
var $, Analytics, BaseView, ButtonNotificationElement, Page, PageToolbar, SerpToolbar, SerpToolbarModel, Settings, Toolbar, UrlMetrics, _, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

_ = (typeof window !== "undefined" ? window._ : typeof global !== "undefined" ? global._ : null);

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

Analytics = require('./../models/analytics.coffee');

BaseView = require('./base_view.coffee');

ButtonNotificationElement = require('./button_notification_element.coffee');

Page = require('./../models/page.coffee');

PageToolbar = require('./page_toolbar.coffee');

SerpToolbar = require('./serp_toolbar.coffee');

SerpToolbarModel = require('./../models/serp_toolbar.coffee');

Settings = require('./../models/settings.coffee');

UrlMetrics = require('./../models/url_metrics.coffee');

module.exports = Toolbar = (function(_super) {
  __extends(Toolbar, _super);

  function Toolbar() {
    _ref = Toolbar.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  Toolbar.prototype.analytics = Analytics.getInstance();

  Toolbar.prototype.settings = Settings.getInstance();

  Toolbar.prototype.contentPage = null;

  Toolbar.prototype.tooltipPlacement = 'below';

  Toolbar.prototype.events = {
    'click .settings': 'toggleSettingsDialog',
    'click .help': 'toggleHelpDialog',
    'click .dock': 'toggleDockPosition',
    'click .close': 'close'
  };

  Toolbar.prototype.initialize = function(options) {
    var $toolbarPanel, opts, position;
    Toolbar.__super__.initialize.apply(this, arguments);
    $toolbarPanel = this.$el.find('.toolbar-panel');
    position = $toolbarPanel.offset();
    opts = {
      host: options.host,
      el: $toolbarPanel,
      margin: position.left + this.$el.find('right-panel').outerWidth()
    };
    return this.childView = Page.isSerp() ? new SerpToolbar(_.extend(opts, {
      model: new SerpToolbarModel
    })) : new PageToolbar(_.extend(opts, {
      model: UrlMetrics.getInstance()
    }));
  };

  Toolbar.prototype.render = function() {
    this.childView.render();
    this.updateTooltipPlacement();
    return Toolbar.__super__.render.apply(this, arguments);
  };

  Toolbar.prototype.toolbarHeight = function() {
    return this.$el.find('.toolbar').height();
  };

  Toolbar.prototype.toggleSettingsDialog = function(e) {
    this.hideTooltip();
    return this.host.toggleSettingsDialog(this.getDialogOptions(e));
  };

  Toolbar.prototype.toggleHelpDialog = function(e) {
    this.hideTooltip();
    return this.host.toggleHelpDialog(this.getDialogOptions(e));
  };

  Toolbar.prototype.getDialogOptions = function(e) {
    var $target, height, isDockedOnBottom, position;
    $target = $(e.currentTarget);
    position = $target.offset();
    isDockedOnBottom = this.settings.get('isDockedOnBottom');
    height = this.$el.find('.toolbar-panel').height();
    return {
      left: position.left + ($target.width() / 2),
      top: !isDockedOnBottom ? height : void 0,
      bottom: isDockedOnBottom ? height : void 0,
      arrow: isDockedOnBottom ? 'bottom' : 'top'
    };
  };

  Toolbar.prototype.toggleDockPosition = function(e) {
    this.hideTooltip();
    this.settings.toggleDockPosition();
    this.updateTooltipPlacement();
    return this.analytics.trackToggleDockPosition();
  };

  Toolbar.prototype.updateTooltipPlacement = function() {
    var isDockedOnBottom;
    isDockedOnBottom = this.settings.get('isDockedOnBottom');
    this.tooltipPlacement = isDockedOnBottom ? 'above' : 'below';
    return this.childView.tooltipPlacement = this.tooltipPlacement;
  };

  Toolbar.prototype.closeAllPanels = function(done) {
    if (this.childView.closeAllPanels) {
      return this.childView.closeAllPanels(done);
    } else {
      return done();
    }
  };

  Toolbar.prototype.close = function() {
    this.settings.toggleMozbar();
    return this.hideTooltip();
  };

  return Toolbar;

})(BaseView);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../models/analytics.coffee":4,"./../models/page.coffee":18,"./../models/serp_toolbar.coffee":28,"./../models/settings.coffee":29,"./../models/url_metrics.coffee":34,"./base_view.coffee":40,"./button_notification_element.coffee":43,"./page_toolbar.coffee":63,"./serp_toolbar.coffee":72}],77:[function(require,module,exports){
var BaseView, Tooltip, template, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BaseView = require('./base_view.coffee');

template = require('./../../templates/tooltip.hbs');

module.exports = Tooltip = (function(_super) {
  __extends(Tooltip, _super);

  function Tooltip() {
    _ref = Tooltip.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  Tooltip.prototype.initialize = function(opts) {
    Tooltip.__super__.initialize.apply(this, arguments);
    return this.listenTo(this.model, 'change', this.render);
  };

  Tooltip.prototype.render = function() {
    return this.$el.html(template(this.model.toJSON()));
  };

  return Tooltip;

})(BaseView);


},{"./../../templates/tooltip.hbs":111,"./base_view.coffee":40}],78:[function(require,module,exports){
(function (global){
var $, BaseElement, Dispatcher, Tooltip, TooltipElement, TooltipModel, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

BaseElement = require('./base_element.coffee');

Dispatcher = require('./event_dispatcher.coffee');

Tooltip = require('./tooltip.coffee');

TooltipModel = require('./../models/tooltip.coffee');

module.exports = TooltipElement = (function(_super) {
  __extends(TooltipElement, _super);

  function TooltipElement() {
    _ref = TooltipElement.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  TooltipElement.prototype.TOOLTIP_DELAY = 250;

  TooltipElement.prototype.TOOLTIP_WIDTH = 200;

  TooltipElement.prototype.TOOLTIP_HEIGHT = 200;

  TooltipElement.prototype.dispatcher = Dispatcher.getInstance();

  TooltipElement.prototype.elementCssClass = 'tooltip';

  TooltipElement.prototype.elementViewClass = Tooltip;

  TooltipElement.prototype.elementViewModel = new TooltipModel;

  TooltipElement.prototype.top = 0;

  TooltipElement.prototype.left = 0;

  TooltipElement.prototype.id = 'mozbar-tooltip-wGA7MhRhQ3WS';

  TooltipElement.prototype.timeout = null;

  TooltipElement.prototype.initialize = function(opts) {
    TooltipElement.__super__.initialize.apply(this, arguments);
    this.listenTo(this.dispatcher, 'tooltip:start-timeout', this.startTimeout);
    return this.listenTo(this.dispatcher, 'tooltip:hide', this.hide);
  };

  TooltipElement.prototype.startTimeout = function(opts) {
    var _this = this;
    this.elementViewModel.set(opts);
    this.top = opts.top;
    if (opts.placement === 'above') {
      this.top -= this.TOOLTIP_HEIGHT;
    }
    this.left = opts.left;
    clearTimeout(this.timeout);
    return this.timeout = setTimeout((function() {
      return _this.show();
    }), this.TOOLTIP_DELAY);
  };

  TooltipElement.prototype.show = function() {
    this.render();
    this.$el.show();
    return this.updatePosition();
  };

  TooltipElement.prototype.renderShadow = function(shadow, css) {
    TooltipElement.__super__.renderShadow.apply(this, arguments);
    return this.updatePosition();
  };

  TooltipElement.prototype.updatePosition = function() {
    return this.$el.css({
      top: this.top,
      left: this.left - this.$el.width() / 2
    });
  };

  TooltipElement.prototype.hide = function() {
    clearTimeout(this.timeout);
    return this.$el.hide();
  };

  return TooltipElement;

})(BaseElement);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../models/tooltip.coffee":31,"./base_element.coffee":38,"./event_dispatcher.coffee":45,"./tooltip.coffee":77}],79:[function(require,module,exports){
(function (global){
var $, BasePanelTab, TwitterCards, template, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

$ = (typeof window !== "undefined" ? window.$ : typeof global !== "undefined" ? global.$ : null);

BasePanelTab = require('./base_panel_tab.coffee');

template = require('./../../templates/twitter_cards.hbs');

module.exports = TwitterCards = (function(_super) {
  __extends(TwitterCards, _super);

  function TwitterCards() {
    _ref = TwitterCards.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  TwitterCards.prototype.className = 'twitter';

  TwitterCards.prototype.template = template;

  return TwitterCards;

})(BasePanelTab);


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./../../templates/twitter_cards.hbs":112,"./base_panel_tab.coffee":39}],80:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<div class=\"bar bar1\"></div>\n<div class=\"bar bar2\"></div>\n<div class=\"bar bar3\"></div>\n";
  });

},{"hbsfy/runtime":162}],81:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<html class=\"";
  if (helper = helpers.elementCssClass) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.elementCssClass); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n  <base target='_parent'>\n  <head>\n    <style>\n      body { display: none; }\n    </style>\n  </head>\n  <body class=\"";
  if (helper = helpers.elementCssClass) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.elementCssClass); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n    ";
  if (helper = helpers.html) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.html); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n  </body>\n</html>\n";
  return buffer;
  });

},{"hbsfy/runtime":162}],82:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<a href=\"#\" class=\"close\">x</a>\n<p>\n  <em>MozBar is now in DA mode.</em>\n  To turn it off completely, click the <img class=\"icon\"></img> to the\n  right of the address bar\n</p>\n";
  });

},{"hbsfy/runtime":162}],83:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<div class=\"arrow-up\"></div>\n<div class=\"content\">\n\n  <h2>Help</h2>\n  <a href=\"#\" class=\"tour\">Turn on Tutorial</a>\n  <a href=\"http://moz.com/help/guides/research-tools/mozbar\" target=\"_blank\">MozBar Help</a>\n  <a href=\"https://seomoz.zendesk.com/forums/293194-Moz-Feature-Requests\" target=\"_blank\">Request a Feature</a>\n  <a href=\"http://moz.com/academy\" target=\"_blank\">Moz Academy</a>\n\n</div>\n<div class=\"arrow-down\"></div>\n";
  });

},{"hbsfy/runtime":162}],84:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, self=this, functionType="function", escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n    <tr>\n      <td class=\"tag ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.isOk), {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"><p>";
  if (helper = helpers.status) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.status); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p></td>\n      <td class=\"url\"><a href=\"";
  if (helper = helpers.url) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.url); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">";
  if (helper = helpers.url) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.url); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a></td>\n    </tr>\n    ";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "ok";
  }

  buffer += "<table class=\"http-status\">\n  <thead>\n    <tr>\n      <td class=\"tag\">Status Code</td>\n      <td class=\"url\">URL</td>\n    </tr>\n  </thead>\n  <tbody class=\"scrollable\">\n    ";
  stack1 = helpers.each.call(depth0, depth0, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</table>\n\n";
  return buffer;
  });

},{"hbsfy/runtime":162}],85:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, self=this, functionType="function", escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  
  return "\n          <div class=\"login\">\n            <div class=\"premium pull-left\"></div>\n            <p>Metrics are available with a paid\n              subscription to Moz.  <a href=\"http://moz.com/products\" target=\"_blank\">Learn more</a>\n              or <a href=\"http://moz.com/login\" target=\"_blank\">Login</a>\n            </p>\n          </div>\n          ";
  }

  buffer += "<table class=\"inbound-links\">\n  <thead>\n    <tr>\n      <td class=\"tag\">Page Attributes</td>\n      <td class=\"url\">URL</td>\n      <td class=\"subdomain\">Subdomain</td>\n      <td class=\"rootdomain\">\n        <div class=\"rootdomain\">\n          Root Domain\n\n          ";
  stack1 = helpers.unless.call(depth0, ((stack1 = (depth0 && depth0.user)),stack1 == null || stack1 === false ? stack1 : stack1.isPro), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        </div>\n      </td>\n    </tr>\n  </thead>\n  <tbody class=\"scrollable "
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.user)),stack1 == null || stack1 === false ? stack1 : stack1.level)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\">\n    <tr>\n      <td class=\"tag\"><p>Page Authority (PA)</p></td>\n      <td class=\"url\"><p>";
  if (helper = helpers.niceUpa) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.niceUpa); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p></td>\n      <td class=\"subdomain\"><p>--</p></td>\n      <td class=\"rootdomain\"><p>--</p></td>\n    </tr>\n    <tr>\n      <td class=\"tag\"><p>Domain Authority</p></td>\n      <td class=\"url\"><p>--</p></td>\n      <td class=\"subdomain\"><p>--</p></td>\n      <td class=\"rootdomain\"><p>";
  if (helper = helpers.wholePda) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.wholePda); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p></td>\n    </tr>\n    <tr>\n      <td class=\"tag\"><p>External Followed Links</p></td>\n      <td class=\"url\"><p>";
  if (helper = helpers.niceUeid) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.niceUeid); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p></td>\n      <td class=\"subdomain premium\"><p>";
  if (helper = helpers.niceFeid) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.niceFeid); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p></td>\n      <td class=\"rootdomain premium\"><p>";
  if (helper = helpers.nicePeid) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.nicePeid); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p></td>\n    </tr>\n    <tr>\n      <td class=\"tag\"><p>Linking Root Domains</p></td>\n      <td class=\"url premium\"><p>";
  if (helper = helpers.niceUipl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.niceUipl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p></td>\n      <td class=\"subdomain premium\"><p>";
  if (helper = helpers.niceFipl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.niceFipl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p></td>\n      <td class=\"rootdomain premium\"><p>";
  if (helper = helpers.nicePid) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.nicePid); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p></td>\n    </tr>\n    <tr>\n      <td class=\"tag\"><p>MozRank (mR)</p></td>\n      <td class=\"url\"><p>";
  if (helper = helpers.umrp) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.umrp); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p></td>\n      <td class=\"subdomain\"><p>";
  if (helper = helpers.fmrp) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.fmrp); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + " (DmR)</p></td>\n      <td class=\"rootdomain premium\"><p>";
  if (helper = helpers.pmrp) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.pmrp); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p></td>\n    </tr>\n    <tr>\n      <td class=\"tag\"><p>MozTrust (mT)</p></td>\n      <td class=\"url\"><p>";
  if (helper = helpers.utrp) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.utrp); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p></td>\n      <td class=\"subdomain premium\"><p>";
  if (helper = helpers.ftrp) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.ftrp); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p></td>\n      <td class=\"rootdomain premium\"><p>";
  if (helper = helpers.ptrp) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.ptrp); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p></td>\n    </tr>\n    <tr>\n      <td class=\"tag\"><p>Total Links</p></td>\n      <td class=\"url\"><p>";
  if (helper = helpers.niceUid) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.niceUid); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p></td>\n      <td class=\"subdomain premium\"><p>";
  if (helper = helpers.niceFuid) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.niceFuid); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p></td>\n      <td class=\"rootdomain premium\"><p>";
  if (helper = helpers.nicePuid) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.nicePuid); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p></td>\n    </tr>\n  </tbody>\n</table>\n\n";
  return buffer;
  });

},{"hbsfy/runtime":162}],86:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "(<span class='status-code'>";
  if (helper = helpers.statusCode) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.statusCode); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>)";
  return buffer;
  }

  buffer += "<ul class=\"tabs\">\n  <li data-tab=\"page-elements\">On-Page Elements</li>\n  <li data-tab=\"general-attributes\">General Attributes</li>\n  <li data-tab=\"inbound-links\">Link Metrics</li>\n  <li data-tab=\"semantics\">Markup</li>\n  <li data-tab=\"http-status\">\n    Http Status\n    ";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.isOk), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </li>\n</ul>\n\n<div class=\"tab\"></div>\n\n<div class=\"btn expand\"></div>\n<div class=\"gutter\"></div>\n";
  return buffer;
  });

},{"hbsfy/runtime":162}],87:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      ";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.isLoaded), {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.isLoaded), {hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n      <a href=\"https://moz.com/researchtools/keyword-difficulty\" target=\"_blank\">\n        <div class=\"btn key\" data-tooltip=\"Run Keyword Analysis\"/>\n      </a>\n    ";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "\n      <div class=\"btn activate-keyword-difficulty\"\n        data-tooltip=\"Obtain % and Estimated Volume<br>of keyword entered\">\n        <p>Get Keyword Difficulty</p>\n        <div class=\"onboarding-text\">\n          Get the Moz <em>Keyword Difficulty Score</em> for this keyword.\n        </div>\n      </div>\n      ";
  }

function program4(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <div class=\"loaded\">\n          <div class=\"difficulty\"\n            data-tooltip=\"Keyword Difficulty Score Highly Competitive!\">\n            <p>";
  if (helper = helpers.difficulty) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.difficulty); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "%</p>\n          </div>\n        </div>\n      ";
  return buffer;
  }

function program6(depth0,data) {
  
  
  return "\n      <a class=\"logged-out\" href=\"https://moz.com/pro/mozbar?utm_source=mozbar_toolbar&utm_medium=mozbar&utm_campaign=mozbar_get_premium\" target=\"_blank\">\n        Get Keyword Difficulty\n        with MozBar Premium\n        <div class=\"cta\">\n          Try Free\n        </div>\n      </a>\n    ";
  }

  buffer += "<style>\n";
  if (helper = helpers.css) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.css); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n</style>\n<div class=\"mozbar-css-wGA7MhRhQ3WS\">\n  <div class=\"keyword-difficulty\">\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.isPro), {hash:{},inverse:self.program(6, program6, data),fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":162}],88:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<div class=\"links-panel\">\n  <div class=\"link-type followed\" data-type=\"followed\">\n    Followed\n    <div class=\"bar\"></div>\n  </div>\n  <div class=\"link-type no-followed\" data-type=\"no-followed\">\n    No-Followed\n    <div class=\"bar\"></div>\n  </div>\n  <div class=\"link-type external\" data-type=\"external\">\n    External\n    <div class=\"bar\"></div>\n  </div>\n  <div class=\"link-type internal\" data-type=\"internal\">\n    Internal\n    <div class=\"bar\"></div>\n  </div>\n\n  <div class=\"search\">\n    <input name=\"search\" />\n  </div>\n\n  <div class=\"link-type keyword\" data-type=\"keyword\">\n    Highlight\n    <div class=\"bar\"></div>\n  </div>\n</div>\n";
  });

},{"hbsfy/runtime":162}],89:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "\n<div class=\"content page-serp-intro-address-bar\">\n  <div class=\"close\">x</div>\n  <p>The MozBar also helps you analyze SERPs. Search for a Keyword to learn how.</p>\n  <p>\n    For example - search for\n    <a href=\"https://google.com/search?q=seo%20tools\" target=\"_top\">SEO Tools</a>\n  </p>\n  <div class=\"footer\">\n    <a href='#' class='close'>No thanks - close this tutorial.</a>\n  </div>\n</div>\n\n<div class=\"content serp-page-intro-address-bar\">\n  <div class=\"close\">x</div>\n  <p>The MozBar also helps you analyze pages. Enter a URL to learn how.</p>\n\n  <p>\n    For example - analyze\n    <a href=\"http://moz.com\" target=\"_top\">moz.com</a>\n  </p>\n  <div class=\"footer\">\n    <a href='#' class='close'>\n      No thanks - close this tutorial.\n    </a>\n  </div>\n</div>\n\n<div class=\"content serp-hotspots page-hotspots\">\n  <p>Turn off hotspots.</p>\n  <a href=\"#\" class=\"close\">\n    <span class=\"close x\">x</span>\n    Close this tutorial.\n  </a>\n</div>\n";
  });

},{"hbsfy/runtime":162}],90:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div class=\"";
  if (helper = helpers.placement) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.placement); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n  <div class=\"arrow-up ";
  if (helper = helpers.lean) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.lean); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"></div>\n  <div class=\"content\"><p>";
  if (helper = helpers.text) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.text); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</p></div>\n  <div class=\"arrow-down ";
  if (helper = helpers.lean) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.lean); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"></div>\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":162}],91:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n    <tr>\n      <td class=\"tag\">";
  if (helper = helpers.tag) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.tag); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</td>\n      <td class=\"content ";
  if (helper = helpers.contentClass) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.contentClass); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n        <p>\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.url), {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        ";
  if (helper = helpers.content) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.content); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.url), {hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.multipleError), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        </p>\n      </td>\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.showLength), {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </tr>\n    ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n          <a href=\"";
  if (helper = helpers.url) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.url); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" target=\"_blank\">\n        ";
  return buffer;
  }

function program4(depth0,data) {
  
  
  return "\n          </a>\n        ";
  }

function program6(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n          <p class=\"error\">Multiple ";
  if (helper = helpers.tag) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.tag); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + " tags found!</p>\n        ";
  return buffer;
  }

function program8(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <td class=\"characters\">";
  if (helper = helpers.length) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.length); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</td>\n      ";
  return buffer;
  }

  buffer += "<table class=\"";
  if (helper = helpers.className) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.className); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n  <thead>\n    <tr>\n      <td class=\"tag\">Tag/Location</td>\n      <td class=\"content ";
  if (helper = helpers.contentClass) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.contentClass); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">Content</td>\n      <td class=\"characters\"># of Characters</td>\n    </tr>\n  </thead>\n  <tbody class=\"scrollable\">\n    ";
  stack1 = helpers.each.call(depth0, depth0, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </tbody>\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":162}],92:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <div class=\"badge\">";
  if (helper = helpers.statusCode) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.statusCode); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n  ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <div class=\"stat\">\n          <div class=\"title\">mR: ";
  if (helper = helpers.umrp) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.umrp); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n          <div class=\"scale-outer\">\n            <div class=\"scale-inner\" style=\"width: ";
  if (helper = helpers.umrpPct) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.umrpPct); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "%\"></div>\n          </div>\n        </div>\n        ";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"stat\">\n        <div class=\"title\">mT: ";
  if (helper = helpers.utrp) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.utrp); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n        <div class=\"scale-outer\">\n          <div class=\"scale-inner\" style=\"width: ";
  if (helper = helpers.utrpPct) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.utrpPct); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "%\"></div>\n        </div>\n      </div>\n      ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"links\">\n        <a href=\"http://moz.com/researchtools/ose/links?site=";
  if (helper = helpers.pageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.pageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "&src=mb\" target=\"_blank\">\n          <p class=\"line\">";
  if (helper = helpers.niceUid) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.niceUid); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + " links";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.user)),stack1 == null || stack1 === false ? stack1 : stack1.isPro), {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</p>\n          ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.user)),stack1 == null || stack1 === false ? stack1 : stack1.isPro), {hash:{},inverse:self.noop,fn:self.program(10, program10, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        </a>\n      </div>\n      ";
  return buffer;
  }
function program8(depth0,data) {
  
  
  return " from";
  }

function program10(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n          <p class=\"line\">";
  if (helper = helpers.niceUipl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.niceUipl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + " Root Domains</p>\n          ";
  return buffer;
  }

function program12(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"stat\">\n        <div class=\"title\">DmR: ";
  if (helper = helpers.pmrp) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.pmrp); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n        <div class=\"scale-outer alt\">\n          <div class=\"scale-inner alt\" style=\"width: ";
  if (helper = helpers.pmrpPct) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.pmrpPct); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "%\"></div>\n        </div>\n      </div>\n      ";
  return buffer;
  }

function program14(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"stat\">\n        <div class=\"title\">DmT: ";
  if (helper = helpers.ptrp) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.ptrp); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n        <div class=\"scale-outer alt\">\n          <div class=\"scale-inner alt\" style=\"width: ";
  if (helper = helpers.ptrpPct) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.ptrpPct); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "%\"></div>\n        </div>\n      </div>\n      ";
  return buffer;
  }

function program16(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.user)),stack1 == null || stack1 === false ? stack1 : stack1.isPro), {hash:{},inverse:self.noop,fn:self.program(17, program17, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  return buffer;
  }
function program17(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"links\">\n        <a href=\"http://moz.com/researchtools/ose/links?site=";
  if (helper = helpers.rootDomain) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.rootDomain); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "&src=mb\" target=\"_blank\">\n          <p class=\"line\">";
  if (helper = helpers.nicePuid) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.nicePuid); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + " links from</p>\n          <p class=\"line\">";
  if (helper = helpers.nicePid) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.nicePid); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + " Root Domains</p>\n        </a>\n      </div>\n      <h3>Subdomain:</h3>\n      <div class=\"links\">\n        <a href=\"http://moz.com/researchtools/ose/links?site=";
  if (helper = helpers.pageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.pageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "&src=mb\" target=\"_blank\">\n          <p class=\"line\">";
  if (helper = helpers.niceFuid) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.niceFuid); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + " links from</p>\n          <p class=\"line\">";
  if (helper = helpers.niceFipl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.niceFipl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + " Root Domains</p>\n        </a>\n      </div>\n      ";
  return buffer;
  }

function program19(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      <div class=\"stat\">\n        <div class=\"title\">Spam<br />Score:</div>\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noFspsc), {hash:{},inverse:self.program(22, program22, data),fn:self.program(20, program20, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </div>\n      ";
  return buffer;
  }
function program20(depth0,data) {
  
  
  return "\n          <div class='line' data-tooltip=\"Spam score not yet determined for this domain\">--</div>\n        ";
  }

function program22(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n          <div class=\"score\">\n            <a href=\"https://moz.com/researchtools/ose/spam-analysis?site=";
  if (helper = helpers.rootDomain) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.rootDomain); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "&target=subdomain&source=subdomain&page=1&sort=spam_score\" target=\"_blank\">\n              <p class=\"line\">";
  if (helper = helpers.niceFspsc) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.niceFspsc); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p>\n            </a>\n          </div>\n          <div class=\"meter\">\n            <a href=\"https://moz.com/researchtools/ose/spam-analysis?site=";
  if (helper = helpers.rootDomain) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.rootDomain); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "&target=subdomain&source=subdomain&page=1&sort=spam_score\" target=\"_blank\">\n              <div class=\"bar bar1 ";
  if (helper = helpers.bar1on) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.bar1on); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"></div>\n              <div class=\"bar bar2 ";
  if (helper = helpers.bar2on) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.bar2on); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"></div>\n              <div class=\"bar bar3 ";
  if (helper = helpers.bar3on) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.bar3on); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"></div>\n            </a>\n          </div>\n        ";
  return buffer;
  }

function program24(depth0,data) {
  
  
  return "\n  <div class=\"right-panel\">\n    Get full access to MozBar Premium with Moz Pro\n    <a class=\"cta learn-more\" href=\"https://moz.com/pro/mozbar?utm_source=mozbar_toolbar&utm_medium=mozbar&utm_campaign=mozbar_get_premium\" target=\"_blank\">\n      Try Free\n    </a>\n    or\n    <a href=\"http://moz.com/login\" target=\"_blank\">\n      Log in\n    </a>\n  </div>\n";
  }

  buffer += "<div class=\"btn show-info-panel\" data-tooltip=\"Page Analysis\">\n  ";
  stack1 = self.invokePartial(partials['page-info-icon'], 'page-info-icon', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n  <div class=\"onboarding-text\">\n    <p>Open the <em>Page Analysis Drawer</em>.</p>\n    <p>\n      Get information and analysis about the page structure and markup as well as backlink data.\n    </p>\n  </div>\n  ";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.isOk), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n\n<div class=\"btn show-links-panel\" data-tooltip=\"Highlight Links\">\n  ";
  stack1 = self.invokePartial(partials['highlight-icon'], 'highlight-icon', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  <div class=\"onboarding-text\">\n    <p>Open the <em>Highlighter Tool</em>.</p>\n    <p>\n      Show followed or external links, even custom text.  Click again to put it away.\n    </p>\n  </div>\n</div>\n<div class=\"divider\"></div>\n<div class=\"viewport\">\n  <div class=\"fade-out\"></div>\n  <div class=\"viewport-contents\">\n    <div class=\"page-stats\">\n      <div class=\"stat-stack\">\n        <div class=\"stat\">\n          <div class=\"title\">PA: ";
  if (helper = helpers.niceUpa) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.niceUpa); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n          <div class=\"scale-outer\">\n            <div class=\"scale-inner\" style=\"width: ";
  if (helper = helpers.niceUpa) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.niceUpa); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "%\"></div>\n          </div>\n        </div>\n        ";
  stack1 = (helper = helpers.ifDefined || (depth0 && depth0.ifDefined),options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.umrp), options) : helperMissing.call(depth0, "ifDefined", (depth0 && depth0.umrp), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </div>\n      ";
  stack1 = (helper = helpers.ifDefined || (depth0 && depth0.ifDefined),options={hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.utrp), options) : helperMissing.call(depth0, "ifDefined", (depth0 && depth0.utrp), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.showLinks), {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      <div class=\"stat\">\n        <div class=\"title\">DA: ";
  if (helper = helpers.nicePda) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.nicePda); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n        <div class=\"scale-outer alt\">\n          <div class=\"scale-inner alt\" style=\"width: ";
  if (helper = helpers.nicePda) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.nicePda); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "%\"></div>\n        </div>\n      </div>\n      ";
  stack1 = (helper = helpers.ifDefined || (depth0 && depth0.ifDefined),options={hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.pmrp), options) : helperMissing.call(depth0, "ifDefined", (depth0 && depth0.pmrp), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = (helper = helpers.ifDefined || (depth0 && depth0.ifDefined),options={hash:{},inverse:self.noop,fn:self.program(14, program14, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.ptrp), options) : helperMissing.call(depth0, "ifDefined", (depth0 && depth0.ptrp), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.showLinks), {hash:{},inverse:self.noop,fn:self.program(16, program16, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n      ";
  stack1 = (helper = helpers.ifDefined || (depth0 && depth0.ifDefined),options={hash:{},inverse:self.noop,fn:self.program(19, program19, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.fspsc), options) : helperMissing.call(depth0, "ifDefined", (depth0 && depth0.fspsc), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n\n    <div class=\"social-stats\"></div>\n\n  </div>\n  <div class=\"fade-in\"></div>\n</div>\n<div class=\"scroll-arrows\">\n  <div class=\"left-arrow\">&lt;</div>\n  <div class=\"right-arrow enabled\">&gt;</div>\n</div>\n\n";
  stack1 = helpers.unless.call(depth0, ((stack1 = (depth0 && depth0.user)),stack1 == null || stack1 === false ? stack1 : stack1.isPro), {hash:{},inverse:self.noop,fn:self.program(24, program24, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":162}],93:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n  <circle cx=\"12\" cy=\"12\" r=\"12\"/>\n  <text x=\"9.5\" y=\"8.75\" transform=\"rotate(45)\" font-size=\"26\" font-weight=\"bold\" font-family=\"Open Sans, sans-serif\">\n    <tspan>+</tspan>\n  </text>\n</svg>\n";
  });

},{"hbsfy/runtime":162}],94:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 21 48\">\n  <path d=\"M24.112 21.112h-24v-12h48v12h-24zm0-18h-24v-3h48v3h-24z\"/>\n</svg>\n";
  });

},{"hbsfy/runtime":162}],95:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 48 60\">\n  <path d=\"M40 48.407H20v-14h4v10h32v-30H44v-10H24v15h-4v-19h32.544l3.728 3.073L60 6.552v41.855H40zm12-38c2.2 0 4-.247 4-.548 0-.304-1.237-1.64-2.75-2.97-1.513-1.33-3.313-2.435-4-2.453L48 4.407v6h4zm-40.788 27H9.425l-4.713-4.785L0 27.838v-2.606l4.75-4.373 4.75-4.375 1.75-.04 1.75-.04v3.425l-2.75 2.25-2.75 2.253 14.69.036 14.692.036.645 1.044.645 1.044-1.208 1.457-1.21 1.458H7.73l2.635 2.072L13 33.55v3.854h-1.788z\"/>\n</svg>\n";
  });

},{"hbsfy/runtime":162}],96:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 69.287 72.44\">\n  <path d=\"M2.933 69.22l-1.782.067-.574-1.5-.576-1.5 3.357-9.863 3.357-9.864 23.328-22.386L53.37 1.787l2.28-.893L57.934 0l2.622.658 2.622.658 3.395 2.98 3.395 2.982 1.237 2.985 1.236 2.985-.596 2.27-.597 2.27-24.108 23-24.11 23-9.158 2.683c-5.037 1.476-9.96 2.714-10.94 2.75zm8.3-7.938c1.788-.513 3.415-1.095 3.613-1.293.198-.2-.76-1.415-2.132-2.703C11.344 56 10 55.167 9.728 55.44c-.27.27-.776 1.907-1.12 3.634l-.63 3.14 3.254-.932zm9.934-4.046c.3-.028 8.872-8.115 19.047-17.97l18.5-17.922-4.173-4.186-4.17-4.186-18.58 17.835c-10.216 9.81-18.576 18.074-18.576 18.366 0 .29 1.666 2.236 3.703 4.322 2.036 2.086 3.95 3.77 4.25 3.74zm42.127-40.95c.37 0 1.233-.67 1.916-1.494l1.24-1.495-1.67-2.55-1.672-2.55-2.417-1.102-2.417-1.102L56.697 7.3l-1.575 1.31 3.75 3.838c2.06 2.112 4.05 3.84 4.422 3.84z\"/>\n</svg>\n";
  });

},{"hbsfy/runtime":162}],97:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 28.071 21.2\">\n  <path d=\"M2.435 27.42l-1.192-.578-.62-1.364L0 24.114V12.53l1.255-.178 1.256-.18.325-3.775.324-3.777 1.604-1.675L6.37 1.268 8.484.634 10.6 0l2.115.634 2.116.634 1.606 1.675 1.605 1.675.325 3.777.324 3.776 1.255.18 1.255.178v11.587l-.62 1.36-.62 1.36-1.358.618-1.36.62-6.808-.038-6.808-.038-1.19-.577zM18.3 25.17l.668-.67V14.125H2.232v10.378l.67.668.67.67H17.63l.67-.67zM8.136 22.545l-.963-1.064.18-1.847.178-1.848 1.534-.854 1.534-.853 1.534.854 1.534.855.18 1.848.178 1.848-.963 1.065-.962 1.063h-3l-.963-1.063zm3.827-1.676l.313-.508-.34-.888-.34-.887H9.603l-.34.887-.34.888.312.507.314.507h2.1l.314-.508zm4.683-10.362l.19-1.664-.622-2.072-.62-2.072-1.457-1.146-1.457-1.146H8.618l-1.3.91-1.298.91-.78 1.862-.777 1.86v1.88c0 1.032.176 2.052.39 2.267l.39.39 5.608-.158 5.608-.16.19-1.662z\"/>\n</svg>\n";
  });

},{"hbsfy/runtime":162}],98:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 62 62\">\n  <path d=\"M29.316 59.378l-.897-2.36-3.908-.625-3.906-.624-4.168-3.02-4.168-3.02-3.02-4.168-3.02-4.168-.623-3.906-.625-3.907-2.36-.896-2.36-.897v-2.1l2.36-.896 2.36-.897.625-3.906.624-3.907 3.02-4.167 3.02-4.168 4.168-3.02 4.168-3.02 3.906-.624 3.907-.623.896-2.36.897-2.36h2.1l.896 2.36.897 2.36 3.906.624 3.906.626 4.167 3.02 4.168 3.02 3.02 4.167 3.02 4.167.624 3.907.623 3.906 2.36.898 2.36.898v2.1l-2.36.896-2.36.897-.624 3.908-.626 3.906-3.02 4.168-3.02 4.168-4.167 3.02-4.168 3.02-3.907.623-3.906.625-.898 2.36-.898 2.36h-2.1l-.896-2.36zm10.967-10.166c5.713-2.92 10.206-9.063 11.32-15.475l.61-3.5-.882-3.8-.88-3.802-2.253-3.29-2.254-3.288-3.29-2.255-3.292-2.255-4.048-.91-4.05-.91-4.048.91-4.05.91-3.29 2.255-3.292 2.255-2.255 3.29-2.255 3.292-.91 4.048-.91 4.05.91 4.048.91 4.05 2.255 3.29 2.255 3.292 3.335 2.285c1.834 1.256 4.8 2.642 6.59 3.08l3.256.793 4-.538c2.2-.295 5.134-1.117 6.52-1.826zm-20.02-6.334c0-.472 1.537-4.185 3.417-8.25l3.417-7.39 6.474-4.75c6.266-4.597 8.693-5.683 8.693-3.892 0 .473-1.538 4.185-3.417 8.25l-3.417 7.39-6.476 4.75c-6.265 4.598-8.69 5.684-8.69 3.892zM35.31 27.652l1.115-2.086-.575-.575-.575-.574-1.983 1.794-1.982 1.795.535.866c.902 1.46 2.292.97 3.464-1.218z\"/>\n  </svg>\n";
  });

},{"hbsfy/runtime":162}],99:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 28 28\">\n  <path d=\"M27.084 27.874l-.458-.003-2.472-2.245-2.47-2.246-1.416.7-1.416.7h-4.084l-1.6-.775-1.6-.774H0V0h21.444v11.412l.68.363.68.364L23.73 14l.928 1.864v3.208l-.737 1.524-.738 1.523 2.407 2.282L28 26.682l-.23.598-.228.597-.458-.003zM17.5 23.017c.68-.113 1.667-.427 2.19-.698.525-.272 1.37-.986 1.876-1.59l.922-1.094.24-1.275.238-1.274-.408-1.362-.408-1.362-1.242-1.09-1.242-1.09-1.434-.387-1.434-.386-1.435.385-1.434.387-1.243 1.09-1.24 1.09-.41 1.362-.408 1.362.246 1.314.246 1.314 1.14 1.237 1.14 1.238 1.43.518 1.43.517 1.238-.206zM5.88 21.444h4.09l-.517-1.24c-.285-.68-.518-1.646-.518-2.144v-.905H4.29v-1.073h4.568l.217-.566c.12-.31.217-.713.217-.893v-.328H4.29v-.715H9.98l.35-.65c.19-.36.966-1.08 1.723-1.605l1.377-.954 1.678-.313 1.678-.313 1.434.262 1.435.262v-8.48H1.787v19.657H5.88zM9.29 8.934H4.29V5.004h10.006v3.93H9.292z\"/>\n  </svg>\n";
  });

},{"hbsfy/runtime":162}],100:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24.142 24\">\n  <path d=\"M9.504 23.087c-.245-.613-.547-1.4-.67-1.745-.24-.676-.573-.646-2.61.237l-1.215.525-1.56-1.588-1.562-1.587.67-1.494c.37-.822.623-1.64.563-1.82-.06-.18-.785-.576-1.614-.882L0 14.178V9.822l1.52-.568c1.687-.63 1.8-1.004.908-3.03l-.533-1.215 1.588-1.56L5.07 1.887l1.494.67c.822.37 1.64.623 1.82.563.18-.06.576-.785.882-1.614L9.822 0h4.356l.556 1.506c.306.83.703 1.555.882 1.615.18.06.998-.192 1.82-.56l1.494-.672 1.587 1.56 1.588 1.56-.533 1.215c-.89 2.027-.78 2.402.907 3.03l1.52.57v4.355l-1.52.568c-1.687.63-1.8 1.004-.908 3.03l.533 1.215-1.588 1.56-1.587 1.562-1.494-.67c-.822-.37-1.64-.623-1.82-.563-.18.06-.575.785-.88 1.614L14.18 24l-2.114.1c-2.11.102-2.116.1-2.562-1.013zm3.812-2.312c.304-1.012.697-1.503 1.52-1.895 1.035-.494 1.196-.483 2.463.163 1.24.634 1.4.646 1.895.152.494-.494.484-.65-.122-1.837-.602-1.18-.618-1.402-.175-2.46.38-.91.788-1.256 1.865-1.578 1.167-.35 1.378-.552 1.378-1.32s-.21-.97-1.377-1.32c-1.077-.322-1.485-.668-1.865-1.577-.443-1.06-.427-1.282.175-2.46.606-1.19.616-1.344.122-1.838s-.654-.482-1.896.152c-1.268.646-1.43.657-2.465.163-.822-.392-1.215-.883-1.52-1.895C12.97 2.07 12.768 1.86 12 1.86c-.767 0-.97.21-1.316 1.365-.304 1.012-.697 1.503-1.52 1.895-1.035.494-1.196.483-2.463-.163-1.24-.634-1.4-.646-1.895-.152-.494.494-.482.654.152 1.896.646 1.268.657 1.43.163 2.465-.392.822-.883 1.215-1.895 1.52C2.07 11.03 1.86 11.232 1.86 12c0 .768.21.97 1.377 1.32 1.077.322 1.485.668 1.865 1.577.443 1.06.427 1.282-.175 2.46-.606 1.19-.616 1.344-.122 1.838s.654.482 1.896-.152c1.268-.646 1.43-.657 2.465-.163.822.392 1.215.883 1.52 1.895.345 1.155.548 1.366 1.315 1.366.767 0 .97-.21 1.316-1.365zM10.48 15.75c-1.506-.66-2.367-2.033-2.367-3.77 0-1.42.157-1.815 1.105-2.762 1.6-1.602 3.963-1.602 5.564 0 .95.95 1.105 1.34 1.105 2.782 0 1.424-.157 1.835-1.045 2.723-1.116 1.116-3.1 1.583-4.363 1.028zm2.872-2.398c.372-.372.676-.98.676-1.352 0-.87-1.157-2.028-2.028-2.028-.372 0-.98.304-1.352.676-.372.372-.676.98-.676 1.352 0 .372.304.98.676 1.352.372.372.98.676 1.352.676.372 0 .98-.304 1.352-.676z\"/>\n</svg>\n";
  });

},{"hbsfy/runtime":162}],101:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, self=this, helperMissing=helpers.helperMissing, functionType="function", escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  
  return "\n      <option value=\"google\">Google</option>\n      <option value=\"bing\">Bing</option>\n      <option value=\"yahoo\">Yahoo</option>\n    ";
  }

function program3(depth0,data) {
  
  
  return "checked";
  }

function program5(depth0,data) {
  
  
  return "\n        <option value=\"US\">United States</option>\n        <option value=\"GB\">United Kingdom</option>\n        <option value=\"IN\">India</option>\n        <option value=\"CA\">Canada</option>\n        <option value=\"DE\">Germany</option>\n        <optgroup label=\"----------\"></optgroup>\n        <option value=\"\">Country</option>\n        <option value=\"AF\">Afghanistan</option>\n        <option value=\"AL\">Albania</option>\n        <option value=\"DZ\">Algeria</option>\n        <option value=\"AS\">American Samoa</option>\n        <option value=\"AD\">Andorra</option>\n        <option value=\"AO\">Angola</option>\n        <option value=\"AI\">Anguilla</option>\n        <option value=\"AQ\">Antarctica</option>\n        <option value=\"AG\">Antigua and Barbuda</option>\n        <option value=\"AR\">Argentina</option>\n        <option value=\"AM\">Armenia</option>\n        <option value=\"AW\">Aruba</option>\n        <option value=\"AU\">Australia</option>\n        <option value=\"AT\">Austria</option>\n        <option value=\"AZ\">Azerbaijan</option>\n        <option value=\"BS\">Bahamas</option>\n        <option value=\"BH\">Bahrain</option>\n        <option value=\"BD\">Bangladesh</option>\n        <option value=\"BB\">Barbados</option>\n        <option value=\"BY\">Belarus</option>\n        <option value=\"BE\">Belgium</option>\n        <option value=\"BZ\">Belize</option>\n        <option value=\"BJ\">Benin</option>\n        <option value=\"BM\">Bermuda</option>\n        <option value=\"BT\">Bhutan</option>\n        <option value=\"BO\">Bolivia</option>\n        <option value=\"BA\">Bosnia and Herzegovina</option>\n        <option value=\"BW\">Botswana</option>\n        <option value=\"BV\">Bouvet Island</option>\n        <option value=\"BR\">Brazil</option>\n        <option value=\"IO\">British Indian Ocean Territory</option>\n        <option value=\"VG\">British Virgin Islands</option>\n        <option value=\"BN\">Brunei</option>\n        <option value=\"BG\">Bulgaria</option>\n        <option value=\"BF\">Burkina Faso</option>\n        <option value=\"BI\">Burundi</option>\n        <option value=\"KH\">Cambodia</option>\n        <option value=\"CM\">Cameroon</option>\n        <option value=\"CA\">Canada</option>\n        <option value=\"CV\">Cape Verde</option>\n        <option value=\"KY\">Cayman Islands</option>\n        <option value=\"CF\">Central African Republic</option>\n        <option value=\"TD\">Chad</option>\n        <option value=\"CL\">Chile</option>\n        <option value=\"CN\">China</option>\n        <option value=\"CX\">Christmas Island</option>\n        <option value=\"CC\">Cocos [Keeling] Islands</option>\n        <option value=\"CO\">Colombia</option>\n        <option value=\"KM\">Comoros</option>\n        <option value=\"CD\">Congo [DRC]</option>\n        <option value=\"CG\">Congo [Republic]</option>\n        <option value=\"CK\">Cook Islands</option>\n        <option value=\"CR\">Costa Rica</option>\n        <option value=\"CI\">Cote d'Ivoire</option>\n        <option value=\"HR\">Croatia</option>\n        <option value=\"CU\">Cuba</option>\n        <option value=\"CY\">Cyprus</option>\n        <option value=\"CZ\">Czech Republic</option>\n        <option value=\"DK\">Denmark</option>\n        <option value=\"DJ\">Djibouti</option>\n        <option value=\"DM\">Dominica</option>\n        <option value=\"DO\">Dominican Republic</option>\n        <option value=\"EC\">Ecuador</option>\n        <option value=\"EG\">Egypt</option>\n        <option value=\"SV\">El Salvador</option>\n        <option value=\"GQ\">Equatorial Guinea</option>\n        <option value=\"ER\">Eritrea</option>\n        <option value=\"EE\">Estonia</option>\n        <option value=\"ET\">Ethiopia</option>\n        <option value=\"FK\">Falkland Islands [Islas Malvinas]</option>\n        <option value=\"FO\">Faroe Islands</option>\n        <option value=\"FJ\">Fiji</option>\n        <option value=\"FI\">Finland</option>\n        <option value=\"FR\">France</option>\n        <option value=\"GF\">French Guiana</option>\n        <option value=\"PF\">French Polynesia</option>\n        <option value=\"TF\">French Southern Territories</option>\n        <option value=\"GA\">Gabon</option>\n        <option value=\"GM\">Gambia</option>\n        <option value=\"GE\">Georgia</option>\n        <option value=\"DE\">Germany</option>\n        <option value=\"GH\">Ghana</option>\n        <option value=\"GI\">Gibraltar</option>\n        <option value=\"GR\">Greece</option>\n        <option value=\"GL\">Greenland</option>\n        <option value=\"GD\">Grenada</option>\n        <option value=\"GP\">Guadeloupe</option>\n        <option value=\"GU\">Guam</option>\n        <option value=\"GT\">Guatemala</option>\n        <option value=\"GN\">Guinea</option>\n        <option value=\"GW\">Guinea-Bissau</option>\n        <option value=\"GY\">Guyana</option>\n        <option value=\"HT\">Haiti</option>\n        <option value=\"HM\">Heard Island and McDonald Islands</option>\n        <option value=\"HN\">Honduras</option>\n        <option value=\"HK\">Hong Kong</option>\n        <option value=\"HU\">Hungary</option>\n        <option value=\"IS\">Iceland</option>\n        <option value=\"IN\">India</option>\n        <option value=\"ID\">Indonesia</option>\n        <option value=\"IR\">Iran</option>\n        <option value=\"IQ\">Iraq</option>\n        <option value=\"IE\">Ireland</option>\n        <option value=\"IL\">Israel</option>\n        <option value=\"IT\">Italy</option>\n        <option value=\"JM\">Jamaica</option>\n        <option value=\"JP\">Japan</option>\n        <option value=\"JO\">Jordan</option>\n        <option value=\"KZ\">Kazakhstan</option>\n        <option value=\"KE\">Kenya</option>\n        <option value=\"KI\">Kiribati</option>\n        <option value=\"KW\">Kuwait</option>\n        <option value=\"KG\">Kyrgyzstan</option>\n        <option value=\"LA\">Laos</option>\n        <option value=\"LV\">Latvia</option>\n        <option value=\"LB\">Lebanon</option>\n        <option value=\"LS\">Lesotho</option>\n        <option value=\"LR\">Liberia</option>\n        <option value=\"LY\">Libya</option>\n        <option value=\"LI\">Liechtenstein</option>\n        <option value=\"LT\">Lithuania</option>\n        <option value=\"LU\">Luxembourg</option>\n        <option value=\"MO\">Macau</option>\n        <option value=\"MK\">Macedonia [FYROM]</option>\n        <option value=\"MG\">Madagascar</option>\n        <option value=\"MW\">Malawi</option>\n        <option value=\"MY\">Malaysia</option>\n        <option value=\"MV\">Maldives</option>\n        <option value=\"ML\">Mali</option>\n        <option value=\"MT\">Malta</option>\n        <option value=\"MH\">Marshall Islands</option>\n        <option value=\"MQ\">Martinique</option>\n        <option value=\"MR\">Mauritania</option>\n        <option value=\"MU\">Mauritius</option>\n        <option value=\"YT\">Mayotte</option>\n        <option value=\"MX\">Mexico</option>\n        <option value=\"FM\">Micronesia</option>\n        <option value=\"MD\">Moldova</option>\n        <option value=\"MC\">Monaco</option>\n        <option value=\"MN\">Mongolia</option>\n        <option value=\"MS\">Montserrat</option>\n        <option value=\"MA\">Morocco</option>\n        <option value=\"MZ\">Mozambique</option>\n        <option value=\"MM\">Myanmar [Burma]</option>\n        <option value=\"NA\">Namibia</option>\n        <option value=\"NR\">Nauru</option>\n        <option value=\"NP\">Nepal</option>\n        <option value=\"NL\">Netherlands</option>\n        <option value=\"AN\">Netherlands Antilles</option>\n        <option value=\"NC\">New Caledonia</option>\n        <option value=\"NZ\">New Zealand</option>\n        <option value=\"NI\">Nicaragua</option>\n        <option value=\"NE\">Niger</option>\n        <option value=\"NG\">Nigeria</option>\n        <option value=\"NU\">Niue</option>\n        <option value=\"NF\">Norfolk Island</option>\n        <option value=\"KP\">North Korea</option>\n        <option value=\"MP\">Northern Mariana Islands</option>\n        <option value=\"NO\">Norway</option>\n        <option value=\"OM\">Oman</option>\n        <option value=\"PK\">Pakistan</option>\n        <option value=\"PW\">Palau</option>\n        <option value=\"PS\">Palestinian Territories</option>\n        <option value=\"PA\">Panama</option>\n        <option value=\"PG\">Papua New Guinea</option>\n        <option value=\"PY\">Paraguay</option>\n        <option value=\"PE\">Peru</option>\n        <option value=\"PH\">Philippines</option>\n        <option value=\"PN\">Pitcairn Islands</option>\n        <option value=\"PL\">Poland</option>\n        <option value=\"PT\">Portugal</option>\n        <option value=\"PR\">Puerto Rico</option>\n        <option value=\"QA\">Qatar</option>\n        <option value=\"RE\">Reunion</option>\n        <option value=\"RO\">Romania</option>\n        <option value=\"RU\">Russia</option>\n        <option value=\"RW\">Rwanda</option>\n        <option value=\"SH\">Saint Helena</option>\n        <option value=\"KN\">Saint Kitts and Nevis</option>\n        <option value=\"LC\">Saint Lucia</option>\n        <option value=\"PM\">Saint Pierre and Miquelon</option>\n        <option value=\"VC\">Saint Vincent and the Grenadines</option>\n        <option value=\"WS\">Samoa</option>\n        <option value=\"SM\">San Marino</option>\n        <option value=\"ST\">Sao Tome and Prncipe</option>\n        <option value=\"SA\">Saudi Arabia</option>\n        <option value=\"SN\">Senegal</option>\n        <option value=\"YU\">Serbia</option>\n        <option value=\"SC\">Seychelles</option>\n        <option value=\"SL\">Sierra Leone</option>\n        <option value=\"SG\">Singapore</option>\n        <option value=\"SK\">Slovakia</option>\n        <option value=\"SI\">Slovenia</option>\n        <option value=\"SB\">Solomon Islands</option>\n        <option value=\"SO\">Somalia</option>\n        <option value=\"ZA\">South Africa</option>\n        <option value=\"GS\">South Georgia and the South Sandwich Islands</option>\n        <option value=\"KR\">South Korea</option>\n        <option value=\"ES\">Spain</option>\n        <option value=\"LK\">Sri Lanka</option>\n        <option value=\"SD\">Sudan</option>\n        <option value=\"SR\">Suriname</option>\n        <option value=\"SJ\">Svalbard and Jan Mayen</option>\n        <option value=\"SZ\">Swaziland</option>\n        <option value=\"SE\">Sweden</option>\n        <option value=\"CH\">Switzerland</option>\n        <option value=\"SY\">Syria</option>\n        <option value=\"TW\">Taiwan</option>\n        <option value=\"TJ\">Tajikistan</option>\n        <option value=\"TZ\">Tanzania</option>\n        <option value=\"TH\">Thailand</option>\n        <option value=\"TG\">Togo</option>\n        <option value=\"TK\">Tokelau</option>\n        <option value=\"TO\">Tonga</option>\n        <option value=\"TT\">Trinidad and Tobago</option>\n        <option value=\"TN\">Tunisia</option>\n        <option value=\"TR\">Turkey</option>\n        <option value=\"TM\">Turkmenistan</option>\n        <option value=\"TC\">Turks and Caicos Islands</option>\n        <option value=\"TV\">Tuvalu</option>\n        <option value=\"UM\">U.S. Minor Outlying Islands</option>\n        <option value=\"VI\">U.S. Virgin Islands</option>\n        <option value=\"UG\">Uganda</option>\n        <option value=\"UA\">Ukraine</option>\n        <option value=\"AE\">United Arab Emirates</option>\n        <option value=\"GB\">United Kingdom</option>\n        <option value=\"US\">United States</option>\n        <option value=\"UY\">Uruguay</option>\n        <option value=\"UZ\">Uzbekistan</option>\n        <option value=\"VU\">Vanuatu</option>\n        <option value=\"VA\">Vatican City</option>\n        <option value=\"VE\">Venezuela</option>\n        <option value=\"VN\">Vietnam</option>\n        <option value=\"WF\">Wallis and Futuna</option>\n        <option value=\"EH\">Western Sahara</option>\n        <option value=\"YE\">Yemen</option>\n        <option value=\"ZM\">Zambia</option>\n        <option value=\"ZW\">Zimbabwe</option>\n      ";
  }

function program7(depth0,data) {
  
  
  return "\n        Update Profile\n      ";
  }

function program9(depth0,data) {
  
  
  return "\n        Create Profile\n      ";
  }

function program11(depth0,data) {
  
  
  return "\n    <button class=\"delete\">\n      Delete Profile\n    </button>\n   ";
  }

  buffer += "  <div class=\"profile-edit\">\n  <h1>Add Profile</h1>\n\n  <p>Create a profile so you can quickly rerun custom, targeted search results.</p>\n\n  <div>\n  <select name=\"engine\" class=\"engine\">\n    ";
  stack1 = (helper = helpers.select || (depth0 && depth0.select),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.engine), options) : helperMissing.call(depth0, "select", (depth0 && depth0.engine), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </select>\n  </div>\n  <div>\n  <label>\n    <input type=\"checkbox\" class=\"disable-personalization\"\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.disablePersonalization), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n      Show non-personalized results</input>\n  </label>\n  </div>\n  <div>\n    <select name=\"country\" class=\"country\">\n      ";
  stack1 = (helper = helpers.select || (depth0 && depth0.select),options={hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.country), options) : helperMissing.call(depth0, "select", (depth0 && depth0.country), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </select>\n  </div>\n\n  <div>\n  <select name=\"region\" class=\"region\">\n  </select>\n  </div>\n\n  <div>\n  <select name=\"city\" class=\"city\">\n  </select>\n  </div>\n\n  <div>\n  <input type=\"text\" name=\"name\" placeholder=\"Name\" value=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" class=\"name\"/>\n  </div>\n\n  <div class=\"actions\">\n    <button class=\"save\">\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.id), {hash:{},inverse:self.program(9, program9, data),fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </button>\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.id), {hash:{},inverse:self.noop,fn:self.program(11, program11, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    <button class=\"cancel\">Cancel</button>\n  </div>\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":162}],102:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this, functionType="function", blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data,depth1) {
  
  var buffer = "", helper, options;
  buffer += "\n  "
    + escapeExpression((helper = helpers.option || (depth0 && depth0.option),options={hash:{
    'value': ((depth0 && depth0.name)),
    'text': ((depth0 && depth0.name))
  },data:data},helper ? helper.call(depth0, (depth1 && depth1.city), options) : helperMissing.call(depth0, "option", (depth1 && depth1.city), options)))
    + "\n";
  return buffer;
  }

  buffer += "<option value=\"\">City</option>\n";
  options={hash:{},inverse:self.noop,fn:self.programWithDepth(1, program1, data, depth0),data:data}
  if (helper = helpers.cities) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.cities); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.cities) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.programWithDepth(1, program1, data, depth0),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":162}],103:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this, functionType="function", blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data,depth1) {
  
  var buffer = "", helper, options;
  buffer += "\n  "
    + escapeExpression((helper = helpers.option || (depth0 && depth0.option),options={hash:{
    'value': ((depth0 && depth0.code)),
    'text': ((depth0 && depth0.name))
  },data:data},helper ? helper.call(depth0, (depth1 && depth1.region), options) : helperMissing.call(depth0, "option", (depth1 && depth1.region), options)))
    + "\n";
  return buffer;
  }

  buffer += "<option value=\"\">Region</option>\n";
  options={hash:{},inverse:self.noop,fn:self.programWithDepth(1, program1, data, depth0),data:data}
  if (helper = helpers.regions) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.regions); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.regions) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.programWithDepth(1, program1, data, depth0),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":162}],104:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <li class=\"search-profile\" data-engine=\"";
  if (helper = helpers.engine) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.engine); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-id=\"";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n        ";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n        <div class=\"edit-profile\"></div>\n      </li>\n    ";
  return buffer;
  }

  buffer += "<div class=\"content\">\n  <div class=\"divider divider-top\"></div>\n  <ul>\n    ";
  stack1 = helpers.each.call(depth0, depth0, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    <li class=\"search-profile add-new\">\n      Add New Profile\n      <div class=\"edit-profile\"></div>\n    </li>\n  </ul>\n  <div class=\"divider divider-bottom\"></div>\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":162}],105:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  
  return "check";
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n          <p>Schema.org found on this page.</p>\n          <div class=\"cta\">\n          Preview in\n            <a href=\"";
  if (helper = helpers.richSnippetToolUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.richSnippetToolUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" target=\"_blank\">\n              Structured Data Testing Tool\n            </a>\n          </div>\n        ";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n          <p>Schema.org not found on this page.</p>\n\n          <p>Implementing schema.org structured data in a page lets search engines understand more about the contentand can allow pages to be shown in different search features, such as Reviews and Recipes. This can increase click-through!</p>\n\n          <p>Google provides a\n            <a href=\"";
  if (helper = helpers.richSnippetToolUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.richSnippetToolUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" target=\"_blank\">\n              Structured Data Testing Tool\n            </a>\n            that allows you to test and validate markup.\n          </p>\n\n          <p>\n          To learn more about schema.org, visit\n          <a href=\"https://support.google.com/webmasters/answer/1211158?hl=en\" target=\"_blank\">\n          Google's Schema.org FAQ.\n          </a>\n          </p>\n        ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <p>Open Graph protocol found on this page.</p>\n        <div class=\"cta\">\n          Preview in\n          <a href=\"";
  if (helper = helpers.openGraphToolUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.openGraphToolUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" target=\"_blank\">\n            Facebook Open Graph Object Debugger.\n          </a>\n        </div>\n        ";
  return buffer;
  }

function program9(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n          <p>Open Graph protocol not found on this page.</p>\n\n          <p>\n            Implementing Open Graph protocol structured data determines how a page appears when it is shared on Facebookand on other social media sites. This can increase engagement.\n          </p>\n\n          <p>\n            Facebook provides an\n            <a href=\"";
  if (helper = helpers.openGraphToolUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.openGraphToolUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" target=\"_blank\">\n              Open Graph Object Debugger\n            </a>\n            that allows you to test and validate your markup.\n          </p>\n\n          <p>\n            Visit this page to learn more about\n            <a href=\"http://ogp.me/\" target=\"_blank\">\n              Open Graph protocol\n            </a>\n          </p>\n        ";
  return buffer;
  }

function program11(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n          Microformats found on this page.\n\n          Preview in\n          <a href=\"";
  if (helper = helpers.richSnippetToolUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.richSnippetToolUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"  target=\"_blank\">\n            Google Structured Data Testing Tool\n          </a>.\n        ";
  return buffer;
  }

function program13(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n          <p>Microformats not found on this page.</p>\n\n          <p>\n          Implementing microformats structured data on a page lets search engines understand more about the contentand allows pages to be shown in different search features, such as Reviews and Recipes. These can increase click-through.\n          </p>\n\n          <p>\n          Google provides a\n          <a href=\"";
  if (helper = helpers.richSnippetToolUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.richSnippetToolUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" target=\"_blank\">\n            Structured Data Testing Tool\n          </a>.\n          that allows you to test and validate markup.\n          </p>\n\n          <p>\n            To learn more about microformats, visit\n            <a href=\"http://microformats.org/\" target=\"_blank\">\n            the microformats documentation page</a>.\n          </p>\n        ";
  return buffer;
  }

  buffer += "\n\n<div class=\"semantics\">\n  <div class=\"column snippet-column\">\n    <div class=\"header\">Type</div>\n    <div class=\"snippet scrollable\">\n      <div class=\"content ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.hasSchema), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n        data-show=\"schema\">Schema.org</div>\n      <div class=\"content ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.hasOpenGraph), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n        data-show=\"open-graph\">Open Graph Protocol</div>\n      <div class=\"content ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.hasTwitter), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n        data-show=\"twitter\">Twitter Cards</div>\n      <div class=\"content ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.hasMicroformats), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n        data-show=\"microformats\">Microformats</div>\n    </div>\n  </div>\n\n  <div class=\"column preview-column\">\n    <div class=\"header\">Preview</div>\n    <div class=\"preview scrollable\">\n      <div class=\"content schema\">\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.hasSchema), {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </div>\n\n      <div class=\"content open-graph\">\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.hasOpenGraph), {hash:{},inverse:self.program(9, program9, data),fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </div>\n      <div class=\"content twitter\">\n      </div>\n\n      <div class=\"content microformats\">\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.hasMicroformats), {hash:{},inverse:self.program(13, program13, data),fn:self.program(11, program11, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </div>\n    </div>\n  </div>\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":162}],106:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  
  return "/";
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "<p class=\"line\">";
  if (helper = helpers.niceUipl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.niceUipl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + " RDs</p>";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n            <p class=\"line\">";
  if (helper = helpers.nicePuid) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.nicePuid); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + " links /</p>\n            <p class=\"line\">";
  if (helper = helpers.nicePid) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.nicePid); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + " RDs</p>\n          ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      <a href=\"http://moz.com/login\" target=\"_blank\">\n        <div class=\"btn lock\" data-tooltip=\"Get more metrics<br><span class=cta>Log in with Moz</span>\">\n          ";
  stack1 = self.invokePartial(partials['locked-icon'], 'locked-icon', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          <div class=\"onboarding-text\">\n            Log in to your <em>Moz Pro</em> account for more features, like Keyword Difficulty and enhanced link metrics.\n          </div>\n        </div>\n      </a>\n    ";
  return buffer;
  }

  buffer += "<style>\n";
  if (helper = helpers.css) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.css); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n</style>\n<div class=\"mozbar-css-wGA7MhRhQ3WS\">\n  <div class=\"serp-item\">\n    <div class=\"page-stats\">\n      <div class=\"stat\">\n        <div class=\"position\">";
  if (helper = helpers.position) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.position); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ")</div>\n        <div class=\"title\">PA: ";
  if (helper = helpers.niceUpa) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.niceUpa); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n        <div class=\"scale-outer\">\n          <div class=\"scale-inner\" style=\"width: ";
  if (helper = helpers.niceUpa) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.niceUpa); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "%\"></div>\n        </div>\n      </div>\n      <div class=\"links\">\n        <a href=\"http://moz.com/researchtools/ose/links?site=";
  if (helper = helpers.pageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.pageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "&src=mb\" target=\"_blank\">\n          <p class=\"line\">";
  if (helper = helpers.niceUid) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.niceUid); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + " links ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.user)),stack1 == null || stack1 === false ? stack1 : stack1.isPro), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</p>\n          ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.user)),stack1 == null || stack1 === false ? stack1 : stack1.isPro), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        </a>\n      </div>\n\n      <div class=\"divider\"></div>\n\n      <div class=\"stat\">\n        <div class=\"title\">DA: ";
  if (helper = helpers.nicePda) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.nicePda); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n        <div class=\"scale-outer\">\n          <div class=\"scale-inner alt\" style=\"width: ";
  if (helper = helpers.nicePda) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.nicePda); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "%\"></div>\n        </div>\n      </div>\n\n      <div class=\"links\">\n        <a href=\"http://moz.com/researchtools/ose/links?site=";
  if (helper = helpers.rootDomain) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.rootDomain); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "&src=mb\" target=\"_blank\">\n          ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.user)),stack1 == null || stack1 === false ? stack1 : stack1.isPro), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        </a>\n      </div>\n    </div>\n\n    ";
  stack1 = helpers.unless.call(depth0, ((stack1 = (depth0 && depth0.user)),stack1 == null || stack1 === false ? stack1 : stack1.isPro), {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n\n    <div class=\"right-panel\">\n      <div class=\"divider\"></div>\n\n      <a href=\"http://moz.com/researchtools/ose/links?site=";
  if (helper = helpers.pageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.pageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "&src=mb\" target=\"_blank\">\n        <div class=\"btn link-analysis\" data-tooltip=\"Link Analysis with OSE\">\n          ";
  stack1 = self.invokePartial(partials['ose-icon'], 'ose-icon', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          <p>Link Analysis</p>\n          <div class=\"onboarding-text\">\n            Do a deeper link analysis by opening this page in <em>Open Site Explorer</em>.\n          </div>\n        </div>\n      </a>\n    </div>\n  </div>\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":162}],107:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  
  return "\n    <div class=\"right-panel\">\n      <a href=\"http://moz.com/login\" target='_blank'>\n        Log in\n      </a>\n    </div>\n  ";
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    <div class=\"right-panel\">\n      <a href=\"http://moz.com/community/users/"
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.user)),stack1 == null || stack1 === false ? stack1 : stack1.display_name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" target=\"_blank\">\n        "
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.user)),stack1 == null || stack1 === false ? stack1 : stack1.display_name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\n      </a>\n\n      <a href=\"http://moz.com/logout\" target=\"_blank\" class=\"logout\">\n        Logout\n      </a>\n  ";
  return buffer;
  }

  buffer += "<div class=\"serp-toolbar\">\n  <div class=\"btn export\" data-tooltip=\"Export SERP Analysis to CSV\">\n    ";
  stack1 = self.invokePartial(partials['export-icon'], 'export-icon', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    <div class=\"onboarding-text\">\n      <em>Export this SERP to a CSV.</em>\n    </div>\n  </div>\n\n  <div class=\"divider\"></div>\n\n  <h3>Search Profiles</h3>\n\n  <div class=\"btn search-profile selected\" data-engine=\""
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.profile)),stack1 == null || stack1 === false ? stack1 : stack1.engine)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"\n    data-tooltip=\"\">\n      "
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.profile)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\n      <div class=\"arrow arrow-down\" />\n      <div class=\"onboarding-text\">\n        <p>Open <em>Search Profiles</em>.</p>\n        <p>Use the MozBar to perform geo-located searches.</p>\n      </div>\n  </div>\n\n  ";
  stack1 = helpers.unless.call(depth0, ((stack1 = (depth0 && depth0.user)),stack1 == null || stack1 === false ? stack1 : stack1.isPro), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n  ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.user)),stack1 == null || stack1 === false ? stack1 : stack1.isPro), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":162}],108:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  
  return "\n      <div class=\"col\">\n        <p>\n          Connecting your Moz Pro subscription gets you access to more\n          link metrics and functionality within the Mozbar.\n          <a href=\"http://moz.com/pro/mozbar\" target=\"_blank\">Learn more</a>\n        </p>\n      </div>\n      <div class=\"col\">\n        <a class=\"login-button\" href=\"http://moz.com/login\" target=\"_blank\">\n          Login with Moz Pro\n        </a>\n      </div>\n    ";
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"col\">\n        <div class=\"pro\">\n          <p>Logged in as:</p>\n          <div class=\"username\">";
  if (helper = helpers.display_name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.display_name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n        </div>\n      </div>\n      <div class=\"col \">\n        <div class=\"logout\">\n          <a href=\"http://moz.com/logout\" target=\"_blank\">(X) Logout</a>\n        </div>\n      </div>\n    ";
  return buffer;
  }

  buffer += "<div class=\"arrow-up\"></div>\n<div class=\"content\">\n  <div class=\"padded\">\n    <div class=\"row full\">\n      <div class=\"col\">\n        <h2>MozBar Settings</h2>\n      </div>\n      <div class=\"col switch-container\">\n        <span class=\"title\">Theme:</span>\n        <label class=\"switch-label light on\">Dark</label>\n        <div class=\"onoffswitch\">\n          <input type=\"checkbox\" name=\"onoffswitch\" class=\"checkbox\" id=\"lightdarkswitch\">\n          <label for=\"lightdarkswitch\">\n            <span class=\"inner\"></span>\n            <span class=\"switch\"></span>\n          </label>\n        </div>\n        <label class=\"switch-label light\">Light</label>\n      </div>\n    </div>\n\n    <div class=\"divider\" />\n\n    <div class=\"row metrics\">\n      <div class=\"col\">\n        <label>\n          <input type=\"checkbox\" data-col=\"umrp\">MozRank (MR)</input>\n        </label>\n        <label>\n          <input type=\"checkbox\" data-col=\"pmrp\">Domain MozRank (DMR)</input>\n        </label>\n      </div>\n      <div class=\"col\">\n        <label>\n          <input type=\"checkbox\" data-col=\"utrp\">MozTrust (MT)</input>\n        </label>\n        <label>\n          <input type=\"checkbox\" data-col=\"ptrp\">Domain MozTrust (DMT)</input>\n        </label>\n      </div>\n      <div class=\"col\">\n        <label>\n          <input type=\"checkbox\" data-col=\"links\">Link Metrics</input>\n        </label>\n        <label>\n          <input type=\"checkbox\" data-col=\"fspsc\">Spam Score</input>\n        </label>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col\">\n        <span class=\"tip\">\n          <em>TIP: Easily toggle the MozBar between modes</em> (without disabling the extension)\n        </span>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col shortcut\">\n        <p><b>OSX:</b> Cmd+Option+Ctrl+M</p>\n      </div>\n      <div class=\"col shortcut\">\n        <p><em>Windows:</em> Shift+Ctrl+Alt+M</p>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col\">\n        <h2>More by Moz</h2>\n        <div class=\"divider\"></div>\n      </div>\n    </div>\n\n    <div class=\"row\">\n      <div class=\"col\">\n        <a href=\"http://analytics.moz.com/pro/home\" target=\"_blank\">Moz Campaign Dashboard</a>\n        <a href=\"http://moz.com\" target=\"_blank\">Moz.com</a>\n        <div class=\"spacer\"></div>\n        <a href=\"http://moz.com/blog\" target=\"_blank\">The Moz Blog</a>\n        <a href=\"http://moz.com/community/q\" taret=\"_blank\">Q&amp;A</a>\n      </div>\n\n      <div class=\"col\">\n        <a href=\"http://moz.com/researchtools/ose/links?site=";
  if (helper = helpers.pageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.pageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "&src=mb\">Open Site Explorer</a>\n        <a href=\"http://moz.com/researchtools/ose/pages?site=";
  if (helper = helpers.pageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.pageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "&src=mb\">Top Pages</a>\n        <a href=\"http://pro.moz.com/tools/keyword-difficulty/\">Keyword Analysis</a>\n        <a href=\"http://getlisted.org?src=mb\">GetListed</a>\n        <a href=\"http://freshwebexplorer.moz.com\">Fresh Web Explorer</a>\n      </div>\n\n      <div class=\"col\">\n        <a href=\"http://ranktracker.moz.com/?src=mb\">Rank Tracker</a>\n        <a href=\"http://pro.moz.com/tools/on-page-keyword-optimization/new\">On Page Grader</a>\n        <a href=\"https://followerwonk.com?src=mb\">Followerwonk</a>\n        <a href=\"http://mozcast.com?src=mb\">MozCast</a>\n      </div>\n    </div>\n  </div>\n  <div class=\"row full login\">\n    ";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.isPro), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.isPro), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n\n</div>\n<div class=\"arrow-down\"></div>\n\n";
  return buffer;
  });

},{"hbsfy/runtime":162}],109:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div class=\"social\" data-tooltip=\"";
  if (helper = helpers.tooltip) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.tooltip); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n  <div class=\"icon ";
  if (helper = helpers.site) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.site); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"></div>\n  <div class=\"count\">";
  if (helper = helpers.count) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.count); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":162}],110:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, self=this;


  buffer += "<div class=\"toolbar tooltip-container\">\n  <div class=\"logo\"></div>\n\n  <div class=\"toolbar-panel\"></div>\n\n  <div class=\"right-panel\">\n    <div class=\"btn help\" data-tooltip=\"Help\">\n      <p>?</p>\n\n      <div class=\"onboarding-text\">\n        <p>Get <em>Help</em>.</p>\n\n        <p>Find help on the MozBar and request features, and get back to this tutorial.</p>\n      </div>\n    </div>\n\n    <div class=\"divider\"></div>\n\n    <div class=\"btn settings\" data-tooltip=\"Tools &amp; Settings\">\n      ";
  stack1 = self.invokePartial(partials['settings-icon'], 'settings-icon', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n      <div class=\"onboarding-text\">\n        <p>Open <em>Tool and Settings</em>.\n\n        <p>Customize your MozBar to fit your needs and look as well as access helpful links.</p>\n      </div>\n    </div>\n    <div class=\"btn dock\" data-tooltip=\"Dock to Bottom of Browser\">\n      ";
  stack1 = self.invokePartial(partials['dock-icon'], 'dock-icon', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n    <div class=\"btn close\" data-tooltip=\"Turn Off<br />MozBar\" >\n      ";
  stack1 = self.invokePartial(partials['close-icon'], 'close-icon', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      <div class=\"onboarding-text\">\n        <p><em>Turn off the MozBar</em>.</p>\n\n        <p>You can turn it on at any time by clicking the <span class=\"icon off\"></span> icon to the right of the address bar.</p>\n      </div>\n    </div>\n  </div>\n</div>\n<div class=\"panel\"></div>\n";
  return buffer;
  });

},{"hbsfy/runtime":162}],111:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div class=\"";
  if (helper = helpers.placement) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.placement); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n  <div class=\"arrow-up\"></div>\n  <div class=\"text\"><p>";
  if (helper = helpers.text) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.text); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</p></div>\n  <div class=\"arrow-down\"></div>\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":162}],112:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  
  return "\n  Twitter cards found on this page.\n";
  }

function program3(depth0,data) {
  
  
  return "\n  <p>Twitter Cards not found on this page.</p>\n\n  <p>\n    Implementing Twitter Cards metadata determines how a page appears when it is shared on Twitter. This can increase engagement.\n  </p>\n\n  <p>\n    To learn more about Twitter Cards, visit the\n      <a href=\"https://dev.twitter.com/docs/cards\" target=\"_blank\">\n        Twitter card\n      </a>\n    documentation.\n  </p>\n";
  }

function program5(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <div class=\"summary\">\n    <h3>Summary Card</h3>\n    <div class=\"site\">\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.site)),stack1 == null || stack1 === false ? stack1 : stack1.image), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      "
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.site)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\n    </div>\n    <div class=\"container\">\n      <div class=\"col1\">\n        <h4>";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h4>\n        <div class=\"byline\">"
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.creator)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " "
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.creator)),stack1 == null || stack1 === false ? stack1 : stack1.handle)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " </div>\n        <div class=\"blurb\">";
  if (helper = helpers.description) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.description); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n      </div>\n      <div class=\"col2\">\n        <div class=\"card-image\" style=\"background-image: url('";
  if (helper = helpers.image) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.image); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\"></div>\n      </div>\n    </div>\n  </div>\n";
  return buffer;
  }
function program6(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "<img src=\""
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.site)),stack1 == null || stack1 === false ? stack1 : stack1.image)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" />";
  return buffer;
  }

function program8(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <div class=\"summary-large-image\">\n    <h3>Summary Large Image Card</h3>\n    <div class=\"site\">\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.site)),stack1 == null || stack1 === false ? stack1 : stack1.image), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      "
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.site)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\n    </div>\n    <div class=\"card-image\"><img src=\"";
  if (helper = helpers.image) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.image); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" /></div>\n    <h4>";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h4>\n    <div class=\"byline\">"
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.creator)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " "
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.creator)),stack1 == null || stack1 === false ? stack1 : stack1.handle)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " </div>\n    <div class=\"blurb\">";
  if (helper = helpers.description) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.description); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n  </div>\n";
  return buffer;
  }

function program10(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <div class=\"product\">\n    <h3>Product Card</h3>\n    <div class=\"site\">\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.site)),stack1 == null || stack1 === false ? stack1 : stack1.image), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      "
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.site)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\n    </div>\n    <h4>";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h4>\n    By <div class=\"byline\">"
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.creator)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " "
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.creator)),stack1 == null || stack1 === false ? stack1 : stack1.handle)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " </div>\n    <div class=\"container\">\n      <div class=\"col1\">\n        <div class=\"card-image\" style=\"background-image: url('";
  if (helper = helpers.image) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.image); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\"></div>\n      </div>\n      <div class=\"col2\">\n        <div class=\"divider\"></div>\n        <div class=\"data\">";
  if (helper = helpers.data1) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.data1); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n        <div class=\"label\">";
  if (helper = helpers.label1) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.label1); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n        <div class=\"divider\"></div>\n        <div class=\"data\">";
  if (helper = helpers.data2) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.data2); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n        <div class=\"label\">";
  if (helper = helpers.label2) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.label2); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n        <div class=\"divider\"></div>\n      </div>\n    </div>\n    <div class=\"blurb\">";
  if (helper = helpers.description) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.description); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n  </div>\n";
  return buffer;
  }

function program12(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <div class=\"photo\">\n    <h3>Photo Card</h3>\n    <div class=\"card-image\"><img src=\"";
  if (helper = helpers.image) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.image); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" /></div>\n    <h4>";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h4>\n    <div class=\"byline\">"
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.creator)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " "
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.creator)),stack1 == null || stack1 === false ? stack1 : stack1.handle)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " </div>\n    <div class=\"blurb\">";
  if (helper = helpers.description) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.description); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n    <div class=\"site\">\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.site)),stack1 == null || stack1 === false ? stack1 : stack1.image), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      "
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.site)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\n    </div>\n  </div>\n";
  return buffer;
  }

function program14(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <div class=\"gallery\">\n    <h3>Gallery Card</h3>\n    <div class=\"site\">\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.site)),stack1 == null || stack1 === false ? stack1 : stack1.image), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      "
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.site)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\n    </div>\n    <div class=\"card-image\" style=\"background-image: url('";
  if (helper = helpers.image0) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.image0); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\"></div>\n    <div class=\"card-image\" style=\"background-image: url('";
  if (helper = helpers.image1) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.image1); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\"></div>\n    <div class=\"card-image\" style=\"background-image: url('";
  if (helper = helpers.image2) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.image2); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\"></div>\n    <div class=\"card-image\" style=\"background-image: url('";
  if (helper = helpers.image3) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.image3); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\"></div>\n    <h4>";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h4>\n    <div class=\"byline\">"
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.creator)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " "
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.creator)),stack1 == null || stack1 === false ? stack1 : stack1.handle)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " </div>\n    <div class=\"blurb\">";
  if (helper = helpers.description) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.description); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n    <div class=\"site\">\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.site)),stack1 == null || stack1 === false ? stack1 : stack1.image), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      "
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.site)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\n    </div>\n  </div>\n";
  return buffer;
  }

function program16(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <div class=\"player\">\n    <h3>Player Card</h3>\n    <div class=\"site\">\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.site)),stack1 == null || stack1 === false ? stack1 : stack1.image), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      "
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.site)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\n    </div>\n    <iframe width=\"500\" height=\"375\" src=\"";
  if (helper = helpers.player) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.player); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n      frameborder=\"0\" allowfullscreen></iframe>\n\n    <h4>";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h4>\n    <div class=\"byline\">"
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.creator)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " "
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.creator)),stack1 == null || stack1 === false ? stack1 : stack1.handle)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " </div>\n    <div class=\"blurb\">";
  if (helper = helpers.description) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.description); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n  </div>\n";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.hasTwitter), {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n";
  stack1 = (helper = helpers.ifEqual || (depth0 && depth0.ifEqual),options={hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.cardType), "summary", options) : helperMissing.call(depth0, "ifEqual", (depth0 && depth0.cardType), "summary", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n";
  stack1 = (helper = helpers.ifEqual || (depth0 && depth0.ifEqual),options={hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.cardType), "summary_large_image", options) : helperMissing.call(depth0, "ifEqual", (depth0 && depth0.cardType), "summary_large_image", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n";
  stack1 = (helper = helpers.ifEqual || (depth0 && depth0.ifEqual),options={hash:{},inverse:self.noop,fn:self.program(10, program10, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.cardType), "product", options) : helperMissing.call(depth0, "ifEqual", (depth0 && depth0.cardType), "product", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n";
  stack1 = (helper = helpers.ifEqual || (depth0 && depth0.ifEqual),options={hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.cardType), "photo", options) : helperMissing.call(depth0, "ifEqual", (depth0 && depth0.cardType), "photo", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n";
  stack1 = (helper = helpers.ifEqual || (depth0 && depth0.ifEqual),options={hash:{},inverse:self.noop,fn:self.program(14, program14, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.cardType), "gallery", options) : helperMissing.call(depth0, "ifEqual", (depth0 && depth0.cardType), "gallery", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n";
  stack1 = (helper = helpers.ifEqual || (depth0 && depth0.ifEqual),options={hash:{},inverse:self.noop,fn:self.program(16, program16, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.cardType), "player", options) : helperMissing.call(depth0, "ifEqual", (depth0 && depth0.cardType), "player", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":162}],113:[function(require,module,exports){

},{}],114:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new TypeError('must start with number, buffer, array or string')

  if (this.length > kMaxLength)
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
      'size: 0x' + kMaxLength.toString(16) + ' bytes')

  var buf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    throw new TypeError('Arguments must be Buffers')

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function (b) {
  if(!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max)
      str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length, 2)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0)
    throw new RangeError('offset is not uint')
  if (offset + ext > length)
    throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80))
    return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  if (end < start) throw new TypeError('sourceEnd < sourceStart')
  if (target_start < 0 || target_start >= target.length)
    throw new TypeError('targetStart out of bounds')
  if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')
  if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new TypeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')
  if (end < 0 || end > this.length) throw new TypeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length, unitSize) {
  if (unitSize) length -= length % unitSize;
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":115,"ieee754":116,"is-array":117}],115:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],116:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],117:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],118:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],119:[function(require,module,exports){
var http = module.exports;
var EventEmitter = require('events').EventEmitter;
var Request = require('./lib/request');
var url = require('url')

http.request = function (params, cb) {
    if (typeof params === 'string') {
        params = url.parse(params)
    }
    if (!params) params = {};
    if (!params.host && !params.port) {
        params.port = parseInt(window.location.port, 10);
    }
    if (!params.host && params.hostname) {
        params.host = params.hostname;
    }

    if (!params.protocol) {
        if (params.scheme) {
            params.protocol = params.scheme + ':';
        } else {
            params.protocol = window.location.protocol;
        }
    }

    if (!params.host) {
        params.host = window.location.hostname || window.location.host;
    }
    if (/:/.test(params.host)) {
        if (!params.port) {
            params.port = params.host.split(':')[1];
        }
        params.host = params.host.split(':')[0];
    }
    if (!params.port) params.port = params.protocol == 'https:' ? 443 : 80;
    
    var req = new Request(new xhrHttp, params);
    if (cb) req.on('response', cb);
    return req;
};

http.get = function (params, cb) {
    params.method = 'GET';
    var req = http.request(params, cb);
    req.end();
    return req;
};

http.Agent = function () {};
http.Agent.defaultMaxSockets = 4;

var xhrHttp = (function () {
    if (typeof window === 'undefined') {
        throw new Error('no window object present');
    }
    else if (window.XMLHttpRequest) {
        return window.XMLHttpRequest;
    }
    else if (window.ActiveXObject) {
        var axs = [
            'Msxml2.XMLHTTP.6.0',
            'Msxml2.XMLHTTP.3.0',
            'Microsoft.XMLHTTP'
        ];
        for (var i = 0; i < axs.length; i++) {
            try {
                var ax = new(window.ActiveXObject)(axs[i]);
                return function () {
                    if (ax) {
                        var ax_ = ax;
                        ax = null;
                        return ax_;
                    }
                    else {
                        return new(window.ActiveXObject)(axs[i]);
                    }
                };
            }
            catch (e) {}
        }
        throw new Error('ajax not supported in this browser')
    }
    else {
        throw new Error('ajax not supported in this browser');
    }
})();

http.STATUS_CODES = {
    100 : 'Continue',
    101 : 'Switching Protocols',
    102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918
    200 : 'OK',
    201 : 'Created',
    202 : 'Accepted',
    203 : 'Non-Authoritative Information',
    204 : 'No Content',
    205 : 'Reset Content',
    206 : 'Partial Content',
    207 : 'Multi-Status',               // RFC 4918
    300 : 'Multiple Choices',
    301 : 'Moved Permanently',
    302 : 'Moved Temporarily',
    303 : 'See Other',
    304 : 'Not Modified',
    305 : 'Use Proxy',
    307 : 'Temporary Redirect',
    400 : 'Bad Request',
    401 : 'Unauthorized',
    402 : 'Payment Required',
    403 : 'Forbidden',
    404 : 'Not Found',
    405 : 'Method Not Allowed',
    406 : 'Not Acceptable',
    407 : 'Proxy Authentication Required',
    408 : 'Request Time-out',
    409 : 'Conflict',
    410 : 'Gone',
    411 : 'Length Required',
    412 : 'Precondition Failed',
    413 : 'Request Entity Too Large',
    414 : 'Request-URI Too Large',
    415 : 'Unsupported Media Type',
    416 : 'Requested Range Not Satisfiable',
    417 : 'Expectation Failed',
    418 : 'I\'m a teapot',              // RFC 2324
    422 : 'Unprocessable Entity',       // RFC 4918
    423 : 'Locked',                     // RFC 4918
    424 : 'Failed Dependency',          // RFC 4918
    425 : 'Unordered Collection',       // RFC 4918
    426 : 'Upgrade Required',           // RFC 2817
    428 : 'Precondition Required',      // RFC 6585
    429 : 'Too Many Requests',          // RFC 6585
    431 : 'Request Header Fields Too Large',// RFC 6585
    500 : 'Internal Server Error',
    501 : 'Not Implemented',
    502 : 'Bad Gateway',
    503 : 'Service Unavailable',
    504 : 'Gateway Time-out',
    505 : 'HTTP Version Not Supported',
    506 : 'Variant Also Negotiates',    // RFC 2295
    507 : 'Insufficient Storage',       // RFC 4918
    509 : 'Bandwidth Limit Exceeded',
    510 : 'Not Extended',               // RFC 2774
    511 : 'Network Authentication Required' // RFC 6585
};
},{"./lib/request":120,"events":118,"url":143}],120:[function(require,module,exports){
var Stream = require('stream');
var Response = require('./response');
var Base64 = require('Base64');
var inherits = require('inherits');

var Request = module.exports = function (xhr, params) {
    var self = this;
    self.writable = true;
    self.xhr = xhr;
    self.body = [];
    
    self.uri = (params.protocol || 'http:') + '//'
        + params.host
        + (params.port ? ':' + params.port : '')
        + (params.path || '/')
    ;
    
    if (typeof params.withCredentials === 'undefined') {
        params.withCredentials = true;
    }

    try { xhr.withCredentials = params.withCredentials }
    catch (e) {}
    
    if (params.responseType) try { xhr.responseType = params.responseType }
    catch (e) {}
    
    xhr.open(
        params.method || 'GET',
        self.uri,
        true
    );

    xhr.onerror = function(event) {
        self.emit('error', new Error('Network error'));
    };

    self._headers = {};
    
    if (params.headers) {
        var keys = objectKeys(params.headers);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!self.isSafeRequestHeader(key)) continue;
            var value = params.headers[key];
            self.setHeader(key, value);
        }
    }
    
    if (params.auth) {
        //basic auth
        this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));
    }

    var res = new Response;
    res.on('close', function () {
        self.emit('close');
    });
    
    res.on('ready', function () {
        self.emit('response', res);
    });

    res.on('error', function (err) {
        self.emit('error', err);
    });
    
    xhr.onreadystatechange = function () {
        // Fix for IE9 bug
        // SCRIPT575: Could not complete the operation due to error c00c023f
        // It happens when a request is aborted, calling the success callback anyway with readyState === 4
        if (xhr.__aborted) return;
        res.handle(xhr);
    };
};

inherits(Request, Stream);

Request.prototype.setHeader = function (key, value) {
    this._headers[key.toLowerCase()] = value
};

Request.prototype.getHeader = function (key) {
    return this._headers[key.toLowerCase()]
};

Request.prototype.removeHeader = function (key) {
    delete this._headers[key.toLowerCase()]
};

Request.prototype.write = function (s) {
    this.body.push(s);
};

Request.prototype.destroy = function (s) {
    this.xhr.__aborted = true;
    this.xhr.abort();
    this.emit('close');
};

Request.prototype.end = function (s) {
    if (s !== undefined) this.body.push(s);

    var keys = objectKeys(this._headers);
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = this._headers[key];
        if (isArray(value)) {
            for (var j = 0; j < value.length; j++) {
                this.xhr.setRequestHeader(key, value[j]);
            }
        }
        else this.xhr.setRequestHeader(key, value)
    }

    if (this.body.length === 0) {
        this.xhr.send('');
    }
    else if (typeof this.body[0] === 'string') {
        this.xhr.send(this.body.join(''));
    }
    else if (isArray(this.body[0])) {
        var body = [];
        for (var i = 0; i < this.body.length; i++) {
            body.push.apply(body, this.body[i]);
        }
        this.xhr.send(body);
    }
    else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {
        var len = 0;
        for (var i = 0; i < this.body.length; i++) {
            len += this.body[i].length;
        }
        var body = new(this.body[0].constructor)(len);
        var k = 0;
        
        for (var i = 0; i < this.body.length; i++) {
            var b = this.body[i];
            for (var j = 0; j < b.length; j++) {
                body[k++] = b[j];
            }
        }
        this.xhr.send(body);
    }
    else if (isXHR2Compatible(this.body[0])) {
        this.xhr.send(this.body[0]);
    }
    else {
        var body = '';
        for (var i = 0; i < this.body.length; i++) {
            body += this.body[i].toString();
        }
        this.xhr.send(body);
    }
};

// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
Request.unsafeHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "cookie2",
    "content-transfer-encoding",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "user-agent",
    "via"
];

Request.prototype.isSafeRequestHeader = function (headerName) {
    if (!headerName) return false;
    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
};

var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var indexOf = function (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (xs[i] === x) return i;
    }
    return -1;
};

var isXHR2Compatible = function (obj) {
    if (typeof Blob !== 'undefined' && obj instanceof Blob) return true;
    if (typeof ArrayBuffer !== 'undefined' && obj instanceof ArrayBuffer) return true;
    if (typeof FormData !== 'undefined' && obj instanceof FormData) return true;
};

},{"./response":121,"Base64":122,"inherits":123,"stream":141}],121:[function(require,module,exports){
var Stream = require('stream');
var util = require('util');

var Response = module.exports = function (res) {
    this.offset = 0;
    this.readable = true;
};

util.inherits(Response, Stream);

var capable = {
    streaming : true,
    status2 : true
};

function parseHeaders (res) {
    var lines = res.getAllResponseHeaders().split(/\r?\n/);
    var headers = {};
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (line === '') continue;
        
        var m = line.match(/^([^:]+):\s*(.*)/);
        if (m) {
            var key = m[1].toLowerCase(), value = m[2];
            
            if (headers[key] !== undefined) {
            
                if (isArray(headers[key])) {
                    headers[key].push(value);
                }
                else {
                    headers[key] = [ headers[key], value ];
                }
            }
            else {
                headers[key] = value;
            }
        }
        else {
            headers[line] = true;
        }
    }
    return headers;
}

Response.prototype.getResponse = function (xhr) {
    var respType = String(xhr.responseType).toLowerCase();
    if (respType === 'blob') return xhr.responseBlob || xhr.response;
    if (respType === 'arraybuffer') return xhr.response;
    return xhr.responseText;
}

Response.prototype.getHeader = function (key) {
    return this.headers[key.toLowerCase()];
};

Response.prototype.handle = function (res) {
    if (res.readyState === 2 && capable.status2) {
        try {
            this.statusCode = res.status;
            this.headers = parseHeaders(res);
        }
        catch (err) {
            capable.status2 = false;
        }
        
        if (capable.status2) {
            this.emit('ready');
        }
    }
    else if (capable.streaming && res.readyState === 3) {
        try {
            if (!this.statusCode) {
                this.statusCode = res.status;
                this.headers = parseHeaders(res);
                this.emit('ready');
            }
        }
        catch (err) {}
        
        try {
            this._emitData(res);
        }
        catch (err) {
            capable.streaming = false;
        }
    }
    else if (res.readyState === 4) {
        if (!this.statusCode) {
            this.statusCode = res.status;
            this.emit('ready');
        }
        this._emitData(res);
        
        if (res.error) {
            this.emit('error', this.getResponse(res));
        }
        else this.emit('end');
        
        this.emit('close');
    }
};

Response.prototype._emitData = function (res) {
    var respBody = this.getResponse(res);
    if (respBody.toString().match(/ArrayBuffer/)) {
        this.emit('data', new Uint8Array(respBody, this.offset));
        this.offset = respBody.byteLength;
        return;
    }
    if (respBody.length > this.offset) {
        this.emit('data', respBody.slice(this.offset));
        this.offset = respBody.length;
    }
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

},{"stream":141,"util":145}],122:[function(require,module,exports){
;(function () {

  var object = typeof exports != 'undefined' ? exports : this; // #8: web workers
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  function InvalidCharacterError(message) {
    this.message = message;
  }
  InvalidCharacterError.prototype = new Error;
  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

  // encoder
  // [https://gist.github.com/999166] by [https://github.com/nignag]
  object.btoa || (
  object.btoa = function (input) {
    for (
      // initialize result and counter
      var block, charCode, idx = 0, map = chars, output = '';
      // if the next input index does not exist:
      //   change the mapping table to "="
      //   check if d has no fractional digits
      input.charAt(idx | 0) || (map = '=', idx % 1);
      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
    ) {
      charCode = input.charCodeAt(idx += 3/4);
      if (charCode > 0xFF) {
        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
      }
      block = block << 8 | charCode;
    }
    return output;
  });

  // decoder
  // [https://gist.github.com/1020396] by [https://github.com/atk]
  object.atob || (
  object.atob = function (input) {
    input = input.replace(/=+$/, '');
    if (input.length % 4 == 1) {
      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
    }
    for (
      // initialize result and counters
      var bc = 0, bs, buffer, idx = 0, output = '';
      // get next character
      buffer = input.charAt(idx++);
      // character found in table? initialize bit storage and add its ascii value;
      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
        // and if not first of each 4 characters,
        // convert the first 8 bits to one ascii character
        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
    ) {
      // try to find character in table (0-63, not found => -1)
      buffer = chars.indexOf(buffer);
    }
    return output;
  });

}());

},{}],123:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],124:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],125:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],126:[function(require,module,exports){
(function (global){
/*! http://mths.be/punycode v1.2.4 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports;
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		while (length--) {
			array[length] = fn(array[length]);
		}
		return array;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings.
	 * @private
	 * @param {String} domain The domain name.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		return map(string.split(regexSeparators), fn).join('.');
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <http://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols to a Punycode string of ASCII-only
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name to Unicode. Only the
	 * Punycoded parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it on a string that has already been converted to
	 * Unicode.
	 * @memberOf punycode
	 * @param {String} domain The Punycode domain name to convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(domain) {
		return mapDomain(domain, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name to Punycode. Only the
	 * non-ASCII parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it with a domain that's already in ASCII.
	 * @memberOf punycode
	 * @param {String} domain The domain name to convert, as a Unicode string.
	 * @returns {String} The Punycode representation of the given domain name.
	 */
	function toASCII(domain) {
		return mapDomain(domain, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.2.4',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <http://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],127:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],128:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],129:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":127,"./encode":128}],130:[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":131}],131:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this,require('_process'))

},{"./_stream_readable":133,"./_stream_writable":135,"_process":125,"core-util-is":136,"inherits":123}],132:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":134,"core-util-is":136,"inherits":123}],133:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = require('stream');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = false;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // In streams that never have any data, and do push(null) right away,
  // the consumer can miss the 'end' event if they do some I/O before
  // consuming the stream.  So, we don't emit('end') until some reading
  // happens.
  this.calledRead = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (typeof chunk === 'string' && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null || chunk === undefined) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) {
        state.buffer.unshift(chunk);
      } else {
        state.reading = false;
        state.buffer.push(chunk);
      }

      if (state.needReadable)
        emitReadable(stream);

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  var state = this._readableState;
  state.calledRead = true;
  var nOrig = n;
  var ret;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    ret = null;

    // In cases where the decoder did not receive enough data
    // to produce a full chunk, then immediately received an
    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
    // howMuchToRead will see this and coerce the amount to
    // read to zero (because it's looking at the length of the
    // first <Buffer > in state.buffer), and we'll end up here.
    //
    // This can only happen via state.decoder -- no other venue
    // exists for pushing a zero-length chunk into state.buffer
    // and triggering this behavior. In this case, we return our
    // remaining data and end the stream, if appropriate.
    if (state.length > 0 && state.decoder) {
      ret = fromList(n, state);
      state.length -= ret.length;
    }

    if (state.length === 0)
      endReadable(this);

    return ret;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;

  // if we currently have less than the highWaterMark, then also read some
  if (state.length - n <= state.highWaterMark)
    doRead = true;

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading)
    doRead = false;

  if (doRead) {
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read called its callback synchronously, then `reading`
  // will be false, and we need to re-evaluate how much data we
  // can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we happened to read() exactly the remaining amount in the
  // buffer, and the EOF has been seen at this point, then make sure
  // that we emit 'end' on the very next tick.
  if (state.ended && !state.endEmitted && state.length === 0)
    endReadable(this);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // if we've ended and we have some data left, then emit
  // 'readable' now to make sure it gets picked up.
  if (state.length > 0)
    emitReadable(stream);
  else
    endReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (state.emittedReadable)
    return;

  state.emittedReadable = true;
  if (state.sync)
    process.nextTick(function() {
      emitReadable_(stream);
    });
  else
    emitReadable_(stream);
}

function emitReadable_(stream) {
  stream.emit('readable');
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    if (readable !== src) return;
    cleanup();
  }

  function onend() {
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (!dest._writableState || dest._writableState.needDrain)
      ondrain();
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    // the handler that waits for readable events after all
    // the data gets sucked out in flow.
    // This would be easier to follow with a .once() handler
    // in flow(), but that is too slow.
    this.on('readable', pipeOnReadable);

    state.flowing = true;
    process.nextTick(function() {
      flow(src);
    });
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var dest = this;
    var state = src._readableState;
    state.awaitDrain--;
    if (state.awaitDrain === 0)
      flow(src);
  };
}

function flow(src) {
  var state = src._readableState;
  var chunk;
  state.awaitDrain = 0;

  function write(dest, i, list) {
    var written = dest.write(chunk);
    if (false === written) {
      state.awaitDrain++;
    }
  }

  while (state.pipesCount && null !== (chunk = src.read())) {

    if (state.pipesCount === 1)
      write(state.pipes, 0, null);
    else
      forEach(state.pipes, write);

    src.emit('data', chunk);

    // if anyone needs a drain, then we have to wait for that.
    if (state.awaitDrain > 0)
      return;
  }

  // if every destination was unpiped, either before entering this
  // function, or in the while loop, then stop flowing.
  //
  // NB: This is a pretty rare edge case.
  if (state.pipesCount === 0) {
    state.flowing = false;

    // if there were data event listeners added, then switch to old mode.
    if (EE.listenerCount(src, 'data') > 0)
      emitDataEvents(src);
    return;
  }

  // at this point, no one needed a drain, so we just ran out of data
  // on the next readable event, start it over again.
  state.ranOut = true;
}

function pipeOnReadable() {
  if (this._readableState.ranOut) {
    this._readableState.ranOut = false;
    flow(this);
  }
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data' && !this._readableState.flowing)
    emitDataEvents(this);

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        this.read(0);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  emitDataEvents(this);
  this.read(0);
  this.emit('resume');
};

Readable.prototype.pause = function() {
  emitDataEvents(this, true);
  this.emit('pause');
};

function emitDataEvents(stream, startPaused) {
  var state = stream._readableState;

  if (state.flowing) {
    // https://github.com/isaacs/readable-stream/issues/16
    throw new Error('Cannot switch to old mode now.');
  }

  var paused = startPaused || false;
  var readable = false;

  // convert to an old-style stream.
  stream.readable = true;
  stream.pipe = Stream.prototype.pipe;
  stream.on = stream.addListener = Stream.prototype.on;

  stream.on('readable', function() {
    readable = true;

    var c;
    while (!paused && (null !== (c = stream.read())))
      stream.emit('data', c);

    if (c === null) {
      readable = false;
      stream._readableState.needReadable = true;
    }
  });

  stream.pause = function() {
    paused = true;
    this.emit('pause');
  };

  stream.resume = function() {
    paused = false;
    if (readable)
      process.nextTick(function() {
        stream.emit('readable');
      });
    else
      this.read(0);
    this.emit('resume');
  };

  // now make it start, just in case it hadn't already.
  stream.emit('readable');
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    if (state.decoder)
      chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    //if (state.objectMode && util.isNullOrUndefined(chunk))
    if (state.objectMode && (chunk === null || chunk === undefined))
      return;
    else if (!state.objectMode && (!chunk || !chunk.length))
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (typeof stream[i] === 'function' &&
        typeof this[i] === 'undefined') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted && state.calledRead) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'))

},{"_process":125,"buffer":114,"core-util-is":136,"events":118,"inherits":123,"isarray":124,"stream":141,"string_decoder/":142}],134:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var rs = stream._readableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":131,"core-util-is":136,"inherits":123}],135:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      cb(er);
    });
  else
    cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.bufferProcessing && state.buffer.length)
      clearBuffer(stream, state);

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  cb();
  if (finished)
    finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  for (var c = 0; c < state.buffer.length; c++) {
    var entry = state.buffer[c];
    var chunk = entry.chunk;
    var encoding = entry.encoding;
    var cb = entry.callback;
    var len = state.objectMode ? 1 : chunk.length;

    doWrite(stream, state, len, chunk, encoding, cb);

    // if we didn't call the onwrite immediately, then
    // it means that we need to wait until it does.
    // also, that means that the chunk and cb are currently
    // being processed, so move the buffer counter past them.
    if (state.writing) {
      c++;
      break;
    }
  }

  state.bufferProcessing = false;
  if (c < state.buffer.length)
    state.buffer = state.buffer.slice(c);
  else
    state.buffer.length = 0;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    state.finished = true;
    stream.emit('finish');
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this,require('_process'))

},{"./_stream_duplex":131,"_process":125,"buffer":114,"core-util-is":136,"inherits":123,"stream":141}],136:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return Buffer.isBuffer(arg);
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
}).call(this,require("buffer").Buffer)

},{"buffer":114}],137:[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":132}],138:[function(require,module,exports){
var Stream = require('stream'); // hack to fix a circular dependency issue when used with browserify
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = Stream;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":131,"./lib/_stream_passthrough.js":132,"./lib/_stream_readable.js":133,"./lib/_stream_transform.js":134,"./lib/_stream_writable.js":135,"stream":141}],139:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":134}],140:[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":135}],141:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":118,"inherits":123,"readable-stream/duplex.js":130,"readable-stream/passthrough.js":137,"readable-stream/readable.js":138,"readable-stream/transform.js":139,"readable-stream/writable.js":140}],142:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":114}],143:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":126,"querystring":129}],144:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],145:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":144,"_process":125,"inherits":123}],146:[function(require,module,exports){
"use strict";
/*globals Handlebars: true */
var Handlebars = require("./handlebars.runtime")["default"];

// Compiler imports
var AST = require("./handlebars/compiler/ast")["default"];
var Parser = require("./handlebars/compiler/base").parser;
var parse = require("./handlebars/compiler/base").parse;
var Compiler = require("./handlebars/compiler/compiler").Compiler;
var compile = require("./handlebars/compiler/compiler").compile;
var precompile = require("./handlebars/compiler/compiler").precompile;
var JavaScriptCompiler = require("./handlebars/compiler/javascript-compiler")["default"];

var _create = Handlebars.create;
var create = function() {
  var hb = _create();

  hb.compile = function(input, options) {
    return compile(input, options, hb);
  };
  hb.precompile = function (input, options) {
    return precompile(input, options, hb);
  };

  hb.AST = AST;
  hb.Compiler = Compiler;
  hb.JavaScriptCompiler = JavaScriptCompiler;
  hb.Parser = Parser;
  hb.parse = parse;

  return hb;
};

Handlebars = create();
Handlebars.create = create;

exports["default"] = Handlebars;
},{"./handlebars.runtime":147,"./handlebars/compiler/ast":149,"./handlebars/compiler/base":150,"./handlebars/compiler/compiler":151,"./handlebars/compiler/javascript-compiler":152}],147:[function(require,module,exports){
"use strict";
/*globals Handlebars: true */
var base = require("./handlebars/base");

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)
var SafeString = require("./handlebars/safe-string")["default"];
var Exception = require("./handlebars/exception")["default"];
var Utils = require("./handlebars/utils");
var runtime = require("./handlebars/runtime");

// For compatibility and usage outside of module systems, make the Handlebars object a namespace
var create = function() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = SafeString;
  hb.Exception = Exception;
  hb.Utils = Utils;

  hb.VM = runtime;
  hb.template = function(spec) {
    return runtime.template(spec, hb);
  };

  return hb;
};

var Handlebars = create();
Handlebars.create = create;

exports["default"] = Handlebars;
},{"./handlebars/base":148,"./handlebars/exception":156,"./handlebars/runtime":157,"./handlebars/safe-string":158,"./handlebars/utils":159}],148:[function(require,module,exports){
"use strict";
var Utils = require("./utils");
var Exception = require("./exception")["default"];

var VERSION = "1.3.0";
exports.VERSION = VERSION;var COMPILER_REVISION = 4;
exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '>= 1.0.0'
};
exports.REVISION_CHANGES = REVISION_CHANGES;
var isArray = Utils.isArray,
    isFunction = Utils.isFunction,
    toString = Utils.toString,
    objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials) {
  this.helpers = helpers || {};
  this.partials = partials || {};

  registerDefaultHelpers(this);
}

exports.HandlebarsEnvironment = HandlebarsEnvironment;HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: logger,
  log: log,

  registerHelper: function(name, fn, inverse) {
    if (toString.call(name) === objectType) {
      if (inverse || fn) { throw new Exception('Arg not supported with multiple helpers'); }
      Utils.extend(this.helpers, name);
    } else {
      if (inverse) { fn.not = inverse; }
      this.helpers[name] = fn;
    }
  },

  registerPartial: function(name, str) {
    if (toString.call(name) === objectType) {
      Utils.extend(this.partials,  name);
    } else {
      this.partials[name] = str;
    }
  }
};

function registerDefaultHelpers(instance) {
  instance.registerHelper('helperMissing', function(arg) {
    if(arguments.length === 2) {
      return undefined;
    } else {
      throw new Exception("Missing helper: '" + arg + "'");
    }
  });

  instance.registerHelper('blockHelperMissing', function(context, options) {
    var inverse = options.inverse || function() {}, fn = options.fn;

    if (isFunction(context)) { context = context.call(this); }

    if(context === true) {
      return fn(this);
    } else if(context === false || context == null) {
      return inverse(this);
    } else if (isArray(context)) {
      if(context.length > 0) {
        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      return fn(context);
    }
  });

  instance.registerHelper('each', function(context, options) {
    var fn = options.fn, inverse = options.inverse;
    var i = 0, ret = "", data;

    if (isFunction(context)) { context = context.call(this); }

    if (options.data) {
      data = createFrame(options.data);
    }

    if(context && typeof context === 'object') {
      if (isArray(context)) {
        for(var j = context.length; i<j; i++) {
          if (data) {
            data.index = i;
            data.first = (i === 0);
            data.last  = (i === (context.length-1));
          }
          ret = ret + fn(context[i], { data: data });
        }
      } else {
        for(var key in context) {
          if(context.hasOwnProperty(key)) {
            if(data) { 
              data.key = key; 
              data.index = i;
              data.first = (i === 0);
            }
            ret = ret + fn(context[key], {data: data});
            i++;
          }
        }
      }
    }

    if(i === 0){
      ret = inverse(this);
    }

    return ret;
  });

  instance.registerHelper('if', function(conditional, options) {
    if (isFunction(conditional)) { conditional = conditional.call(this); }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if ((!options.hash.includeZero && !conditional) || Utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function(conditional, options) {
    return instance.helpers['if'].call(this, conditional, {fn: options.inverse, inverse: options.fn, hash: options.hash});
  });

  instance.registerHelper('with', function(context, options) {
    if (isFunction(context)) { context = context.call(this); }

    if (!Utils.isEmpty(context)) return options.fn(context);
  });

  instance.registerHelper('log', function(context, options) {
    var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
    instance.log(level, context);
  });
}

var logger = {
  methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },

  // State enum
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3,
  level: 3,

  // can be overridden in the host environment
  log: function(level, obj) {
    if (logger.level <= level) {
      var method = logger.methodMap[level];
      if (typeof console !== 'undefined' && console[method]) {
        console[method].call(console, obj);
      }
    }
  }
};
exports.logger = logger;
function log(level, obj) { logger.log(level, obj); }

exports.log = log;var createFrame = function(object) {
  var obj = {};
  Utils.extend(obj, object);
  return obj;
};
exports.createFrame = createFrame;
},{"./exception":156,"./utils":159}],149:[function(require,module,exports){
"use strict";
var Exception = require("../exception")["default"];

function LocationInfo(locInfo){
  locInfo = locInfo || {};
  this.firstLine   = locInfo.first_line;
  this.firstColumn = locInfo.first_column;
  this.lastColumn  = locInfo.last_column;
  this.lastLine    = locInfo.last_line;
}

var AST = {
  ProgramNode: function(statements, inverseStrip, inverse, locInfo) {
    var inverseLocationInfo, firstInverseNode;
    if (arguments.length === 3) {
      locInfo = inverse;
      inverse = null;
    } else if (arguments.length === 2) {
      locInfo = inverseStrip;
      inverseStrip = null;
    }

    LocationInfo.call(this, locInfo);
    this.type = "program";
    this.statements = statements;
    this.strip = {};

    if(inverse) {
      firstInverseNode = inverse[0];
      if (firstInverseNode) {
        inverseLocationInfo = {
          first_line: firstInverseNode.firstLine,
          last_line: firstInverseNode.lastLine,
          last_column: firstInverseNode.lastColumn,
          first_column: firstInverseNode.firstColumn
        };
        this.inverse = new AST.ProgramNode(inverse, inverseStrip, inverseLocationInfo);
      } else {
        this.inverse = new AST.ProgramNode(inverse, inverseStrip);
      }
      this.strip.right = inverseStrip.left;
    } else if (inverseStrip) {
      this.strip.left = inverseStrip.right;
    }
  },

  MustacheNode: function(rawParams, hash, open, strip, locInfo) {
    LocationInfo.call(this, locInfo);
    this.type = "mustache";
    this.strip = strip;

    // Open may be a string parsed from the parser or a passed boolean flag
    if (open != null && open.charAt) {
      // Must use charAt to support IE pre-10
      var escapeFlag = open.charAt(3) || open.charAt(2);
      this.escaped = escapeFlag !== '{' && escapeFlag !== '&';
    } else {
      this.escaped = !!open;
    }

    if (rawParams instanceof AST.SexprNode) {
      this.sexpr = rawParams;
    } else {
      // Support old AST API
      this.sexpr = new AST.SexprNode(rawParams, hash);
    }

    this.sexpr.isRoot = true;

    // Support old AST API that stored this info in MustacheNode
    this.id = this.sexpr.id;
    this.params = this.sexpr.params;
    this.hash = this.sexpr.hash;
    this.eligibleHelper = this.sexpr.eligibleHelper;
    this.isHelper = this.sexpr.isHelper;
  },

  SexprNode: function(rawParams, hash, locInfo) {
    LocationInfo.call(this, locInfo);

    this.type = "sexpr";
    this.hash = hash;

    var id = this.id = rawParams[0];
    var params = this.params = rawParams.slice(1);

    // a mustache is an eligible helper if:
    // * its id is simple (a single part, not `this` or `..`)
    var eligibleHelper = this.eligibleHelper = id.isSimple;

    // a mustache is definitely a helper if:
    // * it is an eligible helper, and
    // * it has at least one parameter or hash segment
    this.isHelper = eligibleHelper && (params.length || hash);

    // if a mustache is an eligible helper but not a definite
    // helper, it is ambiguous, and will be resolved in a later
    // pass or at runtime.
  },

  PartialNode: function(partialName, context, strip, locInfo) {
    LocationInfo.call(this, locInfo);
    this.type         = "partial";
    this.partialName  = partialName;
    this.context      = context;
    this.strip = strip;
  },

  BlockNode: function(mustache, program, inverse, close, locInfo) {
    LocationInfo.call(this, locInfo);

    if(mustache.sexpr.id.original !== close.path.original) {
      throw new Exception(mustache.sexpr.id.original + " doesn't match " + close.path.original, this);
    }

    this.type = 'block';
    this.mustache = mustache;
    this.program  = program;
    this.inverse  = inverse;

    this.strip = {
      left: mustache.strip.left,
      right: close.strip.right
    };

    (program || inverse).strip.left = mustache.strip.right;
    (inverse || program).strip.right = close.strip.left;

    if (inverse && !program) {
      this.isInverse = true;
    }
  },

  ContentNode: function(string, locInfo) {
    LocationInfo.call(this, locInfo);
    this.type = "content";
    this.string = string;
  },

  HashNode: function(pairs, locInfo) {
    LocationInfo.call(this, locInfo);
    this.type = "hash";
    this.pairs = pairs;
  },

  IdNode: function(parts, locInfo) {
    LocationInfo.call(this, locInfo);
    this.type = "ID";

    var original = "",
        dig = [],
        depth = 0;

    for(var i=0,l=parts.length; i<l; i++) {
      var part = parts[i].part;
      original += (parts[i].separator || '') + part;

      if (part === ".." || part === "." || part === "this") {
        if (dig.length > 0) {
          throw new Exception("Invalid path: " + original, this);
        } else if (part === "..") {
          depth++;
        } else {
          this.isScoped = true;
        }
      } else {
        dig.push(part);
      }
    }

    this.original = original;
    this.parts    = dig;
    this.string   = dig.join('.');
    this.depth    = depth;

    // an ID is simple if it only has one part, and that part is not
    // `..` or `this`.
    this.isSimple = parts.length === 1 && !this.isScoped && depth === 0;

    this.stringModeValue = this.string;
  },

  PartialNameNode: function(name, locInfo) {
    LocationInfo.call(this, locInfo);
    this.type = "PARTIAL_NAME";
    this.name = name.original;
  },

  DataNode: function(id, locInfo) {
    LocationInfo.call(this, locInfo);
    this.type = "DATA";
    this.id = id;
  },

  StringNode: function(string, locInfo) {
    LocationInfo.call(this, locInfo);
    this.type = "STRING";
    this.original =
      this.string =
      this.stringModeValue = string;
  },

  IntegerNode: function(integer, locInfo) {
    LocationInfo.call(this, locInfo);
    this.type = "INTEGER";
    this.original =
      this.integer = integer;
    this.stringModeValue = Number(integer);
  },

  BooleanNode: function(bool, locInfo) {
    LocationInfo.call(this, locInfo);
    this.type = "BOOLEAN";
    this.bool = bool;
    this.stringModeValue = bool === "true";
  },

  CommentNode: function(comment, locInfo) {
    LocationInfo.call(this, locInfo);
    this.type = "comment";
    this.comment = comment;
  }
};

// Must be exported as an object rather than the root of the module as the jison lexer
// most modify the object to operate properly.
exports["default"] = AST;
},{"../exception":156}],150:[function(require,module,exports){
"use strict";
var parser = require("./parser")["default"];
var AST = require("./ast")["default"];

exports.parser = parser;

function parse(input) {
  // Just return if an already-compile AST was passed in.
  if(input.constructor === AST.ProgramNode) { return input; }

  parser.yy = AST;
  return parser.parse(input);
}

exports.parse = parse;
},{"./ast":149,"./parser":153}],151:[function(require,module,exports){
"use strict";
var Exception = require("../exception")["default"];

function Compiler() {}

exports.Compiler = Compiler;// the foundHelper register will disambiguate helper lookup from finding a
// function in a context. This is necessary for mustache compatibility, which
// requires that context functions in blocks are evaluated by blockHelperMissing,
// and then proceed as if the resulting value was provided to blockHelperMissing.

Compiler.prototype = {
  compiler: Compiler,

  disassemble: function() {
    var opcodes = this.opcodes, opcode, out = [], params, param;

    for (var i=0, l=opcodes.length; i<l; i++) {
      opcode = opcodes[i];

      if (opcode.opcode === 'DECLARE') {
        out.push("DECLARE " + opcode.name + "=" + opcode.value);
      } else {
        params = [];
        for (var j=0; j<opcode.args.length; j++) {
          param = opcode.args[j];
          if (typeof param === "string") {
            param = "\"" + param.replace("\n", "\\n") + "\"";
          }
          params.push(param);
        }
        out.push(opcode.opcode + " " + params.join(" "));
      }
    }

    return out.join("\n");
  },

  equals: function(other) {
    var len = this.opcodes.length;
    if (other.opcodes.length !== len) {
      return false;
    }

    for (var i = 0; i < len; i++) {
      var opcode = this.opcodes[i],
          otherOpcode = other.opcodes[i];
      if (opcode.opcode !== otherOpcode.opcode || opcode.args.length !== otherOpcode.args.length) {
        return false;
      }
      for (var j = 0; j < opcode.args.length; j++) {
        if (opcode.args[j] !== otherOpcode.args[j]) {
          return false;
        }
      }
    }

    len = this.children.length;
    if (other.children.length !== len) {
      return false;
    }
    for (i = 0; i < len; i++) {
      if (!this.children[i].equals(other.children[i])) {
        return false;
      }
    }

    return true;
  },

  guid: 0,

  compile: function(program, options) {
    this.opcodes = [];
    this.children = [];
    this.depths = {list: []};
    this.options = options;

    // These changes will propagate to the other compiler components
    var knownHelpers = this.options.knownHelpers;
    this.options.knownHelpers = {
      'helperMissing': true,
      'blockHelperMissing': true,
      'each': true,
      'if': true,
      'unless': true,
      'with': true,
      'log': true
    };
    if (knownHelpers) {
      for (var name in knownHelpers) {
        this.options.knownHelpers[name] = knownHelpers[name];
      }
    }

    return this.accept(program);
  },

  accept: function(node) {
    var strip = node.strip || {},
        ret;
    if (strip.left) {
      this.opcode('strip');
    }

    ret = this[node.type](node);

    if (strip.right) {
      this.opcode('strip');
    }

    return ret;
  },

  program: function(program) {
    var statements = program.statements;

    for(var i=0, l=statements.length; i<l; i++) {
      this.accept(statements[i]);
    }
    this.isSimple = l === 1;

    this.depths.list = this.depths.list.sort(function(a, b) {
      return a - b;
    });

    return this;
  },

  compileProgram: function(program) {
    var result = new this.compiler().compile(program, this.options);
    var guid = this.guid++, depth;

    this.usePartial = this.usePartial || result.usePartial;

    this.children[guid] = result;

    for(var i=0, l=result.depths.list.length; i<l; i++) {
      depth = result.depths.list[i];

      if(depth < 2) { continue; }
      else { this.addDepth(depth - 1); }
    }

    return guid;
  },

  block: function(block) {
    var mustache = block.mustache,
        program = block.program,
        inverse = block.inverse;

    if (program) {
      program = this.compileProgram(program);
    }

    if (inverse) {
      inverse = this.compileProgram(inverse);
    }

    var sexpr = mustache.sexpr;
    var type = this.classifySexpr(sexpr);

    if (type === "helper") {
      this.helperSexpr(sexpr, program, inverse);
    } else if (type === "simple") {
      this.simpleSexpr(sexpr);

      // now that the simple mustache is resolved, we need to
      // evaluate it by executing `blockHelperMissing`
      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);
      this.opcode('emptyHash');
      this.opcode('blockValue');
    } else {
      this.ambiguousSexpr(sexpr, program, inverse);

      // now that the simple mustache is resolved, we need to
      // evaluate it by executing `blockHelperMissing`
      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);
      this.opcode('emptyHash');
      this.opcode('ambiguousBlockValue');
    }

    this.opcode('append');
  },

  hash: function(hash) {
    var pairs = hash.pairs, pair, val;

    this.opcode('pushHash');

    for(var i=0, l=pairs.length; i<l; i++) {
      pair = pairs[i];
      val  = pair[1];

      if (this.options.stringParams) {
        if(val.depth) {
          this.addDepth(val.depth);
        }
        this.opcode('getContext', val.depth || 0);
        this.opcode('pushStringParam', val.stringModeValue, val.type);

        if (val.type === 'sexpr') {
          // Subexpressions get evaluated and passed in
          // in string params mode.
          this.sexpr(val);
        }
      } else {
        this.accept(val);
      }

      this.opcode('assignToHash', pair[0]);
    }
    this.opcode('popHash');
  },

  partial: function(partial) {
    var partialName = partial.partialName;
    this.usePartial = true;

    if(partial.context) {
      this.ID(partial.context);
    } else {
      this.opcode('push', 'depth0');
    }

    this.opcode('invokePartial', partialName.name);
    this.opcode('append');
  },

  content: function(content) {
    this.opcode('appendContent', content.string);
  },

  mustache: function(mustache) {
    this.sexpr(mustache.sexpr);

    if(mustache.escaped && !this.options.noEscape) {
      this.opcode('appendEscaped');
    } else {
      this.opcode('append');
    }
  },

  ambiguousSexpr: function(sexpr, program, inverse) {
    var id = sexpr.id,
        name = id.parts[0],
        isBlock = program != null || inverse != null;

    this.opcode('getContext', id.depth);

    this.opcode('pushProgram', program);
    this.opcode('pushProgram', inverse);

    this.opcode('invokeAmbiguous', name, isBlock);
  },

  simpleSexpr: function(sexpr) {
    var id = sexpr.id;

    if (id.type === 'DATA') {
      this.DATA(id);
    } else if (id.parts.length) {
      this.ID(id);
    } else {
      // Simplified ID for `this`
      this.addDepth(id.depth);
      this.opcode('getContext', id.depth);
      this.opcode('pushContext');
    }

    this.opcode('resolvePossibleLambda');
  },

  helperSexpr: function(sexpr, program, inverse) {
    var params = this.setupFullMustacheParams(sexpr, program, inverse),
        name = sexpr.id.parts[0];

    if (this.options.knownHelpers[name]) {
      this.opcode('invokeKnownHelper', params.length, name);
    } else if (this.options.knownHelpersOnly) {
      throw new Exception("You specified knownHelpersOnly, but used the unknown helper " + name, sexpr);
    } else {
      this.opcode('invokeHelper', params.length, name, sexpr.isRoot);
    }
  },

  sexpr: function(sexpr) {
    var type = this.classifySexpr(sexpr);

    if (type === "simple") {
      this.simpleSexpr(sexpr);
    } else if (type === "helper") {
      this.helperSexpr(sexpr);
    } else {
      this.ambiguousSexpr(sexpr);
    }
  },

  ID: function(id) {
    this.addDepth(id.depth);
    this.opcode('getContext', id.depth);

    var name = id.parts[0];
    if (!name) {
      this.opcode('pushContext');
    } else {
      this.opcode('lookupOnContext', id.parts[0]);
    }

    for(var i=1, l=id.parts.length; i<l; i++) {
      this.opcode('lookup', id.parts[i]);
    }
  },

  DATA: function(data) {
    this.options.data = true;
    if (data.id.isScoped || data.id.depth) {
      throw new Exception('Scoped data references are not supported: ' + data.original, data);
    }

    this.opcode('lookupData');
    var parts = data.id.parts;
    for(var i=0, l=parts.length; i<l; i++) {
      this.opcode('lookup', parts[i]);
    }
  },

  STRING: function(string) {
    this.opcode('pushString', string.string);
  },

  INTEGER: function(integer) {
    this.opcode('pushLiteral', integer.integer);
  },

  BOOLEAN: function(bool) {
    this.opcode('pushLiteral', bool.bool);
  },

  comment: function() {},

  // HELPERS
  opcode: function(name) {
    this.opcodes.push({ opcode: name, args: [].slice.call(arguments, 1) });
  },

  declare: function(name, value) {
    this.opcodes.push({ opcode: 'DECLARE', name: name, value: value });
  },

  addDepth: function(depth) {
    if(depth === 0) { return; }

    if(!this.depths[depth]) {
      this.depths[depth] = true;
      this.depths.list.push(depth);
    }
  },

  classifySexpr: function(sexpr) {
    var isHelper   = sexpr.isHelper;
    var isEligible = sexpr.eligibleHelper;
    var options    = this.options;

    // if ambiguous, we can possibly resolve the ambiguity now
    if (isEligible && !isHelper) {
      var name = sexpr.id.parts[0];

      if (options.knownHelpers[name]) {
        isHelper = true;
      } else if (options.knownHelpersOnly) {
        isEligible = false;
      }
    }

    if (isHelper) { return "helper"; }
    else if (isEligible) { return "ambiguous"; }
    else { return "simple"; }
  },

  pushParams: function(params) {
    var i = params.length, param;

    while(i--) {
      param = params[i];

      if(this.options.stringParams) {
        if(param.depth) {
          this.addDepth(param.depth);
        }

        this.opcode('getContext', param.depth || 0);
        this.opcode('pushStringParam', param.stringModeValue, param.type);

        if (param.type === 'sexpr') {
          // Subexpressions get evaluated and passed in
          // in string params mode.
          this.sexpr(param);
        }
      } else {
        this[param.type](param);
      }
    }
  },

  setupFullMustacheParams: function(sexpr, program, inverse) {
    var params = sexpr.params;
    this.pushParams(params);

    this.opcode('pushProgram', program);
    this.opcode('pushProgram', inverse);

    if (sexpr.hash) {
      this.hash(sexpr.hash);
    } else {
      this.opcode('emptyHash');
    }

    return params;
  }
};

function precompile(input, options, env) {
  if (input == null || (typeof input !== 'string' && input.constructor !== env.AST.ProgramNode)) {
    throw new Exception("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + input);
  }

  options = options || {};
  if (!('data' in options)) {
    options.data = true;
  }

  var ast = env.parse(input);
  var environment = new env.Compiler().compile(ast, options);
  return new env.JavaScriptCompiler().compile(environment, options);
}

exports.precompile = precompile;function compile(input, options, env) {
  if (input == null || (typeof input !== 'string' && input.constructor !== env.AST.ProgramNode)) {
    throw new Exception("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input);
  }

  options = options || {};

  if (!('data' in options)) {
    options.data = true;
  }

  var compiled;

  function compileInput() {
    var ast = env.parse(input);
    var environment = new env.Compiler().compile(ast, options);
    var templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
    return env.template(templateSpec);
  }

  // Template is only compiled on first use and cached after that point.
  return function(context, options) {
    if (!compiled) {
      compiled = compileInput();
    }
    return compiled.call(this, context, options);
  };
}

exports.compile = compile;
},{"../exception":156}],152:[function(require,module,exports){
"use strict";
var COMPILER_REVISION = require("../base").COMPILER_REVISION;
var REVISION_CHANGES = require("../base").REVISION_CHANGES;
var log = require("../base").log;
var Exception = require("../exception")["default"];

function Literal(value) {
  this.value = value;
}

function JavaScriptCompiler() {}

JavaScriptCompiler.prototype = {
  // PUBLIC API: You can override these methods in a subclass to provide
  // alternative compiled forms for name lookup and buffering semantics
  nameLookup: function(parent, name /* , type*/) {
    var wrap,
        ret;
    if (parent.indexOf('depth') === 0) {
      wrap = true;
    }

    if (/^[0-9]+$/.test(name)) {
      ret = parent + "[" + name + "]";
    } else if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
      ret = parent + "." + name;
    }
    else {
      ret = parent + "['" + name + "']";
    }

    if (wrap) {
      return '(' + parent + ' && ' + ret + ')';
    } else {
      return ret;
    }
  },

  compilerInfo: function() {
    var revision = COMPILER_REVISION,
        versions = REVISION_CHANGES[revision];
    return "this.compilerInfo = ["+revision+",'"+versions+"'];\n";
  },

  appendToBuffer: function(string) {
    if (this.environment.isSimple) {
      return "return " + string + ";";
    } else {
      return {
        appendToBuffer: true,
        content: string,
        toString: function() { return "buffer += " + string + ";"; }
      };
    }
  },

  initializeBuffer: function() {
    return this.quotedString("");
  },

  namespace: "Handlebars",
  // END PUBLIC API

  compile: function(environment, options, context, asObject) {
    this.environment = environment;
    this.options = options || {};

    log('debug', this.environment.disassemble() + "\n\n");

    this.name = this.environment.name;
    this.isChild = !!context;
    this.context = context || {
      programs: [],
      environments: [],
      aliases: { }
    };

    this.preamble();

    this.stackSlot = 0;
    this.stackVars = [];
    this.registers = { list: [] };
    this.hashes = [];
    this.compileStack = [];
    this.inlineStack = [];

    this.compileChildren(environment, options);

    var opcodes = environment.opcodes, opcode;

    this.i = 0;

    for(var l=opcodes.length; this.i<l; this.i++) {
      opcode = opcodes[this.i];

      if(opcode.opcode === 'DECLARE') {
        this[opcode.name] = opcode.value;
      } else {
        this[opcode.opcode].apply(this, opcode.args);
      }

      // Reset the stripNext flag if it was not set by this operation.
      if (opcode.opcode !== this.stripNext) {
        this.stripNext = false;
      }
    }

    // Flush any trailing content that might be pending.
    this.pushSource('');

    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
      throw new Exception('Compile completed with content left on stack');
    }

    return this.createFunctionContext(asObject);
  },

  preamble: function() {
    var out = [];

    if (!this.isChild) {
      var namespace = this.namespace;

      var copies = "helpers = this.merge(helpers, " + namespace + ".helpers);";
      if (this.environment.usePartial) { copies = copies + " partials = this.merge(partials, " + namespace + ".partials);"; }
      if (this.options.data) { copies = copies + " data = data || {};"; }
      out.push(copies);
    } else {
      out.push('');
    }

    if (!this.environment.isSimple) {
      out.push(", buffer = " + this.initializeBuffer());
    } else {
      out.push("");
    }

    // track the last context pushed into place to allow skipping the
    // getContext opcode when it would be a noop
    this.lastContext = 0;
    this.source = out;
  },

  createFunctionContext: function(asObject) {
    var locals = this.stackVars.concat(this.registers.list);

    if(locals.length > 0) {
      this.source[1] = this.source[1] + ", " + locals.join(", ");
    }

    // Generate minimizer alias mappings
    if (!this.isChild) {
      for (var alias in this.context.aliases) {
        if (this.context.aliases.hasOwnProperty(alias)) {
          this.source[1] = this.source[1] + ', ' + alias + '=' + this.context.aliases[alias];
        }
      }
    }

    if (this.source[1]) {
      this.source[1] = "var " + this.source[1].substring(2) + ";";
    }

    // Merge children
    if (!this.isChild) {
      this.source[1] += '\n' + this.context.programs.join('\n') + '\n';
    }

    if (!this.environment.isSimple) {
      this.pushSource("return buffer;");
    }

    var params = this.isChild ? ["depth0", "data"] : ["Handlebars", "depth0", "helpers", "partials", "data"];

    for(var i=0, l=this.environment.depths.list.length; i<l; i++) {
      params.push("depth" + this.environment.depths.list[i]);
    }

    // Perform a second pass over the output to merge content when possible
    var source = this.mergeSource();

    if (!this.isChild) {
      source = this.compilerInfo()+source;
    }

    if (asObject) {
      params.push(source);

      return Function.apply(this, params);
    } else {
      var functionSource = 'function ' + (this.name || '') + '(' + params.join(',') + ') {\n  ' + source + '}';
      log('debug', functionSource + "\n\n");
      return functionSource;
    }
  },
  mergeSource: function() {
    // WARN: We are not handling the case where buffer is still populated as the source should
    // not have buffer append operations as their final action.
    var source = '',
        buffer;
    for (var i = 0, len = this.source.length; i < len; i++) {
      var line = this.source[i];
      if (line.appendToBuffer) {
        if (buffer) {
          buffer = buffer + '\n    + ' + line.content;
        } else {
          buffer = line.content;
        }
      } else {
        if (buffer) {
          source += 'buffer += ' + buffer + ';\n  ';
          buffer = undefined;
        }
        source += line + '\n  ';
      }
    }
    return source;
  },

  // [blockValue]
  //
  // On stack, before: hash, inverse, program, value
  // On stack, after: return value of blockHelperMissing
  //
  // The purpose of this opcode is to take a block of the form
  // `{{#foo}}...{{/foo}}`, resolve the value of `foo`, and
  // replace it on the stack with the result of properly
  // invoking blockHelperMissing.
  blockValue: function() {
    this.context.aliases.blockHelperMissing = 'helpers.blockHelperMissing';

    var params = ["depth0"];
    this.setupParams(0, params);

    this.replaceStack(function(current) {
      params.splice(1, 0, current);
      return "blockHelperMissing.call(" + params.join(", ") + ")";
    });
  },

  // [ambiguousBlockValue]
  //
  // On stack, before: hash, inverse, program, value
  // Compiler value, before: lastHelper=value of last found helper, if any
  // On stack, after, if no lastHelper: same as [blockValue]
  // On stack, after, if lastHelper: value
  ambiguousBlockValue: function() {
    this.context.aliases.blockHelperMissing = 'helpers.blockHelperMissing';

    var params = ["depth0"];
    this.setupParams(0, params);

    var current = this.topStack();
    params.splice(1, 0, current);

    this.pushSource("if (!" + this.lastHelper + ") { " + current + " = blockHelperMissing.call(" + params.join(", ") + "); }");
  },

  // [appendContent]
  //
  // On stack, before: ...
  // On stack, after: ...
  //
  // Appends the string value of `content` to the current buffer
  appendContent: function(content) {
    if (this.pendingContent) {
      content = this.pendingContent + content;
    }
    if (this.stripNext) {
      content = content.replace(/^\s+/, '');
    }

    this.pendingContent = content;
  },

  // [strip]
  //
  // On stack, before: ...
  // On stack, after: ...
  //
  // Removes any trailing whitespace from the prior content node and flags
  // the next operation for stripping if it is a content node.
  strip: function() {
    if (this.pendingContent) {
      this.pendingContent = this.pendingContent.replace(/\s+$/, '');
    }
    this.stripNext = 'strip';
  },

  // [append]
  //
  // On stack, before: value, ...
  // On stack, after: ...
  //
  // Coerces `value` to a String and appends it to the current buffer.
  //
  // If `value` is truthy, or 0, it is coerced into a string and appended
  // Otherwise, the empty string is appended
  append: function() {
    // Force anything that is inlined onto the stack so we don't have duplication
    // when we examine local
    this.flushInline();
    var local = this.popStack();
    this.pushSource("if(" + local + " || " + local + " === 0) { " + this.appendToBuffer(local) + " }");
    if (this.environment.isSimple) {
      this.pushSource("else { " + this.appendToBuffer("''") + " }");
    }
  },

  // [appendEscaped]
  //
  // On stack, before: value, ...
  // On stack, after: ...
  //
  // Escape `value` and append it to the buffer
  appendEscaped: function() {
    this.context.aliases.escapeExpression = 'this.escapeExpression';

    this.pushSource(this.appendToBuffer("escapeExpression(" + this.popStack() + ")"));
  },

  // [getContext]
  //
  // On stack, before: ...
  // On stack, after: ...
  // Compiler value, after: lastContext=depth
  //
  // Set the value of the `lastContext` compiler value to the depth
  getContext: function(depth) {
    if(this.lastContext !== depth) {
      this.lastContext = depth;
    }
  },

  // [lookupOnContext]
  //
  // On stack, before: ...
  // On stack, after: currentContext[name], ...
  //
  // Looks up the value of `name` on the current context and pushes
  // it onto the stack.
  lookupOnContext: function(name) {
    this.push(this.nameLookup('depth' + this.lastContext, name, 'context'));
  },

  // [pushContext]
  //
  // On stack, before: ...
  // On stack, after: currentContext, ...
  //
  // Pushes the value of the current context onto the stack.
  pushContext: function() {
    this.pushStackLiteral('depth' + this.lastContext);
  },

  // [resolvePossibleLambda]
  //
  // On stack, before: value, ...
  // On stack, after: resolved value, ...
  //
  // If the `value` is a lambda, replace it on the stack by
  // the return value of the lambda
  resolvePossibleLambda: function() {
    this.context.aliases.functionType = '"function"';

    this.replaceStack(function(current) {
      return "typeof " + current + " === functionType ? " + current + ".apply(depth0) : " + current;
    });
  },

  // [lookup]
  //
  // On stack, before: value, ...
  // On stack, after: value[name], ...
  //
  // Replace the value on the stack with the result of looking
  // up `name` on `value`
  lookup: function(name) {
    this.replaceStack(function(current) {
      return current + " == null || " + current + " === false ? " + current + " : " + this.nameLookup(current, name, 'context');
    });
  },

  // [lookupData]
  //
  // On stack, before: ...
  // On stack, after: data, ...
  //
  // Push the data lookup operator
  lookupData: function() {
    this.pushStackLiteral('data');
  },

  // [pushStringParam]
  //
  // On stack, before: ...
  // On stack, after: string, currentContext, ...
  //
  // This opcode is designed for use in string mode, which
  // provides the string value of a parameter along with its
  // depth rather than resolving it immediately.
  pushStringParam: function(string, type) {
    this.pushStackLiteral('depth' + this.lastContext);

    this.pushString(type);

    // If it's a subexpression, the string result
    // will be pushed after this opcode.
    if (type !== 'sexpr') {
      if (typeof string === 'string') {
        this.pushString(string);
      } else {
        this.pushStackLiteral(string);
      }
    }
  },

  emptyHash: function() {
    this.pushStackLiteral('{}');

    if (this.options.stringParams) {
      this.push('{}'); // hashContexts
      this.push('{}'); // hashTypes
    }
  },
  pushHash: function() {
    if (this.hash) {
      this.hashes.push(this.hash);
    }
    this.hash = {values: [], types: [], contexts: []};
  },
  popHash: function() {
    var hash = this.hash;
    this.hash = this.hashes.pop();

    if (this.options.stringParams) {
      this.push('{' + hash.contexts.join(',') + '}');
      this.push('{' + hash.types.join(',') + '}');
    }

    this.push('{\n    ' + hash.values.join(',\n    ') + '\n  }');
  },

  // [pushString]
  //
  // On stack, before: ...
  // On stack, after: quotedString(string), ...
  //
  // Push a quoted version of `string` onto the stack
  pushString: function(string) {
    this.pushStackLiteral(this.quotedString(string));
  },

  // [push]
  //
  // On stack, before: ...
  // On stack, after: expr, ...
  //
  // Push an expression onto the stack
  push: function(expr) {
    this.inlineStack.push(expr);
    return expr;
  },

  // [pushLiteral]
  //
  // On stack, before: ...
  // On stack, after: value, ...
  //
  // Pushes a value onto the stack. This operation prevents
  // the compiler from creating a temporary variable to hold
  // it.
  pushLiteral: function(value) {
    this.pushStackLiteral(value);
  },

  // [pushProgram]
  //
  // On stack, before: ...
  // On stack, after: program(guid), ...
  //
  // Push a program expression onto the stack. This takes
  // a compile-time guid and converts it into a runtime-accessible
  // expression.
  pushProgram: function(guid) {
    if (guid != null) {
      this.pushStackLiteral(this.programExpression(guid));
    } else {
      this.pushStackLiteral(null);
    }
  },

  // [invokeHelper]
  //
  // On stack, before: hash, inverse, program, params..., ...
  // On stack, after: result of helper invocation
  //
  // Pops off the helper's parameters, invokes the helper,
  // and pushes the helper's return value onto the stack.
  //
  // If the helper is not found, `helperMissing` is called.
  invokeHelper: function(paramSize, name, isRoot) {
    this.context.aliases.helperMissing = 'helpers.helperMissing';
    this.useRegister('helper');

    var helper = this.lastHelper = this.setupHelper(paramSize, name, true);
    var nonHelper = this.nameLookup('depth' + this.lastContext, name, 'context');

    var lookup = 'helper = ' + helper.name + ' || ' + nonHelper;
    if (helper.paramsInit) {
      lookup += ',' + helper.paramsInit;
    }

    this.push(
      '('
        + lookup
        + ',helper '
          + '? helper.call(' + helper.callParams + ') '
          + ': helperMissing.call(' + helper.helperMissingParams + '))');

    // Always flush subexpressions. This is both to prevent the compounding size issue that
    // occurs when the code has to be duplicated for inlining and also to prevent errors
    // due to the incorrect options object being passed due to the shared register.
    if (!isRoot) {
      this.flushInline();
    }
  },

  // [invokeKnownHelper]
  //
  // On stack, before: hash, inverse, program, params..., ...
  // On stack, after: result of helper invocation
  //
  // This operation is used when the helper is known to exist,
  // so a `helperMissing` fallback is not required.
  invokeKnownHelper: function(paramSize, name) {
    var helper = this.setupHelper(paramSize, name);
    this.push(helper.name + ".call(" + helper.callParams + ")");
  },

  // [invokeAmbiguous]
  //
  // On stack, before: hash, inverse, program, params..., ...
  // On stack, after: result of disambiguation
  //
  // This operation is used when an expression like `{{foo}}`
  // is provided, but we don't know at compile-time whether it
  // is a helper or a path.
  //
  // This operation emits more code than the other options,
  // and can be avoided by passing the `knownHelpers` and
  // `knownHelpersOnly` flags at compile-time.
  invokeAmbiguous: function(name, helperCall) {
    this.context.aliases.functionType = '"function"';
    this.useRegister('helper');

    this.emptyHash();
    var helper = this.setupHelper(0, name, helperCall);

    var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');

    var nonHelper = this.nameLookup('depth' + this.lastContext, name, 'context');
    var nextStack = this.nextStack();

    if (helper.paramsInit) {
      this.pushSource(helper.paramsInit);
    }
    this.pushSource('if (helper = ' + helperName + ') { ' + nextStack + ' = helper.call(' + helper.callParams + '); }');
    this.pushSource('else { helper = ' + nonHelper + '; ' + nextStack + ' = typeof helper === functionType ? helper.call(' + helper.callParams + ') : helper; }');
  },

  // [invokePartial]
  //
  // On stack, before: context, ...
  // On stack after: result of partial invocation
  //
  // This operation pops off a context, invokes a partial with that context,
  // and pushes the result of the invocation back.
  invokePartial: function(name) {
    var params = [this.nameLookup('partials', name, 'partial'), "'" + name + "'", this.popStack(), "helpers", "partials"];

    if (this.options.data) {
      params.push("data");
    }

    this.context.aliases.self = "this";
    this.push("self.invokePartial(" + params.join(", ") + ")");
  },

  // [assignToHash]
  //
  // On stack, before: value, hash, ...
  // On stack, after: hash, ...
  //
  // Pops a value and hash off the stack, assigns `hash[key] = value`
  // and pushes the hash back onto the stack.
  assignToHash: function(key) {
    var value = this.popStack(),
        context,
        type;

    if (this.options.stringParams) {
      type = this.popStack();
      context = this.popStack();
    }

    var hash = this.hash;
    if (context) {
      hash.contexts.push("'" + key + "': " + context);
    }
    if (type) {
      hash.types.push("'" + key + "': " + type);
    }
    hash.values.push("'" + key + "': (" + value + ")");
  },

  // HELPERS

  compiler: JavaScriptCompiler,

  compileChildren: function(environment, options) {
    var children = environment.children, child, compiler;

    for(var i=0, l=children.length; i<l; i++) {
      child = children[i];
      compiler = new this.compiler();

      var index = this.matchExistingProgram(child);

      if (index == null) {
        this.context.programs.push('');     // Placeholder to prevent name conflicts for nested children
        index = this.context.programs.length;
        child.index = index;
        child.name = 'program' + index;
        this.context.programs[index] = compiler.compile(child, options, this.context);
        this.context.environments[index] = child;
      } else {
        child.index = index;
        child.name = 'program' + index;
      }
    }
  },
  matchExistingProgram: function(child) {
    for (var i = 0, len = this.context.environments.length; i < len; i++) {
      var environment = this.context.environments[i];
      if (environment && environment.equals(child)) {
        return i;
      }
    }
  },

  programExpression: function(guid) {
    this.context.aliases.self = "this";

    if(guid == null) {
      return "self.noop";
    }

    var child = this.environment.children[guid],
        depths = child.depths.list, depth;

    var programParams = [child.index, child.name, "data"];

    for(var i=0, l = depths.length; i<l; i++) {
      depth = depths[i];

      if(depth === 1) { programParams.push("depth0"); }
      else { programParams.push("depth" + (depth - 1)); }
    }

    return (depths.length === 0 ? "self.program(" : "self.programWithDepth(") + programParams.join(", ") + ")";
  },

  register: function(name, val) {
    this.useRegister(name);
    this.pushSource(name + " = " + val + ";");
  },

  useRegister: function(name) {
    if(!this.registers[name]) {
      this.registers[name] = true;
      this.registers.list.push(name);
    }
  },

  pushStackLiteral: function(item) {
    return this.push(new Literal(item));
  },

  pushSource: function(source) {
    if (this.pendingContent) {
      this.source.push(this.appendToBuffer(this.quotedString(this.pendingContent)));
      this.pendingContent = undefined;
    }

    if (source) {
      this.source.push(source);
    }
  },

  pushStack: function(item) {
    this.flushInline();

    var stack = this.incrStack();
    if (item) {
      this.pushSource(stack + " = " + item + ";");
    }
    this.compileStack.push(stack);
    return stack;
  },

  replaceStack: function(callback) {
    var prefix = '',
        inline = this.isInline(),
        stack,
        createdStack,
        usedLiteral;

    // If we are currently inline then we want to merge the inline statement into the
    // replacement statement via ','
    if (inline) {
      var top = this.popStack(true);

      if (top instanceof Literal) {
        // Literals do not need to be inlined
        stack = top.value;
        usedLiteral = true;
      } else {
        // Get or create the current stack name for use by the inline
        createdStack = !this.stackSlot;
        var name = !createdStack ? this.topStackName() : this.incrStack();

        prefix = '(' + this.push(name) + ' = ' + top + '),';
        stack = this.topStack();
      }
    } else {
      stack = this.topStack();
    }

    var item = callback.call(this, stack);

    if (inline) {
      if (!usedLiteral) {
        this.popStack();
      }
      if (createdStack) {
        this.stackSlot--;
      }
      this.push('(' + prefix + item + ')');
    } else {
      // Prevent modification of the context depth variable. Through replaceStack
      if (!/^stack/.test(stack)) {
        stack = this.nextStack();
      }

      this.pushSource(stack + " = (" + prefix + item + ");");
    }
    return stack;
  },

  nextStack: function() {
    return this.pushStack();
  },

  incrStack: function() {
    this.stackSlot++;
    if(this.stackSlot > this.stackVars.length) { this.stackVars.push("stack" + this.stackSlot); }
    return this.topStackName();
  },
  topStackName: function() {
    return "stack" + this.stackSlot;
  },
  flushInline: function() {
    var inlineStack = this.inlineStack;
    if (inlineStack.length) {
      this.inlineStack = [];
      for (var i = 0, len = inlineStack.length; i < len; i++) {
        var entry = inlineStack[i];
        if (entry instanceof Literal) {
          this.compileStack.push(entry);
        } else {
          this.pushStack(entry);
        }
      }
    }
  },
  isInline: function() {
    return this.inlineStack.length;
  },

  popStack: function(wrapped) {
    var inline = this.isInline(),
        item = (inline ? this.inlineStack : this.compileStack).pop();

    if (!wrapped && (item instanceof Literal)) {
      return item.value;
    } else {
      if (!inline) {
        if (!this.stackSlot) {
          throw new Exception('Invalid stack pop');
        }
        this.stackSlot--;
      }
      return item;
    }
  },

  topStack: function(wrapped) {
    var stack = (this.isInline() ? this.inlineStack : this.compileStack),
        item = stack[stack.length - 1];

    if (!wrapped && (item instanceof Literal)) {
      return item.value;
    } else {
      return item;
    }
  },

  quotedString: function(str) {
    return '"' + str
      .replace(/\\/g, '\\\\')
      .replace(/"/g, '\\"')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/\u2028/g, '\\u2028')   // Per Ecma-262 7.3 + 7.8.4
      .replace(/\u2029/g, '\\u2029') + '"';
  },

  setupHelper: function(paramSize, name, missingParams) {
    var params = [],
        paramsInit = this.setupParams(paramSize, params, missingParams);
    var foundHelper = this.nameLookup('helpers', name, 'helper');

    return {
      params: params,
      paramsInit: paramsInit,
      name: foundHelper,
      callParams: ["depth0"].concat(params).join(", "),
      helperMissingParams: missingParams && ["depth0", this.quotedString(name)].concat(params).join(", ")
    };
  },

  setupOptions: function(paramSize, params) {
    var options = [], contexts = [], types = [], param, inverse, program;

    options.push("hash:" + this.popStack());

    if (this.options.stringParams) {
      options.push("hashTypes:" + this.popStack());
      options.push("hashContexts:" + this.popStack());
    }

    inverse = this.popStack();
    program = this.popStack();

    // Avoid setting fn and inverse if neither are set. This allows
    // helpers to do a check for `if (options.fn)`
    if (program || inverse) {
      if (!program) {
        this.context.aliases.self = "this";
        program = "self.noop";
      }

      if (!inverse) {
        this.context.aliases.self = "this";
        inverse = "self.noop";
      }

      options.push("inverse:" + inverse);
      options.push("fn:" + program);
    }

    for(var i=0; i<paramSize; i++) {
      param = this.popStack();
      params.push(param);

      if(this.options.stringParams) {
        types.push(this.popStack());
        contexts.push(this.popStack());
      }
    }

    if (this.options.stringParams) {
      options.push("contexts:[" + contexts.join(",") + "]");
      options.push("types:[" + types.join(",") + "]");
    }

    if(this.options.data) {
      options.push("data:data");
    }

    return options;
  },

  // the params and contexts arguments are passed in arrays
  // to fill in
  setupParams: function(paramSize, params, useRegister) {
    var options = '{' + this.setupOptions(paramSize, params).join(',') + '}';

    if (useRegister) {
      this.useRegister('options');
      params.push('options');
      return 'options=' + options;
    } else {
      params.push(options);
      return '';
    }
  }
};

var reservedWords = (
  "break else new var" +
  " case finally return void" +
  " catch for switch while" +
  " continue function this with" +
  " default if throw" +
  " delete in try" +
  " do instanceof typeof" +
  " abstract enum int short" +
  " boolean export interface static" +
  " byte extends long super" +
  " char final native synchronized" +
  " class float package throws" +
  " const goto private transient" +
  " debugger implements protected volatile" +
  " double import public let yield"
).split(" ");

var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

for(var i=0, l=reservedWords.length; i<l; i++) {
  compilerWords[reservedWords[i]] = true;
}

JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
  if(!JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name)) {
    return true;
  }
  return false;
};

exports["default"] = JavaScriptCompiler;
},{"../base":148,"../exception":156}],153:[function(require,module,exports){
"use strict";
/* jshint ignore:start */
/* Jison generated parser */
var handlebars = (function(){
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"root":3,"statements":4,"EOF":5,"program":6,"simpleInverse":7,"statement":8,"openInverse":9,"closeBlock":10,"openBlock":11,"mustache":12,"partial":13,"CONTENT":14,"COMMENT":15,"OPEN_BLOCK":16,"sexpr":17,"CLOSE":18,"OPEN_INVERSE":19,"OPEN_ENDBLOCK":20,"path":21,"OPEN":22,"OPEN_UNESCAPED":23,"CLOSE_UNESCAPED":24,"OPEN_PARTIAL":25,"partialName":26,"partial_option0":27,"sexpr_repetition0":28,"sexpr_option0":29,"dataName":30,"param":31,"STRING":32,"INTEGER":33,"BOOLEAN":34,"OPEN_SEXPR":35,"CLOSE_SEXPR":36,"hash":37,"hash_repetition_plus0":38,"hashSegment":39,"ID":40,"EQUALS":41,"DATA":42,"pathSegments":43,"SEP":44,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",14:"CONTENT",15:"COMMENT",16:"OPEN_BLOCK",18:"CLOSE",19:"OPEN_INVERSE",20:"OPEN_ENDBLOCK",22:"OPEN",23:"OPEN_UNESCAPED",24:"CLOSE_UNESCAPED",25:"OPEN_PARTIAL",32:"STRING",33:"INTEGER",34:"BOOLEAN",35:"OPEN_SEXPR",36:"CLOSE_SEXPR",40:"ID",41:"EQUALS",42:"DATA",44:"SEP"},
productions_: [0,[3,2],[3,1],[6,2],[6,3],[6,2],[6,1],[6,1],[6,0],[4,1],[4,2],[8,3],[8,3],[8,1],[8,1],[8,1],[8,1],[11,3],[9,3],[10,3],[12,3],[12,3],[13,4],[7,2],[17,3],[17,1],[31,1],[31,1],[31,1],[31,1],[31,1],[31,3],[37,1],[39,3],[26,1],[26,1],[26,1],[30,2],[21,1],[43,3],[43,1],[27,0],[27,1],[28,0],[28,2],[29,0],[29,1],[38,1],[38,2]],
performAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {

var $0 = $$.length - 1;
switch (yystate) {
case 1: return new yy.ProgramNode($$[$0-1], this._$); 
break;
case 2: return new yy.ProgramNode([], this._$); 
break;
case 3:this.$ = new yy.ProgramNode([], $$[$0-1], $$[$0], this._$);
break;
case 4:this.$ = new yy.ProgramNode($$[$0-2], $$[$0-1], $$[$0], this._$);
break;
case 5:this.$ = new yy.ProgramNode($$[$0-1], $$[$0], [], this._$);
break;
case 6:this.$ = new yy.ProgramNode($$[$0], this._$);
break;
case 7:this.$ = new yy.ProgramNode([], this._$);
break;
case 8:this.$ = new yy.ProgramNode([], this._$);
break;
case 9:this.$ = [$$[$0]];
break;
case 10: $$[$0-1].push($$[$0]); this.$ = $$[$0-1]; 
break;
case 11:this.$ = new yy.BlockNode($$[$0-2], $$[$0-1].inverse, $$[$0-1], $$[$0], this._$);
break;
case 12:this.$ = new yy.BlockNode($$[$0-2], $$[$0-1], $$[$0-1].inverse, $$[$0], this._$);
break;
case 13:this.$ = $$[$0];
break;
case 14:this.$ = $$[$0];
break;
case 15:this.$ = new yy.ContentNode($$[$0], this._$);
break;
case 16:this.$ = new yy.CommentNode($$[$0], this._$);
break;
case 17:this.$ = new yy.MustacheNode($$[$0-1], null, $$[$0-2], stripFlags($$[$0-2], $$[$0]), this._$);
break;
case 18:this.$ = new yy.MustacheNode($$[$0-1], null, $$[$0-2], stripFlags($$[$0-2], $$[$0]), this._$);
break;
case 19:this.$ = {path: $$[$0-1], strip: stripFlags($$[$0-2], $$[$0])};
break;
case 20:this.$ = new yy.MustacheNode($$[$0-1], null, $$[$0-2], stripFlags($$[$0-2], $$[$0]), this._$);
break;
case 21:this.$ = new yy.MustacheNode($$[$0-1], null, $$[$0-2], stripFlags($$[$0-2], $$[$0]), this._$);
break;
case 22:this.$ = new yy.PartialNode($$[$0-2], $$[$0-1], stripFlags($$[$0-3], $$[$0]), this._$);
break;
case 23:this.$ = stripFlags($$[$0-1], $$[$0]);
break;
case 24:this.$ = new yy.SexprNode([$$[$0-2]].concat($$[$0-1]), $$[$0], this._$);
break;
case 25:this.$ = new yy.SexprNode([$$[$0]], null, this._$);
break;
case 26:this.$ = $$[$0];
break;
case 27:this.$ = new yy.StringNode($$[$0], this._$);
break;
case 28:this.$ = new yy.IntegerNode($$[$0], this._$);
break;
case 29:this.$ = new yy.BooleanNode($$[$0], this._$);
break;
case 30:this.$ = $$[$0];
break;
case 31:$$[$0-1].isHelper = true; this.$ = $$[$0-1];
break;
case 32:this.$ = new yy.HashNode($$[$0], this._$);
break;
case 33:this.$ = [$$[$0-2], $$[$0]];
break;
case 34:this.$ = new yy.PartialNameNode($$[$0], this._$);
break;
case 35:this.$ = new yy.PartialNameNode(new yy.StringNode($$[$0], this._$), this._$);
break;
case 36:this.$ = new yy.PartialNameNode(new yy.IntegerNode($$[$0], this._$));
break;
case 37:this.$ = new yy.DataNode($$[$0], this._$);
break;
case 38:this.$ = new yy.IdNode($$[$0], this._$);
break;
case 39: $$[$0-2].push({part: $$[$0], separator: $$[$0-1]}); this.$ = $$[$0-2]; 
break;
case 40:this.$ = [{part: $$[$0]}];
break;
case 43:this.$ = [];
break;
case 44:$$[$0-1].push($$[$0]);
break;
case 47:this.$ = [$$[$0]];
break;
case 48:$$[$0-1].push($$[$0]);
break;
}
},
table: [{3:1,4:2,5:[1,3],8:4,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,11],22:[1,13],23:[1,14],25:[1,15]},{1:[3]},{5:[1,16],8:17,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,11],22:[1,13],23:[1,14],25:[1,15]},{1:[2,2]},{5:[2,9],14:[2,9],15:[2,9],16:[2,9],19:[2,9],20:[2,9],22:[2,9],23:[2,9],25:[2,9]},{4:20,6:18,7:19,8:4,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,21],20:[2,8],22:[1,13],23:[1,14],25:[1,15]},{4:20,6:22,7:19,8:4,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,21],20:[2,8],22:[1,13],23:[1,14],25:[1,15]},{5:[2,13],14:[2,13],15:[2,13],16:[2,13],19:[2,13],20:[2,13],22:[2,13],23:[2,13],25:[2,13]},{5:[2,14],14:[2,14],15:[2,14],16:[2,14],19:[2,14],20:[2,14],22:[2,14],23:[2,14],25:[2,14]},{5:[2,15],14:[2,15],15:[2,15],16:[2,15],19:[2,15],20:[2,15],22:[2,15],23:[2,15],25:[2,15]},{5:[2,16],14:[2,16],15:[2,16],16:[2,16],19:[2,16],20:[2,16],22:[2,16],23:[2,16],25:[2,16]},{17:23,21:24,30:25,40:[1,28],42:[1,27],43:26},{17:29,21:24,30:25,40:[1,28],42:[1,27],43:26},{17:30,21:24,30:25,40:[1,28],42:[1,27],43:26},{17:31,21:24,30:25,40:[1,28],42:[1,27],43:26},{21:33,26:32,32:[1,34],33:[1,35],40:[1,28],43:26},{1:[2,1]},{5:[2,10],14:[2,10],15:[2,10],16:[2,10],19:[2,10],20:[2,10],22:[2,10],23:[2,10],25:[2,10]},{10:36,20:[1,37]},{4:38,8:4,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,11],20:[2,7],22:[1,13],23:[1,14],25:[1,15]},{7:39,8:17,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,21],20:[2,6],22:[1,13],23:[1,14],25:[1,15]},{17:23,18:[1,40],21:24,30:25,40:[1,28],42:[1,27],43:26},{10:41,20:[1,37]},{18:[1,42]},{18:[2,43],24:[2,43],28:43,32:[2,43],33:[2,43],34:[2,43],35:[2,43],36:[2,43],40:[2,43],42:[2,43]},{18:[2,25],24:[2,25],36:[2,25]},{18:[2,38],24:[2,38],32:[2,38],33:[2,38],34:[2,38],35:[2,38],36:[2,38],40:[2,38],42:[2,38],44:[1,44]},{21:45,40:[1,28],43:26},{18:[2,40],24:[2,40],32:[2,40],33:[2,40],34:[2,40],35:[2,40],36:[2,40],40:[2,40],42:[2,40],44:[2,40]},{18:[1,46]},{18:[1,47]},{24:[1,48]},{18:[2,41],21:50,27:49,40:[1,28],43:26},{18:[2,34],40:[2,34]},{18:[2,35],40:[2,35]},{18:[2,36],40:[2,36]},{5:[2,11],14:[2,11],15:[2,11],16:[2,11],19:[2,11],20:[2,11],22:[2,11],23:[2,11],25:[2,11]},{21:51,40:[1,28],43:26},{8:17,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,11],20:[2,3],22:[1,13],23:[1,14],25:[1,15]},{4:52,8:4,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,11],20:[2,5],22:[1,13],23:[1,14],25:[1,15]},{14:[2,23],15:[2,23],16:[2,23],19:[2,23],20:[2,23],22:[2,23],23:[2,23],25:[2,23]},{5:[2,12],14:[2,12],15:[2,12],16:[2,12],19:[2,12],20:[2,12],22:[2,12],23:[2,12],25:[2,12]},{14:[2,18],15:[2,18],16:[2,18],19:[2,18],20:[2,18],22:[2,18],23:[2,18],25:[2,18]},{18:[2,45],21:56,24:[2,45],29:53,30:60,31:54,32:[1,57],33:[1,58],34:[1,59],35:[1,61],36:[2,45],37:55,38:62,39:63,40:[1,64],42:[1,27],43:26},{40:[1,65]},{18:[2,37],24:[2,37],32:[2,37],33:[2,37],34:[2,37],35:[2,37],36:[2,37],40:[2,37],42:[2,37]},{14:[2,17],15:[2,17],16:[2,17],19:[2,17],20:[2,17],22:[2,17],23:[2,17],25:[2,17]},{5:[2,20],14:[2,20],15:[2,20],16:[2,20],19:[2,20],20:[2,20],22:[2,20],23:[2,20],25:[2,20]},{5:[2,21],14:[2,21],15:[2,21],16:[2,21],19:[2,21],20:[2,21],22:[2,21],23:[2,21],25:[2,21]},{18:[1,66]},{18:[2,42]},{18:[1,67]},{8:17,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,11],20:[2,4],22:[1,13],23:[1,14],25:[1,15]},{18:[2,24],24:[2,24],36:[2,24]},{18:[2,44],24:[2,44],32:[2,44],33:[2,44],34:[2,44],35:[2,44],36:[2,44],40:[2,44],42:[2,44]},{18:[2,46],24:[2,46],36:[2,46]},{18:[2,26],24:[2,26],32:[2,26],33:[2,26],34:[2,26],35:[2,26],36:[2,26],40:[2,26],42:[2,26]},{18:[2,27],24:[2,27],32:[2,27],33:[2,27],34:[2,27],35:[2,27],36:[2,27],40:[2,27],42:[2,27]},{18:[2,28],24:[2,28],32:[2,28],33:[2,28],34:[2,28],35:[2,28],36:[2,28],40:[2,28],42:[2,28]},{18:[2,29],24:[2,29],32:[2,29],33:[2,29],34:[2,29],35:[2,29],36:[2,29],40:[2,29],42:[2,29]},{18:[2,30],24:[2,30],32:[2,30],33:[2,30],34:[2,30],35:[2,30],36:[2,30],40:[2,30],42:[2,30]},{17:68,21:24,30:25,40:[1,28],42:[1,27],43:26},{18:[2,32],24:[2,32],36:[2,32],39:69,40:[1,70]},{18:[2,47],24:[2,47],36:[2,47],40:[2,47]},{18:[2,40],24:[2,40],32:[2,40],33:[2,40],34:[2,40],35:[2,40],36:[2,40],40:[2,40],41:[1,71],42:[2,40],44:[2,40]},{18:[2,39],24:[2,39],32:[2,39],33:[2,39],34:[2,39],35:[2,39],36:[2,39],40:[2,39],42:[2,39],44:[2,39]},{5:[2,22],14:[2,22],15:[2,22],16:[2,22],19:[2,22],20:[2,22],22:[2,22],23:[2,22],25:[2,22]},{5:[2,19],14:[2,19],15:[2,19],16:[2,19],19:[2,19],20:[2,19],22:[2,19],23:[2,19],25:[2,19]},{36:[1,72]},{18:[2,48],24:[2,48],36:[2,48],40:[2,48]},{41:[1,71]},{21:56,30:60,31:73,32:[1,57],33:[1,58],34:[1,59],35:[1,61],40:[1,28],42:[1,27],43:26},{18:[2,31],24:[2,31],32:[2,31],33:[2,31],34:[2,31],35:[2,31],36:[2,31],40:[2,31],42:[2,31]},{18:[2,33],24:[2,33],36:[2,33],40:[2,33]}],
defaultActions: {3:[2,2],16:[2,1],50:[2,42]},
parseError: function parseError(str, hash) {
    throw new Error(str);
},
parse: function parse(input) {
    var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    this.lexer.setInput(input);
    this.lexer.yy = this.yy;
    this.yy.lexer = this.lexer;
    this.yy.parser = this;
    if (typeof this.lexer.yylloc == "undefined")
        this.lexer.yylloc = {};
    var yyloc = this.lexer.yylloc;
    lstack.push(yyloc);
    var ranges = this.lexer.options && this.lexer.options.ranges;
    if (typeof this.yy.parseError === "function")
        this.parseError = this.yy.parseError;
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    function lex() {
        var token;
        token = self.lexer.lex() || 1;
        if (typeof token !== "number") {
            token = self.symbols_[token] || token;
        }
        return token;
    }
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == "undefined") {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
            var errStr = "";
            if (!recovering) {
                expected = [];
                for (p in table[state])
                    if (this.terminals_[p] && p > 2) {
                        expected.push("'" + this.terminals_[p] + "'");
                    }
                if (this.lexer.showPosition) {
                    errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                } else {
                    errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1?"end of input":"'" + (this.terminals_[symbol] || symbol) + "'");
                }
                this.parseError(errStr, {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});
            }
        }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(this.lexer.yytext);
            lstack.push(this.lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = this.lexer.yyleng;
                yytext = this.lexer.yytext;
                yylineno = this.lexer.yylineno;
                yyloc = this.lexer.yylloc;
                if (recovering > 0)
                    recovering--;
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column};
            if (ranges) {
                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
            }
            r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
            if (typeof r !== "undefined") {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}
};


function stripFlags(open, close) {
  return {
    left: open.charAt(2) === '~',
    right: close.charAt(0) === '~' || close.charAt(1) === '~'
  };
}

/* Jison generated lexer */
var lexer = (function(){
var lexer = ({EOF:1,
parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },
setInput:function (input) {
        this._input = input;
        this._more = this._less = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};
        if (this.options.ranges) this.yylloc.range = [0,0];
        this.offset = 0;
        return this;
    },
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) this.yylloc.range[1]++;

        this._input = this._input.slice(1);
        return ch;
    },
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length-len-1);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length-1);
        this.matched = this.matched.substr(0, this.matched.length-1);

        if (lines.length-1) this.yylineno -= lines.length-1;
        var r = this.yylloc.range;

        this.yylloc = {first_line: this.yylloc.first_line,
          last_line: this.yylineno+1,
          first_column: this.yylloc.first_column,
          last_column: lines ?
              (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length:
              this.yylloc.first_column - len
          };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        return this;
    },
more:function () {
        this._more = true;
        return this;
    },
less:function (n) {
        this.unput(this.match.slice(n));
    },
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\n/g, "");
    },
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c+"^";
    },
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) this.done = true;

        var token,
            match,
            tempMatch,
            index,
            col,
            lines;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i=0;i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (!this.options.flex) break;
            }
        }
        if (match) {
            lines = match[0].match(/(?:\r\n?|\n).*/g);
            if (lines) this.yylineno += lines.length;
            this.yylloc = {first_line: this.yylloc.last_line,
                           last_line: this.yylineno+1,
                           first_column: this.yylloc.last_column,
                           last_column: lines ? lines[lines.length-1].length-lines[lines.length-1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length};
            this.yytext += match[0];
            this.match += match[0];
            this.matches = match;
            this.yyleng = this.yytext.length;
            if (this.options.ranges) {
                this.yylloc.range = [this.offset, this.offset += this.yyleng];
            }
            this._more = false;
            this._input = this._input.slice(match[0].length);
            this.matched += match[0];
            token = this.performAction.call(this, this.yy, this, rules[index],this.conditionStack[this.conditionStack.length-1]);
            if (this.done && this._input) this.done = false;
            if (token) return token;
            else return;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\n'+this.showPosition(),
                    {text: "", token: null, line: this.yylineno});
        }
    },
lex:function lex() {
        var r = this.next();
        if (typeof r !== 'undefined') {
            return r;
        } else {
            return this.lex();
        }
    },
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },
popState:function popState() {
        return this.conditionStack.pop();
    },
_currentRules:function _currentRules() {
        return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;
    },
topState:function () {
        return this.conditionStack[this.conditionStack.length-2];
    },
pushState:function begin(condition) {
        this.begin(condition);
    }});
lexer.options = {};
lexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {


function strip(start, end) {
  return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng-end);
}


var YYSTATE=YY_START
switch($avoiding_name_collisions) {
case 0:
                                   if(yy_.yytext.slice(-2) === "\\\\") {
                                     strip(0,1);
                                     this.begin("mu");
                                   } else if(yy_.yytext.slice(-1) === "\\") {
                                     strip(0,1);
                                     this.begin("emu");
                                   } else {
                                     this.begin("mu");
                                   }
                                   if(yy_.yytext) return 14;
                                 
break;
case 1:return 14;
break;
case 2:
                                   this.popState();
                                   return 14;
                                 
break;
case 3:strip(0,4); this.popState(); return 15;
break;
case 4:return 35;
break;
case 5:return 36;
break;
case 6:return 25;
break;
case 7:return 16;
break;
case 8:return 20;
break;
case 9:return 19;
break;
case 10:return 19;
break;
case 11:return 23;
break;
case 12:return 22;
break;
case 13:this.popState(); this.begin('com');
break;
case 14:strip(3,5); this.popState(); return 15;
break;
case 15:return 22;
break;
case 16:return 41;
break;
case 17:return 40;
break;
case 18:return 40;
break;
case 19:return 44;
break;
case 20:// ignore whitespace
break;
case 21:this.popState(); return 24;
break;
case 22:this.popState(); return 18;
break;
case 23:yy_.yytext = strip(1,2).replace(/\\"/g,'"'); return 32;
break;
case 24:yy_.yytext = strip(1,2).replace(/\\'/g,"'"); return 32;
break;
case 25:return 42;
break;
case 26:return 34;
break;
case 27:return 34;
break;
case 28:return 33;
break;
case 29:return 40;
break;
case 30:yy_.yytext = strip(1,2); return 40;
break;
case 31:return 'INVALID';
break;
case 32:return 5;
break;
}
};
lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/,/^(?:[^\x00]+)/,/^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/,/^(?:[\s\S]*?--\}\})/,/^(?:\()/,/^(?:\))/,/^(?:\{\{(~)?>)/,/^(?:\{\{(~)?#)/,/^(?:\{\{(~)?\/)/,/^(?:\{\{(~)?\^)/,/^(?:\{\{(~)?\s*else\b)/,/^(?:\{\{(~)?\{)/,/^(?:\{\{(~)?&)/,/^(?:\{\{!--)/,/^(?:\{\{![\s\S]*?\}\})/,/^(?:\{\{(~)?)/,/^(?:=)/,/^(?:\.\.)/,/^(?:\.(?=([=~}\s\/.)])))/,/^(?:[\/.])/,/^(?:\s+)/,/^(?:\}(~)?\}\})/,/^(?:(~)?\}\})/,/^(?:"(\\["]|[^"])*")/,/^(?:'(\\[']|[^'])*')/,/^(?:@)/,/^(?:true(?=([~}\s)])))/,/^(?:false(?=([~}\s)])))/,/^(?:-?[0-9]+(?=([~}\s)])))/,/^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)]))))/,/^(?:\[[^\]]*\])/,/^(?:.)/,/^(?:$)/];
lexer.conditions = {"mu":{"rules":[4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32],"inclusive":false},"emu":{"rules":[2],"inclusive":false},"com":{"rules":[3],"inclusive":false},"INITIAL":{"rules":[0,1,32],"inclusive":true}};
return lexer;})()
parser.lexer = lexer;
function Parser () { this.yy = {}; }Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();exports["default"] = handlebars;
/* jshint ignore:end */
},{}],154:[function(require,module,exports){
"use strict";
var Visitor = require("./visitor")["default"];

function print(ast) {
  return new PrintVisitor().accept(ast);
}

exports.print = print;function PrintVisitor() {
  this.padding = 0;
}

exports.PrintVisitor = PrintVisitor;PrintVisitor.prototype = new Visitor();

PrintVisitor.prototype.pad = function(string, newline) {
  var out = "";

  for(var i=0,l=this.padding; i<l; i++) {
    out = out + "  ";
  }

  out = out + string;

  if(newline !== false) { out = out + "\n"; }
  return out;
};

PrintVisitor.prototype.program = function(program) {
  var out = "",
      statements = program.statements,
      i, l;

  for(i=0, l=statements.length; i<l; i++) {
    out = out + this.accept(statements[i]);
  }

  this.padding--;

  return out;
};

PrintVisitor.prototype.block = function(block) {
  var out = "";

  out = out + this.pad("BLOCK:");
  this.padding++;
  out = out + this.accept(block.mustache);
  if (block.program) {
    out = out + this.pad("PROGRAM:");
    this.padding++;
    out = out + this.accept(block.program);
    this.padding--;
  }
  if (block.inverse) {
    if (block.program) { this.padding++; }
    out = out + this.pad("{{^}}");
    this.padding++;
    out = out + this.accept(block.inverse);
    this.padding--;
    if (block.program) { this.padding--; }
  }
  this.padding--;

  return out;
};

PrintVisitor.prototype.sexpr = function(sexpr) {
  var params = sexpr.params, paramStrings = [], hash;

  for(var i=0, l=params.length; i<l; i++) {
    paramStrings.push(this.accept(params[i]));
  }

  params = "[" + paramStrings.join(", ") + "]";

  hash = sexpr.hash ? " " + this.accept(sexpr.hash) : "";

  return this.accept(sexpr.id) + " " + params + hash;
};

PrintVisitor.prototype.mustache = function(mustache) {
  return this.pad("{{ " + this.accept(mustache.sexpr) + " }}");
};

PrintVisitor.prototype.partial = function(partial) {
  var content = this.accept(partial.partialName);
  if(partial.context) { content = content + " " + this.accept(partial.context); }
  return this.pad("{{> " + content + " }}");
};

PrintVisitor.prototype.hash = function(hash) {
  var pairs = hash.pairs;
  var joinedPairs = [], left, right;

  for(var i=0, l=pairs.length; i<l; i++) {
    left = pairs[i][0];
    right = this.accept(pairs[i][1]);
    joinedPairs.push( left + "=" + right );
  }

  return "HASH{" + joinedPairs.join(", ") + "}";
};

PrintVisitor.prototype.STRING = function(string) {
  return '"' + string.string + '"';
};

PrintVisitor.prototype.INTEGER = function(integer) {
  return "INTEGER{" + integer.integer + "}";
};

PrintVisitor.prototype.BOOLEAN = function(bool) {
  return "BOOLEAN{" + bool.bool + "}";
};

PrintVisitor.prototype.ID = function(id) {
  var path = id.parts.join("/");
  if(id.parts.length > 1) {
    return "PATH:" + path;
  } else {
    return "ID:" + path;
  }
};

PrintVisitor.prototype.PARTIAL_NAME = function(partialName) {
    return "PARTIAL:" + partialName.name;
};

PrintVisitor.prototype.DATA = function(data) {
  return "@" + this.accept(data.id);
};

PrintVisitor.prototype.content = function(content) {
  return this.pad("CONTENT[ '" + content.string + "' ]");
};

PrintVisitor.prototype.comment = function(comment) {
  return this.pad("{{! '" + comment.comment + "' }}");
};
},{"./visitor":155}],155:[function(require,module,exports){
"use strict";
function Visitor() {}

Visitor.prototype = {
  constructor: Visitor,

  accept: function(object) {
    return this[object.type](object);
  }
};

exports["default"] = Visitor;
},{}],156:[function(require,module,exports){
"use strict";

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var line;
  if (node && node.firstLine) {
    line = node.firstLine;

    message += ' - ' + line + ':' + node.firstColumn;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  if (line) {
    this.lineNumber = line;
    this.column = node.firstColumn;
  }
}

Exception.prototype = new Error();

exports["default"] = Exception;
},{}],157:[function(require,module,exports){
"use strict";
var Utils = require("./utils");
var Exception = require("./exception")["default"];
var COMPILER_REVISION = require("./base").COMPILER_REVISION;
var REVISION_CHANGES = require("./base").REVISION_CHANGES;

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision < currentRevision) {
      var runtimeVersions = REVISION_CHANGES[currentRevision],
          compilerVersions = REVISION_CHANGES[compilerRevision];
      throw new Exception("Template was precompiled with an older version of Handlebars than the current runtime. "+
            "Please update your precompiler to a newer version ("+runtimeVersions+") or downgrade your runtime to an older version ("+compilerVersions+").");
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new Exception("Template was precompiled with a newer version of Handlebars than the current runtime. "+
            "Please update your runtime to a newer version ("+compilerInfo[1]+").");
    }
  }
}

exports.checkRevision = checkRevision;// TODO: Remove this line and break up compilePartial

function template(templateSpec, env) {
  if (!env) {
    throw new Exception("No environment passed to template");
  }

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  var invokePartialWrapper = function(partial, name, context, helpers, partials, data) {
    var result = env.VM.invokePartial.apply(this, arguments);
    if (result != null) { return result; }

    if (env.compile) {
      var options = { helpers: helpers, partials: partials, data: data };
      partials[name] = env.compile(partial, { data: data !== undefined }, env);
      return partials[name](context, options);
    } else {
      throw new Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
    }
  };

  // Just add water
  var container = {
    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,
    programs: [],
    program: function(i, fn, data) {
      var programWrapper = this.programs[i];
      if(data) {
        programWrapper = program(i, fn, data);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = program(i, fn);
      }
      return programWrapper;
    },
    merge: function(param, common) {
      var ret = param || common;

      if (param && common && (param !== common)) {
        ret = {};
        Utils.extend(ret, common);
        Utils.extend(ret, param);
      }
      return ret;
    },
    programWithDepth: env.VM.programWithDepth,
    noop: env.VM.noop,
    compilerInfo: null
  };

  return function(context, options) {
    options = options || {};
    var namespace = options.partial ? options : env,
        helpers,
        partials;

    if (!options.partial) {
      helpers = options.helpers;
      partials = options.partials;
    }
    var result = templateSpec.call(
          container,
          namespace, context,
          helpers,
          partials,
          options.data);

    if (!options.partial) {
      env.VM.checkRevision(container.compilerInfo);
    }

    return result;
  };
}

exports.template = template;function programWithDepth(i, fn, data /*, $depth */) {
  var args = Array.prototype.slice.call(arguments, 3);

  var prog = function(context, options) {
    options = options || {};

    return fn.apply(this, [context, options.data || data].concat(args));
  };
  prog.program = i;
  prog.depth = args.length;
  return prog;
}

exports.programWithDepth = programWithDepth;function program(i, fn, data) {
  var prog = function(context, options) {
    options = options || {};

    return fn(context, options.data || data);
  };
  prog.program = i;
  prog.depth = 0;
  return prog;
}

exports.program = program;function invokePartial(partial, name, context, helpers, partials, data) {
  var options = { partial: true, helpers: helpers, partials: partials, data: data };

  if(partial === undefined) {
    throw new Exception("The partial " + name + " could not be found");
  } else if(partial instanceof Function) {
    return partial(context, options);
  }
}

exports.invokePartial = invokePartial;function noop() { return ""; }

exports.noop = noop;
},{"./base":148,"./exception":156,"./utils":159}],158:[function(require,module,exports){
"use strict";
// Build out our basic SafeString type
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = function() {
  return "" + this.string;
};

exports["default"] = SafeString;
},{}],159:[function(require,module,exports){
"use strict";
/*jshint -W004 */
var SafeString = require("./safe-string")["default"];

var escape = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;"
};

var badChars = /[&<>"'`]/g;
var possible = /[&<>"'`]/;

function escapeChar(chr) {
  return escape[chr] || "&amp;";
}

function extend(obj, value) {
  for(var key in value) {
    if(Object.prototype.hasOwnProperty.call(value, key)) {
      obj[key] = value[key];
    }
  }
}

exports.extend = extend;var toString = Object.prototype.toString;
exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
var isFunction = function(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
if (isFunction(/x/)) {
  isFunction = function(value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
var isFunction;
exports.isFunction = isFunction;
var isArray = Array.isArray || function(value) {
  return (value && typeof value === 'object') ? toString.call(value) === '[object Array]' : false;
};
exports.isArray = isArray;

function escapeExpression(string) {
  // don't escape SafeStrings, since they're already safe
  if (string instanceof SafeString) {
    return string.toString();
  } else if (!string && string !== 0) {
    return "";
  }

  // Force a string conversion as this will be done by the append regardless and
  // the regex test will do this transparently behind the scenes, causing issues if
  // an object's to string has escaped characters in it.
  string = "" + string;

  if(!possible.test(string)) { return string; }
  return string.replace(badChars, escapeChar);
}

exports.escapeExpression = escapeExpression;function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

exports.isEmpty = isEmpty;
},{"./safe-string":158}],160:[function(require,module,exports){
// USAGE:
// var handlebars = require('handlebars');

// var local = handlebars.create();

var handlebars = require('../dist/cjs/handlebars')["default"];

handlebars.Visitor = require('../dist/cjs/handlebars/compiler/visitor')["default"];

var printer = require('../dist/cjs/handlebars/compiler/printer');
handlebars.PrintVisitor = printer.PrintVisitor;
handlebars.print = printer.print;

module.exports = handlebars;

// Publish a Node.js require() handler for .handlebars and .hbs files
if (typeof require !== 'undefined' && require.extensions) {
  var extension = function(module, filename) {
    var fs = require("fs");
    var templateString = fs.readFileSync(filename, "utf8");
    module.exports = handlebars.compile(templateString);
  };
  require.extensions[".handlebars"] = extension;
  require.extensions[".hbs"] = extension;
}

},{"../dist/cjs/handlebars":146,"../dist/cjs/handlebars/compiler/printer":154,"../dist/cjs/handlebars/compiler/visitor":155,"fs":113}],161:[function(require,module,exports){
// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
module.exports = require('./dist/cjs/handlebars.runtime');

},{"./dist/cjs/handlebars.runtime":147}],162:[function(require,module,exports){
module.exports = require("handlebars/runtime")["default"];

},{"handlebars/runtime":161}],163:[function(require,module,exports){
/*
    Heavily inspired by the original js library copyright Mixpanel, Inc.
    (http://mixpanel.com/)

    Copyright (c) 2012 Carl Sverre

    Released under the MIT license.
*/

var http            = require('http'),
    querystring     = require('querystring'),
    Buffer          = require('buffer').Buffer,
    util            = require('util');

var create_client = function(token, config) {
    var metrics = {};

    if(!token) {
        throw new Error("The Mixpanel Client needs a Mixpanel token: `init(token)`");
    }

    metrics.config = {
        test: false,
        debug: false,
        verbose: false
    };

    metrics.token = token;

    /**
        send_request(data)
        ---
        this function sends an async GET request to mixpanel

        data:object                     the data to send in the request
        callback:function(err:Error)    callback is called when the request is
                                        finished or an error occurs
    */
    metrics.send_request = function(endpoint, data, callback) {
        callback = callback || function() {};
        var event_data = new Buffer(JSON.stringify(data));
        var request_data = {
            'data': event_data.toString('base64'),
            'ip': 0,
            'verbose': metrics.config.verbose ? 1 : 0
        };

        if (endpoint === '/import') {
            var key = metrics.config.key;
            if (!key) {
                throw new Error("The Mixpanel Client needs a Mixpanel api key when importing old events: `init(token, { key: ... })`");
            }
            request_data.api_key = key;
        }

        var request_options = {
            host: 'api.mixpanel.com', 
            headers: {}
        };

        request_options = _extend(request_options, metrics.config.request_options);

        if (metrics.config.test) { request_data.test = 1; }

        var query = querystring.stringify(request_data);

        request_options.path = [endpoint,"?",query].join("");

        http.get(request_options, function(res) {
            var data = "";
            res.on('data', function(chunk) {
               data += chunk;
            });

            res.on('end', function() {
                var e;
                if(metrics.config.verbose) {
                    try {
                        var result = JSON.parse(data);
                        if(result.status != 1) {
                            e = new Error("Mixpanel Server Error: " + result.error);
                        }
                    }
                    catch(ex) {
                        e = new Error("Could not parse response from Mixpanel");
                    }
                }
                else {
                    e = (data !== '1') ? new Error("Mixpanel Server Error: " + data) : undefined;
                }

                callback(e);
            });
        }).on('error', function(e) {
            if(metrics.config.debug) {
                console.log("Got Error: " + e.message);
            }
            callback(e);
        });
    };

    /**
        track(event, properties, callback)
        ---
        this function sends an event to mixpanel.

        event:string                    the event name
        properties:object               additional event properties to send
        callback:function(err:Error)    callback is called when the request is
                                        finished or an error occurs
    */
    metrics.track = function(event, properties, callback) {
        if (typeof(properties) === 'function' || !properties) {
            callback = properties;
            properties = {};
        }

        // if properties.time exists, use import endpoint
        var endpoint = (typeof(properties.time) === 'number') ? '/import' : '/track';

        properties.token = metrics.token;
        properties.mp_lib = "node";

        var data = {
            'event' : event,
            'properties' : properties
        };

        if (metrics.config.debug) {
            console.log("Sending the following event to Mixpanel:");
            console.log(data);
        }

        metrics.send_request(endpoint, data, callback);
    };

    /**
        import(event, properties, callback)
        ---
        This function sends an event to mixpanel using the import
        endpoint.  The time argument should be either a Date or Number,
        and should signify the time the event occurred.

        It is highly recommended that you specify the distinct_id
        property for each event you import, otherwise the events will be
        tied to the IP address of the sending machine.

        For more information look at:
        https://mixpanel.com/docs/api-documentation/importing-events-older-than-31-days

        event:string                    the event name
        time:date|number                the time of the event
        properties:object               additional event properties to send
        callback:function(err:Error)    callback is called when the request is
                                        finished or an error occurs
    */
    metrics.import = function(event, time, properties, callback) {
        if (typeof(properties) === 'function' || !properties) {
            callback = properties;
            properties = {};
        }

        if (time === void 0) {
            throw new Error("The import method requires you to specify the time of the event");
        } else if (Object.prototype.toString.call(time) === '[object Date]') {
            time = Math.floor(time.getTime() / 1000);
        }

        properties.time = time;

        metrics.track(event, properties, callback);
    };

    /**
        alias(distinct_id, alias)
        ---
        This function creates an alias for distinct_id

        For more information look at:
        https://mixpanel.com/docs/integration-libraries/using-mixpanel-alias

        distinct_id:string              the current identifier
        alias:string                    the future alias
    */
    metrics.alias = function(distinct_id, alias, callback) {
        var properties = {
            distinct_id: distinct_id,
            alias: alias
        };

        metrics.track('$create_alias', properties, callback);
    };

    metrics.people = {
        /** people.set_once(distinct_id, prop, to, callback)
            ---
            The same as people.set but in the words of mixpanel:
            mixpanel.people.set_once

            " This method allows you to set a user attribute, only if
             it is not currently set. It can be called multiple times
             safely, so is perfect for storing things like the first date
             you saw a user, or the referrer that brought them to your
             website for the first time. "

        */
        set_once: function(distinct_id, prop, to, callback) {
            var $set = {}, data = {};

            if (typeof(prop) === 'object') {
                callback = to;
                $set = prop;
            } else {
                $set[prop] = to;
            }

            this._set(distinct_id, $set, callback, { set_once: true });
        },

        /**
            people.set(distinct_id, prop, to, callback)
            ---
            set properties on an user record in engage

            usage:

                mixpanel.people.set('bob', 'gender', 'm');

                mixpanel.people.set('joe', {
                    'company': 'acme',
                    'plan': 'premium'
                });
        */
        set: function(distinct_id, prop, to, callback) {
            var $set = {}, data = {};

            if (typeof(prop) === 'object') {
                callback = to;
                $set = prop;
            } else {
                $set[prop] = to;
            }

            this._set(distinct_id, $set, callback);
        },

        // used internally by set and set_once
        _set: function(distinct_id, $set, callback, options) {
            var set_key = (options && options.set_once) ? "$set_once" : "$set";

            var data = {
                '$token': metrics.token,
                '$distinct_id': distinct_id
            };
            data[set_key] = $set;

            if ('ip' in $set) {
                data.$ip = $set.ip;
                delete $set.ip;
            }

            if ($set.$ignore_time) {
                data.$ignore_time = $set.$ignore_time;
                delete $set.$ignore_time;
            }

            if(metrics.config.debug) {
                console.log("Sending the following data to Mixpanel (Engage):");
                console.log(data);
            }

            metrics.send_request('/engage', data, callback);
        },

        /**
            people.increment(distinct_id, prop, to, callback)
            ---
            increment/decrement properties on an user record in engage

            usage:

                mixpanel.people.increment('bob', 'page_views', 1);

                // or, for convenience, if you're just incrementing a counter by 1, you can
                // simply do
                mixpanel.people.increment('bob', 'page_views');

                // to decrement a counter, pass a negative number
                mixpanel.people.increment('bob', 'credits_left', -1);

                // like mixpanel.people.set(), you can increment multiple properties at once:
                mixpanel.people.increment('bob', {
                    counter1: 1,
                    counter2: 3,
                    counter3: -2
                });
        */
        increment: function(distinct_id, prop, by, callback) {
            var $add = {};

            if (typeof(prop) === 'object') {
                callback = by;
                Object.keys(prop).forEach(function(key) {
                    var val = prop[key];

                    if (isNaN(parseFloat(val))) {
                        if (metrics.config.debug) {
                            console.error("Invalid increment value passed to mixpanel.people.increment - must be a number");
                            console.error("Passed " + key + ":" + val);
                        }
                        return;
                    } else {
                        $add[key] = val;
                    }
                });
            } else {
                if (!by) { by = 1; }
                $add[prop] = by;
            }

            var data = {
                '$add': $add,
                '$token': metrics.token,
                '$distinct_id': distinct_id
            };

            if(metrics.config.debug) {
                console.log("Sending the following data to Mixpanel (Engage):");
                console.log(data);
            }

            metrics.send_request('/engage', data, callback);
        },

        /**
            people.append(distinct_id, prop, value, callback)
            ---
            Append a value to a list-valued people analytics property.

            usage:

                // append a value to a list, creating it if needed
                mixpanel.people.append('pages_visited', 'homepage');

                // like mixpanel.people.set(), you can append multiple properties at once:
                mixpanel.people.append({
                    list1: 'bob',
                    list2: 123
                });
        */
        append: function(distinct_id, prop, value, callback) {
            var $append = {};

            if (typeof(prop) === 'object') {
                callback = value;
                Object.keys(prop).forEach(function(key) {
                    $append[key] = prop[key];
                });
            } else {
                $append[prop] = value;
            }

            var data = {
                '$append': $append,
                '$token': metrics.token,
                '$distinct_id': distinct_id
            };

            if(metrics.config.debug) {
                console.log("Sending the following data to Mixpanel (Engage):");
                console.log(data);
            }

            metrics.send_request('/engage', data, callback);
        },

        /**
            people.track_charge(distinct_id, amount, properties, callback)
            ---
            Record that you have charged the current user a certain
            amount of money.

            usage:

                // charge a user $29.99
                mixpanel.people.track_charge('bob', 29.99);

                // charge a user $19 on the 1st of february
                mixpanel.people.track_charge('bob', 19, { '$time': new Date('feb 1 2012') });
        */
        track_charge: function(distinct_id, amount, properties, callback) {
            var $append = {};

            if (!properties) { properties = {}; }

            if (typeof(amount) !== 'number') {
                amount = parseFloat(amount);
                if (isNaN(amount)) {
                    console.error("Invalid value passed to mixpanel.people.track_charge - must be a number");
                    return;
                }
            }

            properties.$amount = amount;

            if (properties.hasOwnProperty('$time')) {
                var time = properties.$time;
                if (Object.prototype.toString.call(time) === '[object Date]') {
                    properties.$time = time.toISOString();
                }
            }

            var data = {
                '$append': { '$transactions': properties },
                '$token': metrics.token,
                '$distinct_id': distinct_id
            };

            if(metrics.config.debug) {
                console.log("Sending the following data to Mixpanel (Engage):");
                console.log(data);
            }

            metrics.send_request('/engage', data, callback);
        },

        /**
            people.clear_charges(distinct_id, callback)
            ---
            Clear all the current user's transactions.

            usage:

                mixpanel.people.clear_charges('bob');
        */
        clear_charges: function(distinct_id, callback) {
            var data = {
                '$set': { '$transactions': [] },
                '$token': metrics.token,
                '$distinct_id': distinct_id
            };

            if(metrics.config.debug) {
                console.log("Clearing this user's charges:", distinct_id);
            }

            metrics.send_request('/engage', data, callback);
        },

        /**
            people.delete_user(distinct_id, callback)
            ---
            delete an user record in engage

            usage:

                mixpanel.people.delete_user('bob');
        */
        delete_user: function(distinct_id, callback) {
            var data = {
                '$delete': distinct_id,
                '$token': metrics.token,
                '$distinct_id': distinct_id
            };

            if(metrics.config.debug) {
                console.log("Deleting the user from engage:", distinct_id);
            }

            metrics.send_request('/engage', data, callback);
        },

        /**
         people.unset(distinct_id, prop, callback)
         ---
         delete a property on an user record in engage

         usage:

            mixpanel.people.unset('bob', 'page_views');

            mixpanel.people.unset('bob', ['page_views', 'last_login']);
         */
        unset: function(distinct_id, prop, callback) {
            var $unset = [];

            if (util.isArray(prop)) {
                $unset = prop;
            } else if (typeof(prop) === 'string') {
                $unset = [prop];
            } else {
                if (metrics.config.debug) {
                    console.error("Invalid argument passed to mixpanel.people.unset - must be a string or array");
                    console.error("Passed: " + prop);
                }
                return;
            }

            data = {
                '$unset': $unset,
                '$token': metrics.token,
                '$distinct_id': distinct_id
            };

            if(metrics.config.debug) {
                console.log("Sending the following data to Mixpanel (Engage):");
                console.log(data);
            }

            metrics.send_request('/engage', data, callback);
        }
    };

    /**
        set_config(config)
        ---
        Modifies the mixpanel config

        config:object       an object with properties to override in the
                            mixpanel client config
    */
    metrics.set_config = function(config) {
        metrics.config = _extend(metrics.config, config);
    };

    /**
        _extend(obj1, obj2)
        ---
        Copies properties from obj2 to obj1
    */

    _extend = function(obj1, obj2) {
        for (var prop in obj2) {
            if (obj2.hasOwnProperty(prop)) {
                obj1[prop] = obj2[prop];
            }
        }

        return obj1;
    };


    if (config) {
        metrics.set_config(config);
    }

    return metrics;
};

// module exporting
module.exports = {
    Client: function(token) {
        console.warn("The function `Client(token)` is deprecated.  It is now called `init(token)`.");
        return create_client(token);
    },
    init: create_client
};

},{"buffer":114,"http":119,"querystring":129,"util":145}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvY29udHJvbGxlcnMvY29udGVudF9wYWdlLmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy9oZWxwZXJzL2hhbmRsZWJhcnNfaGVscGVycy5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvaGVscGVycy9oYW5kbGViYXJzX3BhcnRpYWxzLmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy9tb2RlbHMvYW5hbHl0aWNzLmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy9tb2RlbHMvYnJvd3Nlci5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvbW9kZWxzL2J1dHRvbl9tZXRyaWNzLmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy9tb2RlbHMvY2l0aWVzLmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy9tb2RlbHMvZmFjZWJvb2tfc3RhdHMuY29mZmVlIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC9zY3JpcHRzL21vZGVscy9nZW9sb2NhdGlvbi5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvbW9kZWxzL2dvb2dsZV9kb21haW5zLmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy9tb2RlbHMvZ29vZ2xlX3BsdXNfc3RhdHMuY29mZmVlIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC9zY3JpcHRzL21vZGVscy9odHRwX3N0YXR1cy5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvbW9kZWxzL2h0dHBfc3RhdHVzX2xpc3QuY29mZmVlIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC9zY3JpcHRzL21vZGVscy9rZXl3b3JkX2RpZmZpY3VsdHkuY29mZmVlIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC9zY3JpcHRzL21vZGVscy9tb3pfY29scy5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvbW9kZWxzL29uYm9hcmRpbmcuY29mZmVlIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC9zY3JpcHRzL21vZGVscy9vbmJvYXJkaW5nX3RpcC5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvbW9kZWxzL3BhZ2UuY29mZmVlIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC9zY3JpcHRzL21vZGVscy9wYWdlX2F0dHJpYnV0ZXMuY29mZmVlIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC9zY3JpcHRzL21vZGVscy9wYWdlX2VsZW1lbnQuY29mZmVlIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC9zY3JpcHRzL21vZGVscy9wYWdlX2VsZW1lbnRzLmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy9tb2RlbHMvcHJvZmlsZS5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvbW9kZWxzL3Byb2ZpbGVzLmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy9tb2RlbHMvcmVnaW9ucy5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvbW9kZWxzL3NlbWFudGljcy5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvbW9kZWxzL3NlcnBfYXR0cmlidXRlcy5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvbW9kZWxzL3NlcnBfcmVzdWx0c19tZXRyaWNzLmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy9tb2RlbHMvc2VycF90b29sYmFyLmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy9tb2RlbHMvc2V0dGluZ3MuY29mZmVlIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC9zY3JpcHRzL21vZGVscy90YWJfc2V0dGluZ3MuY29mZmVlIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC9zY3JpcHRzL21vZGVscy90b29sdGlwLmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy9tb2RlbHMvdHdpdHRlci5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvbW9kZWxzL3R3aXR0ZXJfdXNlci5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvbW9kZWxzL3VybF9tZXRyaWNzLmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy9tb2RlbHMvdXNlci5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvdmlld3MvYWRkcmVzc19iYXJfaGlnaGxpZ2h0LmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy92aWV3cy9iYXNlX2RpYWxvZy5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvdmlld3MvYmFzZV9lbGVtZW50LmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy92aWV3cy9iYXNlX3BhbmVsX3RhYi5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvdmlld3MvYmFzZV92aWV3LmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy92aWV3cy9icm93c2VyX2J1dHRvbi5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvdmlld3MvYnV0dG9uX25vdGlmaWNhdGlvbi5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvdmlld3MvYnV0dG9uX25vdGlmaWNhdGlvbl9lbGVtZW50LmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy92aWV3cy9jb250ZW50X3BhZ2UuY29mZmVlIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC9zY3JpcHRzL3ZpZXdzL2V2ZW50X2Rpc3BhdGNoZXIuY29mZmVlIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC9zY3JpcHRzL3ZpZXdzL2hlbHBfZGlhbG9nLmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy92aWV3cy9oZWxwX3ZpZXcuY29mZmVlIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC9zY3JpcHRzL3ZpZXdzL2hpZ2hsaWdodGVyLmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy92aWV3cy9odHRwX3N0YXR1cy5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvdmlld3MvaW5ib3VuZF9saW5rcy5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvdmlld3MvaW5mb19wYW5lbC5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvdmlld3Mva2V5d29yZF9kaWZmaWN1bHR5LmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy92aWV3cy9rZXl3b3JkX2RpZmZpY3VsdHlfZWxlbWVudC5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvdmlld3MvbGlua3NfcGFuZWwuY29mZmVlIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC9zY3JpcHRzL3ZpZXdzL21vemJhcl9lbGVtZW50LmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy92aWV3cy9vbmJvYXJkaW5nX2RpYWxvZy5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvdmlld3Mvb25ib2FyZGluZ190aXAuY29mZmVlIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC9zY3JpcHRzL3ZpZXdzL29uYm9hcmRpbmdfdGlwX2VsZW1lbnQuY29mZmVlIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC9zY3JpcHRzL3ZpZXdzL29uYm9hcmRpbmdfdmlldy5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvdmlld3Mvb3ZlcmxheS5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvdmlld3MvcGFnZV9hdHRyaWJ1dGVzLmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy92aWV3cy9wYWdlX2VsZW1lbnRzLmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy92aWV3cy9wYWdlX3Rvb2xiYXIuY29mZmVlIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC9zY3JpcHRzL3ZpZXdzL3BhbmVsX3ZpZXcuY29mZmVlIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC9zY3JpcHRzL3ZpZXdzL3Byb2ZpbGVfZGlhbG9nLmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy92aWV3cy9wcm9maWxlX2VkaXQuY29mZmVlIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC9zY3JpcHRzL3ZpZXdzL3Byb2ZpbGVzX2Ryb3BfZG93bi5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvdmlld3MvcHJvZmlsZXNfbGlzdC5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvdmlld3Mvc2VtYW50aWNzLmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy92aWV3cy9zZXJwX2VsZW1lbnQuY29mZmVlIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC9zY3JpcHRzL3ZpZXdzL3NlcnBfaXRlbS5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvdmlld3Mvc2VycF90b29sYmFyLmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy92aWV3cy9zZXR0aW5nc19kaWFsb2cuY29mZmVlIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC9zY3JpcHRzL3ZpZXdzL3NldHRpbmdzX2VkaXQuY29mZmVlIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC9zY3JpcHRzL3ZpZXdzL3NvY2lhbF9zdGF0cy5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvdmlld3MvdG9vbGJhci5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvdmlld3MvdG9vbHRpcC5jb2ZmZWUiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3NjcmlwdHMvdmlld3MvdG9vbHRpcF9lbGVtZW50LmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvc2NyaXB0cy92aWV3cy90d2l0dGVyX2NhcmRzLmNvZmZlZSIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvdGVtcGxhdGVzL2FkZHJlc3NfYmFyX2hpZ2hsaWdodC5oYnMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3RlbXBsYXRlcy9iYXNlX2VsZW1lbnQuaGJzIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC90ZW1wbGF0ZXMvYnV0dG9uX25vdGlmaWNhdGlvbi5oYnMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3RlbXBsYXRlcy9oZWxwX2RpYWxvZy5oYnMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3RlbXBsYXRlcy9odHRwX3N0YXR1c190YWIuaGJzIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC90ZW1wbGF0ZXMvaW5ib3VuZF9saW5rcy5oYnMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3RlbXBsYXRlcy9pbmZvX3BhbmVsLmhicyIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvdGVtcGxhdGVzL2tleXdvcmRfZGlmZmljdWx0eS5oYnMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3RlbXBsYXRlcy9saW5rc19wYW5lbC5oYnMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3RlbXBsYXRlcy9vbmJvYXJkaW5nX2RpYWxvZy5oYnMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3RlbXBsYXRlcy9vbmJvYXJkaW5nX3RpcC5oYnMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3RlbXBsYXRlcy9wYWdlX2VsZW1lbnRzLmhicyIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvdGVtcGxhdGVzL3BhZ2VfdG9vbGJhci5oYnMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3RlbXBsYXRlcy9wYXJ0aWFscy9jbG9zZV9pY29uLmhicyIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvdGVtcGxhdGVzL3BhcnRpYWxzL2RvY2tfaWNvbi5oYnMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3RlbXBsYXRlcy9wYXJ0aWFscy9leHBvcnRfaWNvbi5oYnMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3RlbXBsYXRlcy9wYXJ0aWFscy9oaWdobGlnaHRfaWNvbi5oYnMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3RlbXBsYXRlcy9wYXJ0aWFscy9sb2NrZWRfaWNvbi5oYnMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3RlbXBsYXRlcy9wYXJ0aWFscy9vc2VfaWNvbi5oYnMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3RlbXBsYXRlcy9wYXJ0aWFscy9wYWdlX2luZm9faWNvbi5oYnMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3RlbXBsYXRlcy9wYXJ0aWFscy9zZXR0aW5nc19pY29uLmhicyIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvdGVtcGxhdGVzL3Byb2ZpbGVfZWRpdC5oYnMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3RlbXBsYXRlcy9wcm9maWxlX2VkaXRfY2l0aWVzLmhicyIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvdGVtcGxhdGVzL3Byb2ZpbGVfZWRpdF9yZWdpb25zLmhicyIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvdGVtcGxhdGVzL3Byb2ZpbGVzX2xpc3QuaGJzIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC90ZW1wbGF0ZXMvc2VtYW50aWNzLmhicyIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvdGVtcGxhdGVzL3NlcnBfaXRlbS5oYnMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3RlbXBsYXRlcy9zZXJwX3Rvb2xiYXIuaGJzIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC90ZW1wbGF0ZXMvc2V0dGluZ3NfZGlhbG9nLmhicyIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvdGVtcGxhdGVzL3NvY2lhbC5oYnMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvYXBwL3RlbXBsYXRlcy90b29sYmFyLmhicyIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9hcHAvdGVtcGxhdGVzL3Rvb2x0aXAuaGJzIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL2FwcC90ZW1wbGF0ZXMvdHdpdHRlcl9jYXJkcy5oYnMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbGliL19lbXB0eS5qcyIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL25vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL25vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaXMtYXJyYXkvaW5kZXguanMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2h0dHAtYnJvd3NlcmlmeS9pbmRleC5qcyIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaHR0cC1icm93c2VyaWZ5L2xpYi9yZXF1ZXN0LmpzIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL25vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9odHRwLWJyb3dzZXJpZnkvbGliL3Jlc3BvbnNlLmpzIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL25vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9odHRwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL0Jhc2U2NC9iYXNlNjQuanMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL25vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9ub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL25vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcyIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL25vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9ub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvaW5kZXguanMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL25vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMuanMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvbm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy5ydW50aW1lLmpzIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL25vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvYmFzZS5qcyIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9ub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL2NvbXBpbGVyL2FzdC5qcyIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9ub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL2NvbXBpbGVyL2Jhc2UuanMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvbm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9jb21waWxlci9jb21waWxlci5qcyIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9ub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL2NvbXBpbGVyL2phdmFzY3JpcHQtY29tcGlsZXIuanMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvbm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9jb21waWxlci9wYXJzZXIuanMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvbm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9jb21waWxlci9wcmludGVyLmpzIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL25vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2Rpc3QvY2pzL2hhbmRsZWJhcnMvY29tcGlsZXIvdmlzaXRvci5qcyIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9ub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL2V4Y2VwdGlvbi5qcyIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9ub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL3J1bnRpbWUuanMiLCIvVXNlcnMvc3RldmUvc3JjL21vei9tb3piYXItdjMvbm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9zYWZlLXN0cmluZy5qcyIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9ub2RlX21vZHVsZXMvaGFuZGxlYmFycy9kaXN0L2Nqcy9oYW5kbGViYXJzL3V0aWxzLmpzIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL25vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9pbmRleC5qcyIsIi9Vc2Vycy9zdGV2ZS9zcmMvbW96L21vemJhci12My9ub2RlX21vZHVsZXMvaGFuZGxlYmFycy9ydW50aW1lLmpzIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL25vZGVfbW9kdWxlcy9oYnNmeS9ydW50aW1lLmpzIiwiL1VzZXJzL3N0ZXZlL3NyYy9tb3ovbW96YmFyLXYzL25vZGVfbW9kdWxlcy9taXhwYW5lbC9saWIvbWl4cGFuZWwtbm9kZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBLENBQUMsS0FBRCxDQUFDLEdBQUQsVUFBQzs7Ozs7QUNBRCxJQUFBLFlBQUE7O0FBQUEsQ0FBQSxFQUFJLElBQUEsS0FBQTs7QUFDSixDQURBLEVBQ0ksSUFBQSxDQUFBOztBQUNKLENBRkEsRUFFYSxJQUFBLEdBQWIsS0FBYTs7QUFXYixDQWJBLENBYW9DLENBQUEsRUFBQSxFQUFBLENBQXBDLENBQXFDLENBQTNCLElBQVY7Q0FDRSxDQUFPLENBQThDLENBQTlDLENBQXFDLENBQVIsQ0FBdEIsRUFBUCxDQUFxQyxZQUFyQztDQUQyQjs7QUFnQnBDLENBN0JBLENBNkJvQyxDQUFBLElBQUEsQ0FBcEMsQ0FBcUMsQ0FBM0IsR0FBMEIsQ0FBcEM7Q0FDRSxLQUFBLHdCQUFBO0NBQUEsQ0FBQSxDQUFRLENBQVksQ0FBcEIsRUFBZTtDQUFmLENBQ0EsQ0FBTyxDQUFQLEdBQWM7Q0FEZCxDQUdBLENBQVUsRUFBZ0MsRUFBMUMsSUFBVSxFQUFhO0NBSHZCLENBSUEsQ0FBYyxJQUFILENBQVgsYUFBVztDQUVJLEVBQTRCLENBQXZDLENBQXVCLEVBQUEsQ0FBQSxDQUF2QixDQUFVLENBQVYsTUFBdUI7Q0FQTzs7QUFVcEMsQ0F2Q0EsQ0F1Q3VDLENBQUEsRUFBQSxFQUFBLEVBQUMsQ0FBOUIsQ0FBVixHQUFBO0FBQzBCLENBQXhCLENBQUEsRUFBQSxDQUF3QixNQUFBO0NBQWhCLENBQVIsRUFBQSxHQUFPLElBQVA7SUFEcUM7Q0FBQTs7QUFHdkMsQ0ExQ0EsQ0EwQ3FDLENBQUEsSUFBQSxFQUFyQyxDQUFVLElBQVY7Q0FDRSxDQUFBLEVBQW9CLENBQU07Q0FBbEIsQ0FB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VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNQQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWhDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBOzs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0OUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMUdBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNzZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIihyZXF1aXJlICd2aWV3cy9jb250ZW50X3BhZ2UnKS5pbml0aWFsaXplKCkucmVuZGVyKClcbiIsIl8gPSByZXF1aXJlICd1bmRlcnNjb3JlJ1xuJCA9IHJlcXVpcmUgJ2pxdWVyeSdcbkhhbmRsZWJhcnMgPSByZXF1aXJlICdoYnNmeS9ydW50aW1lJ1xuXG4jIHNlbGVjdCBhbiBvcHRpb24gd2hlbiB0aGUgb3B0aW9ucyBhcmUgYSBzdGF0aWMgbGlzdFxuIyBFeGFtcGxlOlxuIyA8c2VsZWN0IG5hbWU9XCJlbmdpbmVcIj5cbiMgICB7eyNzZWxlY3QgZW5naW5lfX1cbiMgICAgIDxvcHRpb24gdmFsdWU9XCJnb29nbGVcIj5Hb29nbGU8L29wdGlvbj5cbiMgICAgIDxvcHRpb24gdmFsdWU9XCJiaW5nXCI+QmluZzwvb3B0aW9uPlxuIyAgICAgPG9wdGlvbiB2YWx1ZT1cInlhaG9vXCI+WWFob288L29wdGlvbj5cbiMgICB7ey9zZWxlY3R9fVxuIyA8L3NlbGVjdD5cbkhhbmRsZWJhcnMucmVnaXN0ZXJIZWxwZXIgJ3NlbGVjdCcsICh2YWx1ZSwgb3B0aW9ucykgLT5cbiAgcmV0dXJuIG9wdGlvbnMuZm4odGhpcykucmVwbGFjZSBuZXcgUmVnRXhwKFwidmFsdWU9XFxcIiN7dmFsdWV9XFxcIlwiKSxcbiAgICAnJCYgc2VsZWN0ZWQ9c2VsZWN0ZWQnXG5cblxuIyBHZW5lcmF0ZSBhbmQgc2VsZWN0IGFuIG9wdGlvbiB3aGVuIHRoZSBvcHRpb25zIGxpc3QgaXMgZHlhbm1pY1xuIyBFeGFtcGxlOlxuIyB7eyNjaXRpZXN9fVxuIyAgIHt7b3B0aW9uIC4uL2NpdHl9fVxuIyB7ey9jaXRpZXN9fVxuXG4jIG9yIHdpdGggZXhwbGljaXQgdmFsdWUvdGV4dDpcbiMge3sjcmVnaW9uc319XG4jICAge3tvcHRpb24gLi4vcmVnaW9uIHZhbHVlPWNvZGUgdGV4dD1uYW1lfX1cbiMge3svcmVnaW9uc319XG5cbkhhbmRsZWJhcnMucmVnaXN0ZXJIZWxwZXIgJ29wdGlvbicsIChzZWxlY3RlZFZhbHVlLCBvcHRpb25zKSAtPlxuICB2YWx1ZSA9IG9wdGlvbnMuaGFzaC52YWx1ZSBvciB0aGlzXG4gIHRleHQgPSBvcHRpb25zLmhhc2gudGV4dCBvciB0aGlzXG5cbiAgaXNNYXRjaCA9IHNlbGVjdGVkVmFsdWU/LnRvTG93ZXJDYXNlKCkgaXMgdmFsdWUudG9Mb3dlckNhc2UoKVxuICBzZWxlY3RlZCA9IGlmIGlzTWF0Y2ggdGhlbiAnc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiJyBlbHNlICcnXG5cbiAgbmV3IEhhbmRsZWJhcnMuU2FmZVN0cmluZyBcIjxvcHRpb24gdmFsdWU9JyN7dmFsdWV9J1xuICAgICN7c2VsZWN0ZWR9PiN7dGV4dH08L29wdGlvbj5cIlxuXG5IYW5kbGViYXJzLnJlZ2lzdGVySGVscGVyICdpZkRlZmluZWQnLCAodmFsdWUsIG9wdGlvbnMpIC0+XG4gIG9wdGlvbnMuZm4odGhpcykgdW5sZXNzIF8uaXNVbmRlZmluZWQgdmFsdWVcblxuSGFuZGxlYmFycy5yZWdpc3RlckhlbHBlciAnaWZFcXVhbCcsICh2MSwgdjIsIG9wdGlvbnMpIC0+XG4gIG9wdGlvbnMuZm4odGhpcykgaWYgdjEgaXMgdjJcbiIsIkhhbmRsZWJhcnMgPSByZXF1aXJlICdoYnNmeS9ydW50aW1lJ1xuXG5IYW5kbGViYXJzLnJlZ2lzdGVyUGFydGlhbCAncGFnZS1pbmZvLWljb24nLFxuICByZXF1aXJlICd0ZW1wbGF0ZXMvcGFydGlhbHMvcGFnZV9pbmZvX2ljb24nXG5cbkhhbmRsZWJhcnMucmVnaXN0ZXJQYXJ0aWFsICdoaWdobGlnaHQtaWNvbicsXG4gIHJlcXVpcmUgJ3RlbXBsYXRlcy9wYXJ0aWFscy9oaWdobGlnaHRfaWNvbidcblxuSGFuZGxlYmFycy5yZWdpc3RlclBhcnRpYWwgJ2xvY2tlZC1pY29uJyxcbiAgcmVxdWlyZSAndGVtcGxhdGVzL3BhcnRpYWxzL2xvY2tlZF9pY29uJ1xuXG5IYW5kbGViYXJzLnJlZ2lzdGVyUGFydGlhbCAnc2V0dGluZ3MtaWNvbicsXG4gIHJlcXVpcmUgJ3RlbXBsYXRlcy9wYXJ0aWFscy9zZXR0aW5nc19pY29uJ1xuXG5IYW5kbGViYXJzLnJlZ2lzdGVyUGFydGlhbCAnZG9jay1pY29uJyxcbiAgcmVxdWlyZSAndGVtcGxhdGVzL3BhcnRpYWxzL2RvY2tfaWNvbidcblxuSGFuZGxlYmFycy5yZWdpc3RlclBhcnRpYWwgJ2Nsb3NlLWljb24nLFxuICByZXF1aXJlICd0ZW1wbGF0ZXMvcGFydGlhbHMvY2xvc2VfaWNvbidcblxuSGFuZGxlYmFycy5yZWdpc3RlclBhcnRpYWwgJ29zZS1pY29uJyxcbiAgcmVxdWlyZSAndGVtcGxhdGVzL3BhcnRpYWxzL29zZV9pY29uJ1xuXG5IYW5kbGViYXJzLnJlZ2lzdGVyUGFydGlhbCAnZXhwb3J0LWljb24nLFxuICByZXF1aXJlICd0ZW1wbGF0ZXMvcGFydGlhbHMvZXhwb3J0X2ljb24nXG4iLCJfID0gcmVxdWlyZSAndW5kZXJzY29yZSdcbntNb2RlbH0gPSByZXF1aXJlICdiYWNrYm9uZSdcbk1peHBhbmVsID0gcmVxdWlyZSAnbWl4cGFuZWwnXG5TZXR0aW5ncyA9IHJlcXVpcmUgJ21vZGVscy9zZXR0aW5ncydcblBhZ2UgPSByZXF1aXJlICdtb2RlbHMvcGFnZSdcblVzZXIgPSByZXF1aXJlICdtb2RlbHMvdXNlcidcbkJyb3dzZXIgPSByZXF1aXJlICdtb2RlbHMvYnJvd3NlcidcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBBbmFseXRpY3MgZXh0ZW5kcyBNb2RlbFxuICBAYW5hbHl0aWNzOiBudWxsXG4gIEBnZXRJbnN0YW5jZTogLT5cbiAgICBAYW5hbHl0aWNzID89IG5ldyBBbmFseXRpY3NcblxuICAjIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZXR3ZWVuIHRyaWdnZXJpbmcgb2YgYWN0aXZlIHVzZXJcbiAgIyBldmVudHMgKDI0IGhvdXJzKVxuICBBQ1RJVkVfVVNFUl9USFJPVFRMRV9NUzogMjQgKiA2MCAqIDYwICogMTAwMFxuXG4gIHNldHRpbmdzOiBudWxsXG4gIHVzZXI6IG51bGxcbiAgIyBzb21ldGltZXMgd2UgdHJ5IHRvIHRyYWNrIGV2ZW50cyBiZWZvcmUgc2V0dGluZ3MgYXJlXG4gICMgZnVsbHkgbG9hZGVkLiAgIFF1ZXVlIHRoZW0gdXAgdW50aWwgd2UgaGF2ZSBhIGRpc3RpbmN0IGlkLlxuICBldmVudFF1ZXVlOiBbXVxuXG4gICMgZG9uJ3QgcmVmZXJlbmNlIHRoaXMgZGlyZWN0bHk7IHVzZSBAbWl4cGFuZWwoKSBpbnN0ZWFkXG4gIF9taXhwYW5lbDogbnVsbFxuXG4gIGluaXRpYWxpemU6IC0+XG4gICAgQHNldHRpbmdzID0gU2V0dGluZ3MuZ2V0SW5zdGFuY2UoKVxuICAgIEB1c2VyID0gVXNlci5nZXRJbnN0YW5jZSgpXG5cbiAgICBAbGlzdGVuVG8gQHNldHRpbmdzLCAnY2hhbmdlOm1peHBhbmVsSWQnLCBAc3VibWl0UXVldWVkRXZlbnRzXG4gICAgQGxpc3RlblRvIEB1c2VyLCAnY2hhbmdlOmlzUHJvJywgQHVwZGF0ZVBlcnNvblxuICAgIEBsaXN0ZW5UbyBAc2V0dGluZ3MsICdjaGFuZ2U6aXNNb3piYXJPbiBjaGFuZ2U6aXNCdXR0b25PbicsIEB1cGRhdGVQZXJzb25cblxuICAjIGxhenkgaW5pdCBtaXhwYW5lbC4gICBNaXhwYW5lbC5pbml0IGRvZXMgYSBuZXR3b3JrIGNhbGwsXG4gICMgd2hpY2ggd2UgZG9uJ3Qgd2FudCB0byBkbyB3aGVuIHRoZSBtb3piYXIgaXMgb2ZmIVxuICBtaXhwYW5lbDogLT5cbiAgICBAX21peHBhbmVsID89IE1peHBhbmVsLmluaXQgJzY1NDAwM2M2ZGRkMDNlODg3NjQxMzhlNjAwNDUzYTY3JyxcbiAgICAgIHJlcXVlc3Rfb3B0aW9uczogc2NoZW1lOiAnaHR0cHMnXG5cbiAgdHJhY2tFdmVudDogKG5hbWUsIGV4dHJhQXR0cnMpIC0+XG4gICAgYXR0cnMgPSBAZ2V0RXZlbnRBdHRyaWJ1dGVzKClcbiAgICBpZiAhYXR0cnMuZGlzdGluY3RfaWRcbiAgICAgIEBldmVudFF1ZXVlLnB1c2ggbmFtZTogbmFtZSwgYXR0cnM6IGV4dHJhQXR0cnNcbiAgICAgIHJldHVyblxuXG4gICAgYXR0cnMgPSBfLmV4dGVuZChleHRyYUF0dHJzLCBhdHRycykgaWYgZXh0cmFBdHRyc1xuICAgIEBtaXhwYW5lbCgpLnRyYWNrIG5hbWUsIGF0dHJzXG5cbiAgdHJhY2tOZXdJbnN0YWxsOiAtPlxuICAgIGNvbnNvbGUubG9nICd0cmFja2luZyBuZXcgaW5zdGFsbCEnXG4gICAgQHRyYWNrRXZlbnQgJ05ldyBJbnN0YWxsJ1xuXG4gIHRyYWNrQWN0aXZlVXNlcjogLT5cbiAgICBAdXBkYXRlUGVyc29uKClcblxuICAgIGxhc3RBY3RpdmVVc2VyID0gQHNldHRpbmdzLmdldCAnbGFzdE1peHBhbmVsQWN0aXZlVXNlcidcbiAgICByZXR1cm4gaWYgRGF0ZS5ub3coKSAtIGxhc3RBY3RpdmVVc2VyIDwgQEFDVElWRV9VU0VSX1RIUk9UVExFX01TXG5cbiAgICBAdHJhY2tFdmVudCAnQWN0aXZlIFVzZXInXG4gICAgQHNldHRpbmdzLnNldCAnbGFzdE1peHBhbmVsQWN0aXZlVXNlcicsIERhdGUubm93KClcblxuICB0cmFja1BhbmVsVmlldzogKHBhbmVsKSAtPlxuICAgIEB0cmFja0V2ZW50ICdQYW5lbCBWaWV3JyxcbiAgICAgIHBhbmVsOiBwYW5lbFxuICAgICAgdmlld2VkT25ib2FyZGluZzogQGhhc1VzZXJTZWVuSGlnaGxpZ2h0ICdzaG93LWluZm8tcGFuZWwnXG5cbiAgdHJhY2tUb2dnbGVEb2NrUG9zaXRpb246IC0+XG4gICAgQHRyYWNrRXZlbnQgJ1RvZ2dsZSBEb2NrIFBvc2l0aW9uJ1xuICAgIEBtaXhwYW5lbCgpLnBlb3BsZS5pbmNyZW1lbnQgQHNldHRpbmdzLmdldCgnbWl4cGFuZWxJZCcpLFxuICAgICAgJ1RvZ2dsZSBEb2NrIFBvc2l0aW9uJ1xuXG4gIHRyYWNrS2V5d29yZERpZmZpY3VsdHk6IC0+XG4gICAgQHRyYWNrRXZlbnQgJ0tleXdvcmQgRGlmZmljdWx0eScsXG4gICAgICB2aWV3ZWRPbmJvYXJkaW5nOiBAaGFzVXNlclNlZW5IaWdobGlnaHQgJ2FjdGl2YXRlLWtleXdvcmQtZGlmZmljdWx0eSdcblxuICAgIEBtaXhwYW5lbCgpLnBlb3BsZS5pbmNyZW1lbnQgQHNldHRpbmdzLmdldCgnbWl4cGFuZWxJZCcpLFxuICAgICAgJ0tleXdvcmQgRGlmZmljdWx0eSdcblxuICB0cmFja0V4cG9ydDogLT5cbiAgICBAdHJhY2tFdmVudCAnU0VSUCBFeHBvcnQnLFxuICAgICAgdmlld2VkT25ib2FyZGluZzogQGhhc1VzZXJTZWVuSGlnaGxpZ2h0ICdleHBvcnQnXG5cbiAgICBAbWl4cGFuZWwoKS5wZW9wbGUuaW5jcmVtZW50IEBzZXR0aW5ncy5nZXQoJ21peHBhbmVsSWQnKSwgJ1NFUlAgRXhwb3J0J1xuXG4gIHRyYWNrSW5pdGlhdGVPbmJvYXJkaW5nOiAtPlxuICAgIEB0cmFja0V2ZW50ICdJbml0aWF0ZWQgT25ib2FyZGluZyB2aWEgSGVscCdcblxuICB0cmFja0Nsb3NlT25ib2FyZGluZzogLT5cbiAgICBAdHJhY2tFdmVudCAnQ2xvc2VkIE9uYm9hcmRpbmcnXG5cbiAgdHJhY2tPbmJvYXJkaW5nQ29tcGxldGU6IC0+XG4gICAgQHRyYWNrRXZlbnQgJ0NvbXBsZXRlZCBPbm9iYXJkaW5nJ1xuXG4gIGdldEV2ZW50QXR0cmlidXRlczogLT5cbiAgICBkaXN0aW5jdF9pZDogQHNldHRpbmdzLmdldCgnbWl4cGFuZWxJZCcpXG4gICAgdHlwZTogaWYgUGFnZS5pc1NlcnAoKSB0aGVuICdzZXJwJyBlbHNlICdub24tc2VycCdcbiAgICBpc1BybzogQGdldFVzZXJUeXBlKClcbiAgICBpc0xpZ2h0VGhlbWU6IEBzZXR0aW5ncy5nZXQgJ2lzTGlnaHRUaGVtZSdcbiAgICBpc0RvY2tlZE9uQm90dG9tOiBAc2V0dGluZ3MuZ2V0ICdpc0RvY2tlZE9uQm90dG9tJ1xuICAgIGJyb3dzZXI6IEJyb3dzZXIuYnJvd3Nlck5hbWUoKVxuICAgIG9zOiBCcm93c2VyLm9zTmFtZSgpXG4gICAgcGFnZU9uYm9hcmRpbmdTdGVwOiBAc2V0dGluZ3MuZ2V0KCdvbmJvYXJkaW5nJykucGFnZVN0ZXBcbiAgICBzZXJwT25ib2FyZGluZ1N0ZXA6IEBzZXR0aW5ncy5nZXQoJ29uYm9hcmRpbmcnKS5zZXJwU3RlcFxuXG4gIHVwZGF0ZVBlcnNvbjogLT5cbiAgICByZXR1cm4gdW5sZXNzIEBzZXR0aW5ncy5nZXQgJ2lzQnV0dG9uT24nXG5cbiAgICBAbWl4cGFuZWwoKS5wZW9wbGUuc2V0IEBzZXR0aW5ncy5nZXQoJ21peHBhbmVsSWQnKSxcbiAgICAgIHR5cGU6IEBnZXRVc2VyVHlwZSgpXG4gICAgICBpc01vemJhck9uOiBAc2V0dGluZ3MuZ2V0ICdpc01vemJhck9uJ1xuICAgICAgaXNEb2NrZWRPbkJvdHRvbTogQHNldHRpbmdzLmdldCAnaXNEb2NrZWRPbkJvdHRvbSdcbiAgICAgICRsYXN0X25hbWU6IEB1c2VyLmdldCAnZGlzcGxheV9uYW1lJ1xuICAgICAgYnJvd3NlcjogQnJvd3Nlci5icm93c2VyTmFtZSgpXG4gICAgICBvczogQnJvd3Nlci5vc05hbWUoKVxuICAgICAgcGFnZU9uYm9hcmRpbmdTdGVwOiBAc2V0dGluZ3MuZ2V0KCdvbmJvYXJkaW5nJykucGFnZVN0ZXBcbiAgICAgIHNlcnBPbmJvYXJkaW5nU3RlcDogQHNldHRpbmdzLmdldCgnb25ib2FyZGluZycpLnNlcnBTdGVwXG4gICAgICBleHRlbnNpb25WZXJzaW9uOiBAc2V0dGluZ3MuZ2V0ICdleHRlbnNpb25WZXJzaW9uJ1xuXG4gIGdldFVzZXJUeXBlOiAtPlxuICAgIGlmIEB1c2VyLmdldCAnaXNQcm8nIHRoZW4gJ3BhaWQnIGVsc2UgJ2ZyZWUnXG5cbiAgaGFzVXNlclNlZW5IaWdobGlnaHQ6IChoaWdobGlnaHQpIC0+XG4gICAgdmlzaXRlZCA9IEBzZXR0aW5ncy5nZXQoJ29uYm9hcmRpbmcnKS52aWV3ZWRIaWdobGlnaHRzXG4gICAgdmlzaXRlZC5pbmRleE9mKGhpZ2hsaWdodCkgaXNudCAtMVxuXG4gIHN1Ym1pdFF1ZXVlZEV2ZW50czogLT5cbiAgICByZXR1cm4gdW5sZXNzIEBzZXR0aW5ncy5nZXQgJ21peHBhbmVsSWQnXG5cbiAgICBAdHJhY2tFdmVudCBlLm5hbWUsIGUuYXR0cnMgZm9yIGUgaW4gQGV2ZW50UXVldWVcbiAgICBAZXZlbnRRdWV1ZSA9IFtdXG4iLCIkID0gcmVxdWlyZSAnanF1ZXJ5J1xucGFnZU1vZCA9IHJlcXVpcmUgJ3Nkay9wYWdlLW1vZCdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBCcm93c2VyXG4gIEBnZXQ6IChmaWxlLCBjYWxsYmFjaykgLT5cbiAgICAjIGluIGNocm9tZSB3ZSBjYW4gbG9hZCB0aGUgZmlsZSBmcm9tIHRoZSBleHRlbnNpb25cbiAgICBpZiBjaHJvbWU/XG4gICAgICAkLmdldCBjaHJvbWUuZXh0ZW5zaW9uLmdldFVSTChmaWxlKSwgKGNvbnRlbnRzKSAtPlxuICAgICAgICBjYWxsYmFjay5jYWxsIHRoaXMsIGNvbnRlbnRzXG4gICAgICByZXR1cm5cblxuICAgICMgaW4gZmlyZWZveCB0aGUgZmlsZSBjb21lcyBmcm9tIHRoZSBzZWxmLm9wdGlvbnNcbiAgICBjYWxsYmFjay5jYWxsIHRoaXMsIHNlbGYub3B0aW9uc1tmaWxlXVxuXG4gIEBicm93c2VyTmFtZTogLT5cbiAgICByZXR1cm4gJ2Nocm9tZScgaWYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSBpc250IC0xXG4gICAgcmV0dXJuICdmaXJlZm94JyBpZiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSBpc250IC0xXG4gICAgcmV0dXJuICd1bmtub3duJ1xuXG4gIEBvc05hbWU6IC0+XG4gICAgcmV0dXJuICdvcyB4JyBpZiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01hY2ludG9zaCcpIGlzbnQgLTFcbiAgICByZXR1cm4gJ3dpbmRvd3MnIGlmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignV2luZG93cycpIGlzbnQgLTFcbiAgICByZXR1cm4gJ2xpbnV4JyBpZiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0xpbnV4JykgaXNudCAtMVxuICAgIHJldHVybiAndW5rbm93bidcblxuICBAaXNDaHJvbWU6IC0+XG4gICAgY2hyb21lPy5ydW50aW1lP1xuXG4gIEBpc0ZpcmVmb3g6IC0+XG4gICAgcGFnZU1vZC5QYWdlTW9kPyBvciBzZWxmPy5wb3J0P1xuXG4gIEBzZW5kTWVzc2FnZTogKG1lc3NhZ2UsIGRhdGEsIHJlc3BvbnNlKSAtPlxuICAgIGNocm9tZT8ucnVudGltZT8uc2VuZE1lc3NhZ2Uge3R5cGU6IG1lc3NhZ2UsIGRhdGE6IGRhdGF9LCByZXNwb25zZVxuXG4gICAgaWYgQGlzRmlyZWZveCgpXG4gICAgICBpZiByZXNwb25zZT9cbiAgICAgICAgc2VsZi5wb3J0Lm9uY2UgXCIje21lc3NhZ2V9OnJlc3BvbnNlXCIsIChkYXRhKSAtPlxuICAgICAgICAgIHJlc3BvbnNlIGRhdGFcblxuICAgICAgc2VsZi5wb3J0LmVtaXQgbWVzc2FnZSwgZGF0YVxuXG4iLCJQYWdlID0gcmVxdWlyZSAnbW9kZWxzL3BhZ2UnXG5VcmxNZXRyaWNzID0gcmVxdWlyZSAnbW9kZWxzL3VybF9tZXRyaWNzJ1xubW96Q29scyA9IHJlcXVpcmUgJ21vZGVscy9tb3pfY29scydcblxuQ0FDSEVfREFZUyA9IDFcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBCdXR0b25NZXRyaWNzIGV4dGVuZHMgVXJsTWV0cmljc1xuICBpbml0aWFsaXplOiAtPlxuICAgIEBvbmNlICdzeW5jJywgPT5cbiAgICAgIEBpc0ZldGNoaW5nID0gZmFsc2VcbiAgICAgIEBzZXRDYWNoZWRWYWx1ZSBQYWdlLmhvc3RuYW1lKCksIEBnZXQgJ25pY2VQZGEnXG5cbiAgICBzdXBlclxuXG4gIGZldGNoOiAob3B0aW9ucykgLT5cbiAgICByZXR1cm4gaWYgQGlzRmV0Y2hpbmcgb3IgQGdldCAnbmljZVBkYSdcblxuICAgIEBnZXRDYWNoZWRWYWx1ZSBQYWdlLmhvc3RuYW1lKCksICh2YWx1ZSkgPT5cbiAgICAgIGlmIHZhbHVlPy5uaWNlUGRhXG4gICAgICAgIEBzZXQgbmljZVBkYTogdmFsdWUubmljZVBkYVxuICAgICAgICByZXR1cm5cblxuICAgICAgc3VwZXJcblxuICBnZXRDb2xzOiAtPlxuICAgIG1vekNvbHMuZ2V0Qml0cyBbJ3BkYSddXG5cbiAgZ2V0Q2FjaGVkVmFsdWU6IChrZXksIGNhbGxiYWNrKSAtPlxuICAgIGNocm9tZT8uc3RvcmFnZS5sb2NhbC5nZXQgJ2J1dHRvbk1ldHJpY3MnLCAocmVzdWx0cykgLT5cbiAgICAgIHVubGVzcyBEYXRlLm5vdygpIDwgcmVzdWx0cz8uYnV0dG9uTWV0cmljcz9ba2V5XT8uZXhwaXJlc1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbClcblxuICAgICAgY2FsbGJhY2sgcmVzdWx0cy5idXR0b25NZXRyaWNzW2tleV0udmFsdWVcblxuICBzZXRDYWNoZWRWYWx1ZTogKGtleSwgdmFsdWUpIC0+XG4gICAgIyBncmFiIHRoZSBlbnRpcmUgc2V0IG9mIG1ldHJpY3NcbiAgICBjaHJvbWU/LnN0b3JhZ2UubG9jYWwuZ2V0ICdidXR0b25NZXRyaWNzJywgKHJlc3VsdHMpIC0+XG4gICAgICAjIGRlbGV0ZSBhbnkgdGhhdCBhcmUgZXhwaXJlZFxuICAgICAgbm93ID0gbmV3IERhdGUoKVxuICAgICAgYnV0dG9uTWV0cmljcyA9IHJlc3VsdHM/LmJ1dHRvbk1ldHJpY3Mgb3Ige31cbiAgICAgIGZvciBrZXksIGRhdGEgaW4gYnV0dG9uTWV0cmljc1xuICAgICAgICBpZiBub3cgPiBkYXRhLmV4cGlyZXNcbiAgICAgICAgICBkZWxldGUgYnV0dG9uTWV0cmljc1trZXldXG5cbiAgICAgICMgYWRkIHRoaXMgbmV3IHNpdGUgdmFsdWVcbiAgICAgIGJ1dHRvbk1ldHJpY3Nba2V5XSA9XG4gICAgICAgIHZhbHVlOiBuaWNlUGRhOiB2YWx1ZVxuICAgICAgICBleHBpcmVzOiBub3cuc2V0RGF0ZSBub3cuZ2V0RGF0ZSgpICsgQ0FDSEVfREFZU1xuXG4gICAgICBjaHJvbWU/LnN0b3JhZ2UubG9jYWwuc2V0IHtidXR0b25NZXRyaWNzfVxuIiwiQmFja2JvbmUgPSByZXF1aXJlICdiYWNrYm9uZSdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBDaXRpZXMgZXh0ZW5kcyBCYWNrYm9uZS5Db2xsZWN0aW9uXG4gIHJlZ2lvbjogJydcblxuICB1cmw6IC0+XG4gICAgXCJodHRwczovL2QyZWVpcGNyY2RsZTYuY2xvdWRmcm9udC5uZXQvbW96YmFyL2NpdGllcy8je0ByZWdpb259Lmpzb25cIlxuXG4gIHBhcnNlOiAocmVzcCkgLT5cbiAgICB7bmFtZTogY2l0eX0gZm9yIGNpdHkgaW4gcmVzcFxuIiwiXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG57TW9kZWx9ID0gcmVxdWlyZSAnYmFja2JvbmUnXG5QYWdlID0gcmVxdWlyZSAnbW9kZWxzL3BhZ2UnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRmFjZWJvb2tTdGF0cyBleHRlbmRzIE1vZGVsXG4gIGRlZmF1bHRzOlxuICAgIHNpdGU6ICdmYWNlYm9vaydcbiAgICB0b29sdGlwOiAnRmFjZWJvb2sgQWN0aXZpdHknXG4gICAgY291bnQ6ICctLSdcblxuICB1cmw6IC0+XG4gICAgXCJodHRwczovL2FwaS5mYWNlYm9vay5jb20vbWV0aG9kL2xpbmtzLmdldFN0YXRzP1wiICtcbiAgICBcInVybHM9I3tQYWdlLmhyZWYoKX0mZm9ybWF0PWpzb25cIlxuXG4gIHBhcnNlOiAocmVzcCkgLT5cbiAgICBfLmV4dGVuZCByZXNwWzBdIG9yIHt9LCBjb3VudDogcmVzcFswXT8udG90YWxfY291bnQudG9Mb2NhbGVTdHJpbmcoKVxuXG4gIHZhbGlkYXRlOiAoYXR0cnMpIC0+XG4gICAgJ0RhdGEgbm90IGxvYWRlZCEnIHVubGVzcyBhdHRycy5jb3VudCBpc250IEBkZWZhdWx0cy5jb3VudFxuIiwiXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG57TW9kZWx9ID0gcmVxdWlyZSAnYmFja2JvbmUnXG5QYWdlID0gcmVxdWlyZSAnbW9kZWxzL3BhZ2UnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgR2VvbG9jYXRpb24gZXh0ZW5kcyBNb2RlbFxuICBAaW5zdGFuY2U6IG51bGxcbiAgQGdldEluc3RhbmNlOiAtPlxuICAgIEBpbnN0YW5jZSA/PSBuZXcgR2VvbG9jYXRpb25cblxuICBkZWZhdWx0czpcbiAgICBob3N0bmFtZTogUGFnZS5ob3N0bmFtZSgpXG4gICAgaXA6IG51bGxcbiAgICBjb3VudHJ5X2NvZGU6IG51bGxcbiAgICBjb3VudHJ5X25hbWU6IG51bGxcblxuICB1cmw6IC0+XG4gICAgXCIvL21vemJhci5tb3ouY29tLyN7QGdldCAnaG9zdG5hbWUnfVwiXG5cbiAgdmFsaWRhdGU6IChhdHRycykgLT5cbiAgICAnRGF0YSBub3QgbG9hZGVkIScgaWYgXy5pc051bGwgYXR0cnMuaXBcbiIsIm1vZHVsZS5leHBvcnRzID0gY2xhc3MgR29vZ2xlRG9tYWluc1xuICBAZ2V0RG9tYWluOiAoY291bnRyeSkgLT5cbiAgICBAZG9tYWluc1tjb3VudHJ5XSBvciBcImh0dHA6Ly93d3cuZ29vZ2xlLmNvbS9zZWFyY2g/Y3I9Y291bnRyeSN7Y291bnRyeX1cIlxuXG4gIEBkb21haW5zOlxuICAgIEFGOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNvbS5hZi9zZWFyY2g/XCJcbiAgICBEWjogXCJodHRwOi8vd3d3Lmdvb2dsZS5kei9zZWFyY2g/XCJcbiAgICBBUzogXCJodHRwOi8vd3d3Lmdvb2dsZS5hcy9zZWFyY2g/XCJcbiAgICBBSTogXCJodHRwOi8vd3d3Lmdvb2dsZS5jb20uYWkvc2VhcmNoP1wiXG4gICAgQUc6IFwiaHR0cDovL3d3dy5nb29nbGUuY29tLmFnL3NlYXJjaD9cIlxuICAgIEFSOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNvbS5hci9zZWFyY2g/XCJcbiAgICBBTTogXCJodHRwOi8vd3d3Lmdvb2dsZS5hbS9zZWFyY2g/XCJcbiAgICBBVTogXCJodHRwOi8vd3d3Lmdvb2dsZS5jb20uYXUvc2VhcmNoP1wiXG4gICAgQVQ6IFwiaHR0cDovL3d3dy5nb29nbGUuYXQvc2VhcmNoP1wiXG4gICAgQVo6IFwiaHR0cDovL3d3dy5nb29nbGUuYXovc2VhcmNoP1wiXG4gICAgQlM6IFwiaHR0cDovL3d3dy5nb29nbGUuYnMvc2VhcmNoP1wiXG4gICAgQkg6IFwiaHR0cDovL3d3dy5nb29nbGUuY29tLmJoL3NlYXJjaD9cIlxuICAgIEJEOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNvbS5iZC9zZWFyY2g/XCJcbiAgICBCWTogXCJodHRwOi8vd3d3Lmdvb2dsZS5ieS9zZWFyY2g/XCJcbiAgICBCRTogXCJodHRwOi8vd3d3Lmdvb2dsZS5iZS9zZWFyY2g/XCJcbiAgICBCWjogXCJodHRwOi8vd3d3Lmdvb2dsZS5jb20uYnovc2VhcmNoP1wiXG4gICAgQk86IFwiaHR0cDovL3d3dy5nb29nbGUuY29tLmJvL3NlYXJjaD9cIlxuICAgIEJBOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmJhL3NlYXJjaD9cIlxuICAgIEJSOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNvbS5ici9zZWFyY2g/XCJcbiAgICBCTjogXCJodHRwOi8vd3d3Lmdvb2dsZS5jb20uYm4vc2VhcmNoP1wiXG4gICAgQkc6IFwiaHR0cDovL3d3dy5nb29nbGUuYmcvc2VhcmNoP1wiXG4gICAgQkk6IFwiaHR0cDovL3d3dy5nb29nbGUuYmkvc2VhcmNoP1wiXG4gICAgQ0E6IFwiaHR0cDovL3d3dy5nb29nbGUuY2Evc2VhcmNoP1wiXG4gICAgQ0w6IFwiaHR0cDovL3d3dy5nb29nbGUuY2wvc2VhcmNoP1wiXG4gICAgQ046IFwiaHR0cDovL3d3dy5nb29nbGUuY24vc2VhcmNoP1wiXG4gICAgQ086IFwiaHR0cDovL3d3dy5nb29nbGUuY29tLmNvL3NlYXJjaD9cIlxuICAgIENEOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNkL3NlYXJjaD9cIlxuICAgIENLOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNvLmNrL3NlYXJjaD9cIlxuICAgIENSOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNvLmNyL3NlYXJjaD9cIlxuICAgIEhSOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmhyL3NlYXJjaD9cIlxuICAgIENVOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNvbS5jdS9zZWFyY2g/XCJcbiAgICBDWjogXCJodHRwOi8vd3d3Lmdvb2dsZS5jei9zZWFyY2g/XCJcbiAgICBDSTogXCJodHRwOi8vd3d3Lmdvb2dsZS5jaS9zZWFyY2g/XCJcbiAgICBESzogXCJodHRwOi8vd3d3Lmdvb2dsZS5kay9zZWFyY2g/XCJcbiAgICBETTogXCJodHRwOi8vd3d3Lmdvb2dsZS5kbS9zZWFyY2g/XCJcbiAgICBETzogXCJodHRwOi8vd3d3Lmdvb2dsZS5jb20uZG8vc2VhcmNoP1wiXG4gICAgRUM6IFwiaHR0cDovL3d3dy5nb29nbGUuY29tLmVjL3NlYXJjaD9cIlxuICAgIEVHOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNvbS5lZy9zZWFyY2g/XCJcbiAgICBTVjogXCJodHRwOi8vd3d3Lmdvb2dsZS5jb20uc3Yvc2VhcmNoP1wiXG4gICAgRUU6IFwiaHR0cDovL3d3dy5nb29nbGUuZWUvc2VhcmNoP1wiXG4gICAgRkk6IFwiaHR0cDovL3d3dy5nb29nbGUuZmkvc2VhcmNoP1wiXG4gICAgRlI6IFwiaHR0cDovL3d3dy5nb29nbGUuZnIvc2VhcmNoP1wiXG4gICAgR0U6IFwiaHR0cDovL3d3dy5nb29nbGUuZ2Uvc2VhcmNoP1wiXG4gICAgREU6IFwiaHR0cDovL3d3dy5nb29nbGUuZGUvc2VhcmNoP1wiXG4gICAgR0g6IFwiaHR0cDovL3d3dy5nb29nbGUuY29tLmdoL3NlYXJjaD9cIlxuICAgIEdJOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNvbS5naS9zZWFyY2g/XCJcbiAgICBHUjogXCJodHRwOi8vd3d3Lmdvb2dsZS5nci9zZWFyY2g/XCJcbiAgICBHVDogXCJodHRwOi8vd3d3Lmdvb2dsZS5jb20uZ3Qvc2VhcmNoP1wiXG4gICAgSE46IFwiaHR0cDovL3d3dy5nb29nbGUuaG4vc2VhcmNoP1wiXG4gICAgSEs6IFwiaHR0cDovL3d3dy5nb29nbGUuY29tLmhrL3NlYXJjaD9cIlxuICAgIEhVOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmh1L3NlYXJjaD9cIlxuICAgIElTOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmlzL3NlYXJjaD9cIlxuICAgIElOOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmluL3NlYXJjaD9cIlxuICAgIElEOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNvLmlkL3NlYXJjaD9cIlxuICAgIElFOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmllL3NlYXJjaD9cIlxuICAgIElMOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNvLmlsL3NlYXJjaD9cIlxuICAgIElUOiBcImh0dHA6Ly93d3cuZ29vZ2xlLml0L3NlYXJjaD9cIlxuICAgIEpNOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNvbS5qbS9zZWFyY2g/XCJcbiAgICBKUDogXCJodHRwOi8vd3d3Lmdvb2dsZS5jby5qcC9zZWFyY2g/XCJcbiAgICBKTzogXCJodHRwOi8vd3d3Lmdvb2dsZS5qby9zZWFyY2g/XCJcbiAgICBLRTogXCJodHRwOi8vd3d3Lmdvb2dsZS5rei9zZWFyY2g/XCJcbiAgICBLSTogXCJodHRwOi8vd3d3Lmdvb2dsZS5jby5rZS9zZWFyY2g/XCJcbiAgICBLUjogXCJodHRwOi8vd3d3Lmdvb2dsZS5jby5rci9zZWFyY2g/XCJcbiAgICBMQTogXCJodHRwOi8vd3d3Lmdvb2dsZS5sYS9zZWFyY2g/XCJcbiAgICBMVjogXCJodHRwOi8vd3d3Lmdvb2dsZS5sdi9zZWFyY2g/XCJcbiAgICBMQjogXCJodHRwOi8vd3d3Lmdvb2dsZS5jb20ubGIvc2VhcmNoP1wiXG4gICAgTFM6IFwiaHR0cDovL3d3dy5nb29nbGUuY29tLmx5L3NlYXJjaD9cIlxuICAgIExJOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmxpL3NlYXJjaD9cIlxuICAgIExUOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmx0L3NlYXJjaD9cIlxuICAgIExVOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmx1L3NlYXJjaD9cIlxuICAgIE1POiBcImh0dHA6Ly93d3cuZ29vZ2xlLm1rL3NlYXJjaD9cIlxuICAgIE1HOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNvbS5teS9zZWFyY2g/XCJcbiAgICBNVjogXCJodHRwOi8vd3d3Lmdvb2dsZS5jb20ubXQvc2VhcmNoP1wiXG4gICAgTUg6IFwiaHR0cDovL3d3dy5nb29nbGUubXUvc2VhcmNoP1wiXG4gICAgTVg6IFwiaHR0cDovL3d3dy5nb29nbGUuY29tLm14L3NlYXJjaD9cIlxuICAgIEZNOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmZtL3NlYXJjaD9cIlxuICAgIE1EOiBcImh0dHA6Ly93d3cuZ29vZ2xlLm1kL3NlYXJjaD9cIlxuICAgIE1BOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNvLm1hL3NlYXJjaD9cIlxuICAgIE5SOiBcImh0dHA6Ly93d3cuZ29vZ2xlLm5yL3NlYXJjaD9cIlxuICAgIE5QOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNvbS5ucC9zZWFyY2g/XCJcbiAgICBOTDogXCJodHRwOi8vd3d3Lmdvb2dsZS5ubC9zZWFyY2g/XCJcbiAgICBOWjogXCJodHRwOi8vd3d3Lmdvb2dsZS5jby5uei9zZWFyY2g/XCJcbiAgICBORzogXCJodHRwOi8vd3d3Lmdvb2dsZS5jb20ubmcvc2VhcmNoP1wiXG4gICAgTk86IFwiaHR0cDovL3d3dy5nb29nbGUubm8vc2VhcmNoP1wiXG4gICAgT006IFwiaHR0cDovL3d3dy5nb29nbGUuY29tLm9tL3NlYXJjaD9cIlxuICAgIFBLOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNvbS5way9zZWFyY2g/XCJcbiAgICBQQTogXCJodHRwOi8vd3d3Lmdvb2dsZS5jb20ucGEvc2VhcmNoP1wiXG4gICAgUFk6IFwiaHR0cDovL3d3dy5nb29nbGUuY29tLnB5L3NlYXJjaD9cIlxuICAgIFBFOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNvbS5wZS9zZWFyY2g/XCJcbiAgICBQSDogXCJodHRwOi8vd3d3Lmdvb2dsZS5jb20ucGgvc2VhcmNoP1wiXG4gICAgUEw6IFwiaHR0cDovL3d3dy5nb29nbGUucGwvc2VhcmNoP1wiXG4gICAgUFQ6IFwiaHR0cDovL3d3dy5nb29nbGUucHQvc2VhcmNoP1wiXG4gICAgUFI6IFwiaHR0cDovL3d3dy5nb29nbGUuY29tLnByL3NlYXJjaD9cIlxuICAgIFFBOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNvbS5xYS9zZWFyY2g/XCJcbiAgICBSTzogXCJodHRwOi8vd3d3Lmdvb2dsZS5yby9zZWFyY2g/XCJcbiAgICBSVTogXCJodHRwOi8vd3d3Lmdvb2dsZS5ydS9zZWFyY2g/XCJcbiAgICBTSDogXCJodHRwOi8vd3d3Lmdvb2dsZS5zaC9zZWFyY2g/XCJcbiAgICBXUzogXCJodHRwOi8vd3d3Lmdvb2dsZS5hcy9zZWFyY2g/XCJcbiAgICBTQTogXCJodHRwOi8vd3d3Lmdvb2dsZS5jb20uc2Evc2VhcmNoP1wiXG4gICAgU046IFwiaHR0cDovL3d3dy5nb29nbGUuc24vc2VhcmNoP1wiXG4gICAgWVU6IFwiaHR0cDovL3d3dy5nb29nbGUucnMvc2VhcmNoP1wiXG4gICAgU0M6IFwiaHR0cDovL3d3dy5nb29nbGUuc2Mvc2VhcmNoP1wiXG4gICAgU0c6IFwiaHR0cDovL3d3dy5nb29nbGUuY29tLnNnL3NlYXJjaD9cIlxuICAgIFNLOiBcImh0dHA6Ly93d3cuZ29vZ2xlLnNrL3NlYXJjaD9cIlxuICAgIFNJOiBcImh0dHA6Ly93d3cuZ29vZ2xlLnNpL3NlYXJjaD9cIlxuICAgIFpBOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNvLnphL3NlYXJjaD9cIlxuICAgIEVTOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmVzL3NlYXJjaD9cIlxuICAgIExLOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmxrL3NlYXJjaD9cIlxuICAgIFNFOiBcImh0dHA6Ly93d3cuZ29vZ2xlLnNlL3NlYXJjaD9cIlxuICAgIENIOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNoL3NlYXJjaD9cIlxuICAgIFRXOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNvbS50dy9zZWFyY2g/XCJcbiAgICBUSDogXCJodHRwOi8vd3d3Lmdvb2dsZS5jby50aC9zZWFyY2g/XCJcbiAgICBUSzogXCJodHRwOi8vd3d3Lmdvb2dsZS50ay9zZWFyY2g/XCJcbiAgICBUTzogXCJodHRwOi8vd3d3Lmdvb2dsZS50by9zZWFyY2g/XCJcbiAgICBUVDogXCJodHRwOi8vd3d3Lmdvb2dsZS50dC9zZWFyY2g/XCJcbiAgICBUTjogXCJodHRwOi8vd3d3Lmdvb2dsZS50bi9zZWFyY2g/XCJcbiAgICBUUjogXCJodHRwOi8vd3d3Lmdvb2dsZS5jb20udHIvc2VhcmNoP1wiXG4gICAgVE06IFwiaHR0cDovL3d3dy5nb29nbGUudG0vc2VhcmNoP1wiXG4gICAgVUE6IFwiaHR0cDovL3d3dy5nb29nbGUuY29tLnVhL3NlYXJjaD9cIlxuICAgIEFFOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmFlL3NlYXJjaD9cIlxuICAgIEdCOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNvLnVrL3NlYXJjaD9cIlxuICAgIFVTOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNvbS9zZWFyY2g/Z2w9dXNcIlxuICAgIFVZOiBcImh0dHA6Ly93d3cuZ29vZ2xlLmNvbS51eS9zZWFyY2g/XCJcbiAgICBVWjogXCJodHRwOi8vd3d3Lmdvb2dsZS5jby51ei9zZWFyY2g/XCJcbiAgICBWRTogXCJodHRwOi8vd3d3Lmdvb2dsZS5jby52ZS9zZWFyY2g/XCJcbiAgICBWTjogXCJodHRwOi8vd3d3Lmdvb2dsZS5jb20udm4vc2VhcmNoP1wiXG4gICAgWk06IFwiaHR0cDovL3d3dy5nb29nbGUuY28uem0vc2VhcmNoP1wiXG4gICAgWlc6IFwiaHR0cDovL3d3dy5nb29nbGUuY28uencvc2VhcmNoP1wiXG4iLCJfID0gcmVxdWlyZSAndW5kZXJzY29yZSdcbntNb2RlbH0gPSByZXF1aXJlICdiYWNrYm9uZSdcblBhZ2UgPSByZXF1aXJlICdtb2RlbHMvcGFnZSdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBHb29nbGVQbHVzU3RhdHMgZXh0ZW5kcyBNb2RlbFxuICBkZWZhdWx0czpcbiAgICBzaXRlOiAnZ29vZ2xlLXBsdXMnXG4gICAgdG9vbHRpcDogJ0dvb2dsZSArJ1xuICAgIGNvdW50OiAnLS0nXG5cbiAgdXJsOiAtPlxuICAgIFwiaHR0cHM6Ly9jbGllbnRzNi5nb29nbGUuY29tL3JwY1wiXG5cbiAgZmV0Y2g6IChvcHRzKSAtPlxuICAgIHN1cGVyIF8uZXh0ZW5kIChvcHRzIG9yIHt9KSxcbiAgICAgIHR5cGU6ICdwb3N0J1xuICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uLXJwYydcbiAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5XG4gICAgICAgIG1ldGhvZDogJ3Bvcy5wbHVzb25lcy5nZXQnXG4gICAgICAgIGlkOiAncCdcbiAgICAgICAganNvbnJwYzogJzIuMCdcbiAgICAgICAga2V5OiAncCdcbiAgICAgICAgYXBpVmVyc2lvbjogJ3YxJ1xuICAgICAgICBwYXJhbXM6XG4gICAgICAgICAgbm9sb2c6IHRydWUsXG4gICAgICAgICAgaWQ6IFBhZ2UuaHJlZigpXG4gICAgICAgICAgc291cmNlOiAnd2lkZ2V0J1xuICAgICAgICAgIHVzZXJJZDogJ0B2aWV3ZXInXG4gICAgICAgICAgZ3JvdXBJZDogJ0BzZWxmJ1xuXG4gIHBhcnNlOiAocmVzcCkgLT5cbiAgICBjb3VudDogcmVzcC5yZXN1bHQubWV0YWRhdGEuZ2xvYmFsQ291bnRzLmNvdW50LnRvTG9jYWxlU3RyaW5nKClcblxuICB2YWxpZGF0ZTogKGF0dHJzKSAtPlxuICAgICdEYXRhIG5vdCBsb2FkZWQhJyB1bmxlc3MgYXR0cnMuY291bnQgaXNudCBAZGVmYXVsdHMuY291bnRcbiIsIntNb2RlbH0gPSByZXF1aXJlICdiYWNrYm9uZSdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBIdHRwU3RhdHVzTGlzdCBleHRlbmRzIE1vZGVsXG4gIGRlZmF1bHRzOlxuICAgIGlzT2s6IGZhbHNlXG4gICAgc3RhdHVzOiBudWxsXG4gICAgc3RhdHVzQ29kZTogbnVsbFxuICAgIHVybDogbnVsbFxuXG4gIGluaXRpYWxpemU6IChhdHRycywgb3B0aW9ucykgLT5cbiAgICBzdXBlclxuICAgIEB1cGRhdGVBdHRyaWJ1dGVzKClcbiAgICBAbGlzdGVuVG8gdGhpcywgJ2NoYW5nZScsIEB1cGRhdGVBdHRyaWJ1dGVzXG5cbiAgdXBkYXRlQXR0cmlidXRlczogLT5cbiAgICBjb2RlID0gQGdldCgnc3RhdHVzJykubWF0Y2goL15IVFRQXFwvXFxkK1xcLlxcZCsgKFxcZCspLylbMV1cbiAgICBAc2V0XG4gICAgICBpc09rOiBjb2RlIGlzICcyMDAnXG4gICAgICBzdGF0dXNDb2RlOiBjb2RlXG4iLCJ7Q29sbGVjdGlvbn0gPSByZXF1aXJlICdiYWNrYm9uZSdcbkh0dHBTdGF0dXMgPSByZXF1aXJlICdtb2RlbHMvaHR0cF9zdGF0dXMnXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEh0dHBTdGF0dXNMaXN0IGV4dGVuZHMgQ29sbGVjdGlvblxuICBtb2RlbDogSHR0cFN0YXR1c1xuXG4gIHN5bmM6IChtZXRob2QsIG1vZGVsLCBvcHRpb25zKSAtPlxuICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJykgdW5sZXNzIG1ldGhvZCBpcyAncmVhZCdcblxuICAgIGNocm9tZT8ucnVudGltZT8uc2VuZE1lc3NhZ2UgdHlwZTogJ3N0YXR1cy1oaXN0b3J5JywgKHJlc3BvbnNlKSAtPlxuICAgICAgb3B0aW9ucy5zdWNjZXNzLmNhbGwgbW9kZWwsIHJlc3BvbnNlXG5cbiAgaXNWYWxpZDogLT4gICAgQGxlbmd0aCA+IDBcbiIsIl8gPSByZXF1aXJlICd1bmRlcnNjb3JlJ1xuJCA9IHJlcXVpcmUgJ2pxdWVyeSdcbntNb2RlbH0gPSByZXF1aXJlICdiYWNrYm9uZSdcblBhZ2UgPSByZXF1aXJlICdtb2RlbHMvcGFnZSdcblNlcnBSZXN1bHRzTWV0cmljcyA9IHJlcXVpcmUgJ21vZGVscy9zZXJwX3Jlc3VsdHNfbWV0cmljcydcblVzZXIgPSByZXF1aXJlICdtb2RlbHMvdXNlcidcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBLZXl3b3JkRGlmZmljdWx0eSBleHRlbmRzIE1vZGVsXG4gIGRlZmF1bHRzOlxuICAgIGlzTG9hZGVkOiBmYWxzZVxuICAgIGRpZmZpY3VsdHk6ICctLSdcbiAgICB2b2x1bWU6ICctLSdcbiAgICBpc1BybzogZmFsc2VcblxuICBzZXJwUmVzdWx0c01ldHJpY3M6IG51bGxcbiAgc2VhcmNoUmVzdWx0VXJsczogW11cbiAgdXNlcjogVXNlci5nZXRJbnN0YW5jZSgpXG5cbiAgaW5pdGlhbGl6ZTogLT5cbiAgICBAdXNlci5vbiAnY2hhbmdlOmlzUHJvJywgPT4gQHNldCBpc1BybzogQHVzZXIuZ2V0ICdpc1BybydcblxuICAjIGZvciBkaWZmaWN1bHR5OlxuICAjICAgMSkgZmV0Y2ggZmlyc3QgMjAgcmVzdWx0cyBmcm9tIGdvb2dsZVxuICAjICAgMikgZmV0Y2ggcGEgZm9yIHRob3NlIHJlc3VsdHNcbiAgIyAgIDMpIHNvcnRcbiAgIyAgIDQpIGRpc3BsYXkgdGhlIDV0aCBlbGVtZW50XG4gICNcbiAgZmV0Y2g6IC0+XG4gICAgQHNlcnBSZXN1bHRzTWV0cmljcyA9IFNlcnBSZXN1bHRzTWV0cmljcy5nZXRJbnN0YW5jZSgpXG4gICAgQGxpc3RlblRvIEBzZXJwUmVzdWx0c01ldHJpY3MsICdjaGFuZ2UnLCBAdXBkYXRlRGlmZmljdWx0eVxuXG4gICAgQGZldGNoRGlmZmljdWx0eSgpXG4gICAgQHNldCBpc0xvYWRlZDogdHJ1ZSwgaXNQcm86IEB1c2VyLmdldCAnaXNQcm8nXG5cbiAgZmV0Y2hEaWZmaWN1bHR5OiAtPlxuICAgIHN0YXJ0ID0gUGFnZS5nZXRTdGFydEluZGV4KClcbiAgICBpZiBzdGFydCBpcyAwIG9yIHN0YXJ0IGlzIDEwXG4gICAgICBAYWRkU2VhcmNoUmVzdWx0VXJscyAoJCBkb2N1bWVudClcblxuICAgIGlmIHN0YXJ0ID49IDEwXG4gICAgICAjIHdlcmUgb24gcGFnZSAyIG9yIGFmdGVyLCBnZXQgdGhlIGZpcnN0IHBhZ2Ugb2YgcmVzdWx0c1xuICAgICAgQGZldGNoU2VhcmNoUGFnZSAwXG4gICAgICBAZmV0Y2hTZWFyY2hQYWdlKDEwKSB1bmxlc3Mgc3RhcnQgaXMgMTBcblxuICAgIGlmIHN0YXJ0IGlzIDAgYW5kIEBzZWFyY2hSZXN1bHRVcmxzLmxlbmd0aCA8IDIwXG4gICAgICAjIG5lZWQgdG8gYWRkIHBhZ2UgMiBvZiByZXN1bHRzXG4gICAgICBAZmV0Y2hTZWFyY2hQYWdlIDEwXG5cbiAgICAgIGlmIEBzZWFyY2hSZXN1bHRVcmxzLmxlbmd0aCA8IDEwXG4gICAgICAgICMgZmlyc3QgcGFnZSBoYWQgbGVzcyB0aGFuIDEwIHJlc3VsdHMsIG5lZWQgdG8gZmV0Y2ggYVxuICAgICAgICAjIHRoaXJkIHBhZ2Ugb2YgcmVzdWx0c1xuICAgICAgICBAZmV0Y2hTZWFyY2hQYWdlIDIwXG5cbiAgICBAdXBkYXRlRGlmZmljdWx0eSgpXG5cbiAgdXBkYXRlRGlmZmljdWx0eTogLT5cbiAgICByZXR1cm4gdW5sZXNzIEBzZWFyY2hSZXN1bHRVcmxzLmxlbmd0aCA+PSAyMFxuICAgIHJldHVybiB1bmxlc3MgQHNlcnBSZXN1bHRzTWV0cmljcy5pc0xvYWRlZCBAc2VhcmNoUmVzdWx0VXJsc1xuXG4gICAgIyBzb3J0IGJ5IHVwYSBpbiBkZXNjZW5kaW5nIG9yZGVyXG4gICAgbWV0cmljcyA9IEBzZXJwUmVzdWx0c01ldHJpY3MuZmluZE1ldHJpY3NCeVVybHMgQHNlYXJjaFJlc3VsdFVybHNcbiAgICBtZXRyaWNzID0gXy5zb3J0QnkgbWV0cmljcywgKG1vZGVsKSAtPiBtb2RlbC5nZXQoJ3VwYScpICogLTFcblxuICAgICMgZGlmZmljdWx0eSBpcyB0aGUgNXRoIGhpZ2hlc3QgdXBhXG4gICAgQHNldCBkaWZmaWN1bHR5OiBtZXRyaWNzWzVdLmdldCAnbmljZVVwYSdcblxuICBmZXRjaFNlYXJjaFBhZ2U6IChzdGFydCkgLT5cbiAgICAkLmdldCBcIi8vd3d3Lmdvb2dsZS5jb20vc2VhcmNoP3E9I3tQYWdlLmdldFNlYXJjaFRlcm0oKX0mc3RhcnQ9I3tzdGFydH1cIixcbiAgICAgIChyZXN1bHRzKSA9PiBAYWRkU2VhcmNoUmVzdWx0VXJscyAoJCByZXN1bHRzKVxuXG4gIGFkZFNlYXJjaFJlc3VsdFVybHM6ICgkZG9jKSAtPlxuICAgIHNlcnBDb25maWcgPSBQYWdlLmdldFNlcnBDb25maWcoKVxuICAgICRkb2MuZmluZChzZXJwQ29uZmlnLnNlbGVjdG9yKS5lYWNoIChpLCBlbCkgPT5cbiAgICAgIHBhZ2VVcmwgPSAoJCBlbCkuZmluZChzZXJwQ29uZmlnLmhyZWYpLmF0dHIgJ2hyZWYnXG4gICAgICBAc2VhcmNoUmVzdWx0VXJscy5wdXNoIHBhZ2VVcmxcbiAgICAgIG1ldHJpY3MgPSBAc2VycFJlc3VsdHNNZXRyaWNzLmdldFBhZ2VNZXRyaWNzIHBhZ2VVcmxcbiAgICAgIG1ldHJpY3MuZmV0Y2goKSB1bmxlc3MgbWV0cmljcy5pc1ZhbGlkKClcblxuICByZXNldDogLT5cbiAgICBAc2V0IF8uZXh0ZW5kIEBkZWZhdWx0cywgaXNQcm86IEB1c2VyLmdldCAnaXNQcm8nXG4iLCJfID0gcmVxdWlyZSAndW5kZXJzY29yZSdcblxubW9kdWxlLmV4cG9ydHMgPVxuICBmbGFnczpcbiAgICB1dDogMSAgIyBUaXRsZVxuICAgIHV1OiA0ICAjIENhbm9uaWNhbCBVUkxcbiAgICB1ZnE6IDggICMgU3ViZG9tYWluXG4gICAgdXBsOiAxNiAgIyBSb290IERvbWFpblxuICAgIHVlaWQ6IDMyICAjIEV4dGVybmFsIEVxdWl0eSBMaW5rc1xuICAgIGZlaWQ6IDY0ICAjIFN1YmRvbWFpbiBFeHRlcm5hbCBMaW5rc1xuICAgIHBlaWQ6IDEyOCAgIyBSb290IERvbWFpbiBFeHRlcm5hbCBMaW5rc1xuICAgIHVqaWQ6IDI1NiAgIyBFcXVpdHkgTGlua3NcbiAgICB1aWZxOiA1MTIgICMgU3ViZG9tYWlucyBMaW5raW5nXG4gICAgdWlwbDogMTAyNCAgIyBSb290IERvbWFpbnMgTGlua2luZ1xuICAgIHVpZDogMjA0OCAgIyBMaW5rc1xuICAgIGZpZDogNDA5NiAgIyBTdWJkb21haW4gU3ViZG9tYWlucyBMaW5raW5nXG4gICAgcGlkOiA4MTkyICAjIFJvb3QgRG9tYWluIFJvb3QgRG9tYWlucyBMaW5raW5nXG4gICAgdW1ycDogMTYzODQgICMgTW96UmFua1xuICAgIHVtcnI6IDE2Mzg0ICAjIE1velJhbmtcbiAgICBmbXJwOiAzMjc2OCAgIyBTdWJkb21haW4gTW96UmFua1xuICAgIGZtcnI6IDMyNzY4ICAjIFN1YmRvbWFpbiBNb3pSYW5rXG4gICAgcG1ycDogNjU1MzYgICMgUm9vdCBEb21haW4gTW96UmFua1xuICAgIHBtcnI6IDY1NTM2ICAjIFJvb3QgRG9tYWluIE1velJhbmtcbiAgICB1dHJwOiAxMzEwNzIgICMgTW96VHJ1c3RcbiAgICB1dHJyOiAxMzEwNzIgICMgTW96VHJ1c3RcbiAgICBmdHJwOiAyNjIxNDQgICMgU3ViZG9tYWluIE1velRydXN0XG4gICAgZnRycjogMjYyMTQ0ICAjIFN1YmRvbWFpbiBNb3pUcnVzdFxuICAgIHB0cnA6IDUyNDI4OCAgIyBSb290IERvbWFpbiBNb3pUcnVzdFxuICAgIHB0cnI6IDUyNDI4OCAgIyBSb290IERvbWFpbiBNb3pUcnVzdFxuICAgIHVlbXJwOiAxMDQ4NTc2ICAjIEV4dGVybmFsIE1velJhbmtcbiAgICB1ZW1ycjogMTA0ODU3NiAgIyBFeHRlcm5hbCBNb3pSYW5rXG4gICAgZmVqcDogMjA5NzE1MiAgIyBTdWJkb21haW4gRXh0ZXJuYWwgTGluayBFcXVpdHlcbiAgICBmZWpyOiAyMDk3MTUyICAjIFN1YmRvbWFpbiBFeHRlcm5hbCBMaW5rIEVxdWl0eVxuICAgIHBlanA6IDQxOTQzMDQgICMgUm9vdCBEb21haW4gRXh0ZXJuYWwgTGluayBFcXVpdHlcbiAgICBwZWpyOiA0MTk0MzA0ICAjIFJvb3QgRG9tYWluIEV4dGVybmFsIExpbmsgRXF1aXR5XG4gICAgZmpwOiA4Mzg4NjA4ICAjIFN1YmRvbWFpbiBMaW5rIEVxdWl0eVxuICAgIGZqcjogODM4ODYwOCAgIyBTdWJkb21haW4gTGluayBFcXVpdHlcbiAgICBwanA6IDE2Nzc3MjE2ICAjIFJvb3QgRG9tYWluIExpbmsgRXF1aXR5XG4gICAgcGpyOiAxNjc3NzIxNiAgIyBSb290IERvbWFpbiBMaW5rIEVxdWl0eVxuICAgIHVzOiA1MzY4NzA5MTIgICMgSFRUUCBTdGF0dXMgQ29kZVxuICAgIGZ1aWQ6IDQyOTQ5NjcyOTYgICMgTGlua3MgdG8gU3ViZG9tYWluXG4gICAgcHVpZDogODU4OTkzNDU5MiAgIyBMaW5rcyB0byBSb290IERvbWFpblxuICAgIGZpcGw6IDE3MTc5ODY5MTg0ICAjIFJvb3QgRG9tYWlucyBMaW5raW5nIHRvIFN1YmRvbWFpblxuICAgIHVwYTogMzQzNTk3MzgzNjggICMgUGFnZSBBdXRob3JpdHlcbiAgICBwZGE6IDY4NzE5NDc2NzM2ICAjIERvbWFpbiBBdXRob3JpdHlcbiAgICB1bGM6IDE0NDExNTE4ODA3NTg1NTg3MiAjIFRpbWUgbGFzdCBjcmF3bGVkXG4gICAgZnNwc2M6IDY3MTA4ODY0ICMgc3BhbSBzY29yZVxuXG4gIGdldEJpdHM6IChjb2xzKSAtPlxuICAgIHZhbCA9IDBcbiAgICB2YWwgKz0gQGZsYWdzW2NvbF0gZm9yIGNvbCBpbiBfLnVuaXEgY29sc1xuICAgIHZhbFxuIiwie01vZGVsfSA9IHJlcXVpcmUgJ2JhY2tib25lJ1xuQW5hbHl0aWNzID0gcmVxdWlyZSAnbW9kZWxzL2FuYWx5dGljcydcblVzZXIgPSByZXF1aXJlICdtb2RlbHMvdXNlcidcblBhZ2UgPSByZXF1aXJlICdtb2RlbHMvcGFnZSdcbkRpc3BhdGNoZXIgPSByZXF1aXJlICd2aWV3cy9ldmVudF9kaXNwYXRjaGVyJ1xuU2V0dGluZ3MgPSByZXF1aXJlICdtb2RlbHMvc2V0dGluZ3MnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgT25ib2FyZGluZyBleHRlbmRzIE1vZGVsXG4gIEBvbmJvYXJkaW5nOiBudWxsXG4gIEBnZXRJbnN0YW5jZTogLT5cbiAgICBAb25ib2FyZGluZyA/PSBuZXcgT25ib2FyZGluZ1xuXG4gIHNldHRpbmdzOiBTZXR0aW5ncy5nZXRJbnN0YW5jZSgpXG4gIGRlZmF1bHRzOlxuICAgIHBhZ2VTdGVwOiBudWxsXG4gICAgc2VycFN0ZXA6IG51bGxcbiAgICBwYWdlSGlnaGxpZ2h0czogW11cbiAgICBzZXJwSGlnaGxpZ2h0czogW11cbiAgICBwYWdlVG91ckNvbXBsZXRlOiBmYWxzZVxuICAgIHNlcnBUb3VyQ29tcGxldGU6IGZhbHNlXG4gICAgdmlld2VkSGlnaGxpZ2h0czogW11cbiAgICBzaGFyZWRIaWdobGlnaHRzOiBbXVxuXG4gIHNlcnBTdGVwczogW1xuICAgICdzZXJwLWhvdHNwb3RzJ1xuICAgICdzZXJwLXBhZ2UtaW50cm8tYWRkcmVzcy1iYXInXG4gICAgJ2NvbXBsZXRlJ1xuICBdXG5cbiAgcGFnZVN0ZXBzOiBbXG4gICAgJ3BhZ2UtaG90c3BvdHMnXG4gICAgJ3BhZ2Utc2VycC1pbnRyby1hZGRyZXNzLWJhcidcbiAgICAnY29tcGxldGUnXG4gIF1cblxuICBzZXJwSGlnaGxpZ2h0czogW1xuICAgICdsaW5rLWFuYWx5c2lzJ1xuICAgICdleHBvcnQnXG4gICAgJ2xvY2snXG4gICAgJ2FjdGl2YXRlLWtleXdvcmQtZGlmZmljdWx0eSdcbiAgICAnc2VhcmNoLXByb2ZpbGUnXG4gIF1cblxuICBwYWdlSGlnaGxpZ2h0czogW1xuICAgICdzaG93LWluZm8tcGFuZWwnXG4gICAgJ3Nob3ctbGlua3MtcGFuZWwnXG4gIF1cblxuICBzaGFyZWRIaWdobGlnaHRzOiBbXG4gICAgJ3NldHRpbmdzJ1xuICAgICdoZWxwJ1xuICAgICdjbG9zZSdcbiAgXVxuXG4gIGluaXRpYWxpemU6IC0+XG4gICAgQGRpc3BhdGNoZXIgPSBEaXNwYXRjaGVyLmdldEluc3RhbmNlKClcbiAgICBAdXNlciA9IFVzZXIuZ2V0SW5zdGFuY2UoKVxuXG4gICAgQGxpc3RlblRvIEBzZXR0aW5ncywgJ2NoYW5nZTpvbmJvYXJkaW5nJywgQGZldGNoXG4gICAgQGxpc3RlblRvIEBkaXNwYXRjaGVyLCAnb25ib2FyZGluZzpoaWRlLWhpZ2hsaWdodCcsIEBoaWRlSGlnaGxpZ2h0XG4gICAgQGxpc3RlblRvIHRoaXMsICdjaGFuZ2U6cGFnZVN0ZXAgY2hhbmdlOnNlcnBTdGVwJywgQHN0ZXBDaGFuZ2VkXG5cbiAgICBAbGlzdGVuVG8gdGhpcywgJ2NoYW5nZTpwYWdlSGlnaGxpZ2h0cyBjaGFuZ2U6c2VycEhpZ2hsaWdodHMnLCA9PlxuICAgICAgQGhpZ2hsaWdodHNDaGFuZ2VkKClcblxuICBzeW5jOiAobWV0aG9kKSAtPlxuICAgIHN3aXRjaCBtZXRob2RcbiAgICAgIHdoZW4gJ2NyZWF0ZScsICd1cGRhdGUnLCAncGF0Y2gnXG4gICAgICAgIEBzZXR0aW5ncy5zZXQgJ29uYm9hcmRpbmcnLCBAdG9KU09OKClcbiAgICAgICAgQHNldHRpbmdzLnNhdmUoKVxuXG4gICAgICB3aGVuICdyZWFkJ1xuICAgICAgICBAc2V0IEBzZXR0aW5ncy5nZXQgJ29uYm9hcmRpbmcnXG5cbiAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yIFwiI3ttZXRob2R9IG5vdCBpbXBsZW1lbnRlZC5cIlxuXG4gIG5leHRTdGVwOiAtPlxuICAgIGlmIFBhZ2UuaXNTZXJwKClcbiAgICAgIHNldHRpbmcgPSAnc2VycFN0ZXAnXG4gICAgICBzdGVwcyA9IEBzZXJwU3RlcHNcbiAgICBlbHNlXG4gICAgICBzZXR0aW5nID0gJ3BhZ2VTdGVwJ1xuICAgICAgc3RlcHMgPSBAcGFnZVN0ZXBzXG5cbiAgICBzdGVwID0gQGdldCBzZXR0aW5nXG4gICAgY3VycmVudEluZGV4ID0gc3RlcHMuaW5kZXhPZiBzdGVwXG4gICAgcmV0dXJuIGlmIGN1cnJlbnRJbmRleCBpcyBzdGVwcy5sZW5ndGggLSAxXG5cbiAgICBuZXh0U3RlcCA9IHN0ZXBzW2N1cnJlbnRJbmRleCArIDFdXG5cbiAgICBpZiBuZXh0U3RlcCBpcyAncGFnZS1zZXJwLWludHJvLWFkZHJlc3MtYmFyJ1xuICAgICAgQHNldCBwYWdlVG91ckNvbXBsZXRlOiB0cnVlXG4gICAgICBuZXh0U3RlcCA9ICdjb21wbGV0ZScgaWYgQGdldCAnc2VycFRvdXJDb21wbGV0ZSdcblxuICAgIGlmIG5leHRTdGVwIGlzICdzZXJwLXBhZ2UtaW50cm8tYWRkcmVzcy1iYXInXG4gICAgICBAc2V0IHNlcnBUb3VyQ29tcGxldGU6IHRydWVcbiAgICAgIG5leHRTdGVwID0gJ2NvbXBsZXRlJyBpZiBAZ2V0ICdwYWdlVG91ckNvbXBsZXRlJ1xuXG4gICAgQHNldCBzZXR0aW5nLCBuZXh0U3RlcFxuXG4gICAgaWYgQGdldCgncGFnZVN0ZXAnKSBpcyAnY29tcGxldGUnIGFuZFxuICAgIEBnZXQoJ3BhZ2VUb3VyQ29tcGxldGUnKSBhbmRcbiAgICBAZ2V0KCdzZXJwU3RlcCcpIGlzICdjb21wbGV0ZScgYW5kXG4gICAgQGdldCgnc2VycFRvdXJDb21wbGV0ZScpXG4gICAgICBBbmFseXRpY3MuZ2V0SW5zdGFuY2UoKS50cmFja09uYm9hcmRpbmdDb21wbGV0ZSgpXG5cbiAgICBAc2F2ZSgpXG5cbiAgc3RlcENoYW5nZWQ6IC0+XG4gICAgc3RlcCA9IGlmIFBhZ2UuaXNTZXJwKCkgdGhlbiBAZ2V0KCdzZXJwU3RlcCcpIGVsc2UgQGdldCgncGFnZVN0ZXAnKVxuICAgIEB1cGRhdGVBZGRyZXNzQmFySGlnaGxpZ2h0IHN0ZXBcblxuICAgIGlmIEBnZXQoJ3NlcnBTdGVwJykgaXMgJ2ludHJvJyBhbmRcbiAgICBAZ2V0KCdwYWdlU3RlcCcpIGlzICdpbnRybydcbiAgICAgICMgdGhpcyBpcyBhICdkdW1teScgc3RlcCBzZXQgYnkgQHNldHRpbmdzIGluaXRpYWxpemF0aW9uLFxuICAgICAgIyB0byBpbmRpY2F0ZSBhIG5ldyB1c2VyLiAgU2V0dGluZ3MgY2FuJ3QgY2FsbCBAcmVzYXJ0IGRpcmVjdGx5XG4gICAgICAjIGR1ZSB0byB0aGUgY2lyY3VsYXIgcmVxdWlyZSgpIGl0IHdvdWxkIGVudGFpbC4uXG4gICAgICBAcmVzdGFydCgpXG5cbiAgaGlnaGxpZ2h0c0NoYW5nZWQ6IC0+XG4gICAgaGlnaGxpZ2h0cyA9IEBnZXQgJ3NlcnBIaWdobGlnaHRzJ1xuICAgIGlmIF8uaXNFcXVhbChoaWdobGlnaHRzLCBbJ2FjdGl2YXRlLWtleXdvcmQtZGlmZmljdWx0eSddKSBhbmRcbiAgICBub3QgQHVzZXIuZ2V0ICdpc1BybydcbiAgICAgIEBuZXh0U3RlcCgpXG5cbiAgICBAZGlzcGF0Y2hlci50cmlnZ2VyICdvbmJvYXJkaW5nSGlnaGxpZ2h0czpjaGFuZ2UnXG5cbiAgdXBkYXRlQWRkcmVzc0JhckhpZ2hsaWdodDogKHN0ZXApIC0+XG4gICAgc2hvdyA9IGlmIC9hZGRyZXNzLWJhci8udGVzdChzdGVwKSB0aGVuICdzaG93JyBlbHNlICdoaWRlJ1xuICAgIEBkaXNwYXRjaGVyLnRyaWdnZXIgXCJhZGRyZXNzLWJhci1oaWdobGlnaHQ6I3tzaG93fVwiXG5cbiAgZ2V0SGlnaGxpZ2h0czogLT5cbiAgICBuYW1lID0gaWYgUGFnZS5pc1NlcnAoKSB0aGVuICdzZXJwJyBlbHNlICdwYWdlJ1xuICAgIEBnZXQoXCIje25hbWV9SGlnaGxpZ2h0c1wiKS5jb25jYXQgQGdldCAnc2hhcmVkSGlnaGxpZ2h0cydcblxuICByZW1vdmVIaWdobGlnaHRzOiAoaGlnaGxpZ2h0cykgLT5cbiAgICBuYW1lID0gaWYgUGFnZS5pc1NlcnAoKSB0aGVuICdzZXJwJyBlbHNlICdwYWdlJ1xuXG4gICAgYWxsSGlnaGxpZ2h0cyA9IEBzaGFyZWRIaWdobGlnaHRzLmNvbmNhdCBAc2VycEhpZ2hsaWdodHMsIEBwYWdlSGlnaGxpZ2h0c1xuICAgIGhpZ2hsaWdodHMgPSBfLmludGVyc2VjdGlvbiBoaWdobGlnaHRzLCBhbGxIaWdobGlnaHRzXG5cbiAgICB2aXNpdGVkID0gQGdldCAndmlld2VkSGlnaGxpZ2h0cydcbiAgICB2aXNpdGVkID0gdmlzaXRlZC5jb25jYXQgaGlnaGxpZ2h0c1xuICAgIEBzZXQgJ3ZpZXdlZEhpZ2hsaWdodHMnLCBfLnVuaXEgdmlzaXRlZFxuXG4gICAgQHNldCBcIiN7bmFtZX1IaWdobGlnaHRzXCIsIF8uZGlmZmVyZW5jZSBAZ2V0KFwiI3tuYW1lfUhpZ2hsaWdodHNcIiksIGhpZ2hsaWdodHNcbiAgICBAc2V0ICdzaGFyZWRIaWdobGlnaHRzJywgXy5kaWZmZXJlbmNlIEBnZXQoJ3NoYXJlZEhpZ2hsaWdodHMnKSwgaGlnaGxpZ2h0c1xuXG4gICAgQHNhdmUoKVxuXG4gIGhhc1VzZXJTZWVuSGlnaGxpZ2h0OiAoaGlnaGxpZ2h0KSAtPlxuICAgIEBnZXQoJ3ZpZXdlZEhpZ2hsaWdodHMnKS5pbmRleE9mKGhpZ2hsaWdodCkgaXNudCAtMVxuXG4gIGlzT25ib2FyZGluZ0NvbXBsZXRlOiAtPlxuICAgIEBnZXQoJ3BhZ2VTdGVwJykgaXMgJ2NvbXBsZXRlJyBhbmRcbiAgICBAZ2V0KCdwYWdlVG91ckNvbXBsZXRlJykgYW5kXG4gICAgQGdldCgnc2VycFN0ZXAnKSBpcyAnY29tcGxldGUnIGFuZFxuICAgIEBnZXQoJ3NlcnBUb3VyQ29tcGxldGUnKVxuXG4gIGhpZGVIaWdobGlnaHQ6IC0+XG4gICAgbmFtZSA9IGlmIFBhZ2UuaXNTZXJwKCkgdGhlbiAnc2VycCcgZWxzZSAncGFnZSdcbiAgICBzdGVwID0gQGdldCBcIiN7bmFtZX1TdGVwXCJcblxuICAgIGhpZ2hsaWdodHMgPSBAZ2V0SGlnaGxpZ2h0cygpXG5cbiAgICAjIG5vIGhpZ2hsaWdodHMgbGVmdD9cbiAgICBpZiBoaWdobGlnaHRzLmxlbmd0aCBpcyAwIHRoZW4gQG5leHRTdGVwKClcblxuICAgICMgbG9nZ2VkIGluIGFuZCBvbmx5IHRoZSBsb2NrIGhpZ2hsaWdodCBpcyBsZWZ0XG4gICAgaWYgXy5pc0VxdWFsKGhpZ2hsaWdodHMsIFsnbG9jayddKSBhbmQgQHVzZXIuZ2V0KCdpc1BybycpIHRoZW4gQG5leHRTdGVwKClcblxuICAgICMgbm90IGxvZ2dlZCBpbiBhbmQgb25seSB0aGUga2V5d29yZCBkaWZmaWN1bHR5IGlzIGxlZnRcbiAgICBpZiBfLmlzRXF1YWwoaGlnaGxpZ2h0cywgWydhY3RpdmF0ZS1rZXl3b3JkLWRpZmZpY3VsdHknXSkgYW5kXG4gICAgbm90IEB1c2VyLmdldCgnaXNQcm8nKVxuICAgICAgQG5leHRTdGVwKClcblxuICByZXN0YXJ0OiAtPlxuICAgIEBzZXRcbiAgICAgIHBhZ2VTdGVwOiBAcGFnZVN0ZXBzWzBdXG4gICAgICBzZXJwU3RlcDogQHNlcnBTdGVwc1swXVxuICAgICAgcGFnZUhpZ2hsaWdodHM6IEBwYWdlSGlnaGxpZ2h0c1xuICAgICAgc2VycEhpZ2hsaWdodHM6IEBzZXJwSGlnaGxpZ2h0c1xuICAgICAgc2hhcmVkSGlnaGxpZ2h0czogQHNoYXJlZEhpZ2hsaWdodHNcbiAgICAgIHBhZ2VUb3VyQ29tcGxldGU6IGZhbHNlXG4gICAgICBzZXJwVG91ckNvbXBsZXRlOiBmYWxzZVxuXG4gICAgQHNhdmUoKVxuXG4gIGNsb3NlOiAtPlxuICAgIEBzZXRcbiAgICAgIHBhZ2VTdGVwOiAnY29tcGxldGUnXG4gICAgICBzZXJwU3RlcDogJ2NvbXBsZXRlJ1xuICAgICAgcGFnZUhpZ2hsaWdodHM6IFtdXG4gICAgICBzZXJwSGlnaGxpZ2h0czogW11cbiAgICAgIHNoYXJlZEhpZ2hsaWdodHM6IFtdXG5cbiAgICBAc2F2ZSgpXG4iLCJCYWNrYm9uZSA9IHJlcXVpcmUgJ2JhY2tib25lJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIE9uYm9hcmRpbmdUaXBNb2RlbCBleHRlbmRzIEJhY2tib25lLk1vZGVsXG4gIGRlZmF1bHRzOlxuICAgIHRleHQ6ICcnXG4gICAgdG9wOiAwXG4gICAgbGVmdDogMFxuICAgIHBsYWNlbWVudDogJ2JlbG93J1xuIiwiXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG4kID0gcmVxdWlyZSAnanF1ZXJ5J1xuXG5TRVJQX0NPTkZJRyA9XG4gICdnb29nbGUnOlxuICAgIHNlbGVjdG9yOiAnLmcgLnJjJ1xuICAgIGhyZWY6ICdhLmVudHJ5VGl0bGVbaHJlZl0sIGgzIGFbaHJlZl0sIGEubCdcbiAgICBzZWFyY2hCb3g6ICcuc3JwIGZvcm1bYWN0aW9uPVwiL3NlYXJjaFwiXSAuc2ZzYmMnXG4gICAgZGVzY3JpcHRpb246ICdkaXYucyAuc3QnXG5cbiAgJ3lhaG9vJzpcbiAgICBzZWxlY3RvcjogJ2RpdiN3ZWIgPiBvbCA+IGxpJ1xuICAgIGhyZWY6ICdzcGFuLnVybCdcbiAgICBkZXNjcmlwdGlvbjogJ2Rpdi5hYnN0cidcblxuICAnYmluZyc6XG4gICAgc2VsZWN0b3I6ICdsaS5iX2FsZ28nXG4gICAgaHJlZjogJ2gyIGFbaHJlZl0nXG4gICAgZGVzY3JpcHRpb246ICdwJ1xuXG5CTEFDS0xJU1RfVVJMUyA9IFtcbiAgL1xcOlxcL1xcLy4rXFwuZ29vZ2xlXFwuLitcXC9tYXBzLyAgICAjIGdvb2dsZSBtYXBzXG4gIC9cXDpcXC9cXC9zZW9tb3pcXC56ZW5kZXNrXFwuY29tLyAgICAjIHplbmRlc2tcbiAgL1xcOlxcL1xcL3Rvb2xzXFwuYW5zd2VyZGFzaFxcLmNvbS8gICMgYW5zd2VyZGFzaFxuICAvXFw6XFwvXFwvZG9jc1xcLmdvb2dsZVxcLmNvbS8gICAgICAgIyBnb29nbGUgZG9jc1xuICAvXFw6XFwvXFwvZHJpdmVcXC5nb29nbGVcXC5jb20vICAgICAgIyBnb29nbGUgZHJpdmVcbiAgL1xcOlxcL1xcL21haWxcXC5nb29nbGVcXC5jb20vICAgICAgICMgZ21haWxcbiAgL1xcOlxcL1xcLy4rXFwubXl3b3JrZGF5XFwuY29tLyAgICAgICMgbXl3b3JrZGF5LmNvbVxuICAvXFw6XFwvXFwvbW96LmNvbVxcL3Jlc2VhcmNodG9vbHNcXC9vc2UvICMgT1NFXG5dXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUGFnZVxuICBAZWw6IG51bGxcblxuICBAdXJsOiAtPlxuICAgIHJldHVybiBAZWwgdW5sZXNzIEBlbCBpcyBudWxsXG5cbiAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgJ2EnXG5cbiAgICBpZiB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgaW4gWydjaHJvbWUtZXh0ZW5zaW9uOicsICdkYXRhOiddXG4gICAgICAjIHdlJ3JlIGluIGFuIGV4dGVuc2lvbiB0b29sYmFyIGlmcmFtZSwgdXNlIHRoZSBoYXNoXG4gICAgICBlbC5ocmVmID0gd2luZG93LmxvY2F0aW9uLmhhc2guc3Vic3RyIDFcbiAgICBlbHNlXG4gICAgICBlbC5ocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWZcblxuICAgIEBlbCA9IGVsXG5cbiAgQGhyZWY6IC0+XG4gICAgQHVybCgpLmhyZWZcblxuICBAaG9zdG5hbWU6IC0+XG4gICAgQHVybCgpLmhvc3RuYW1lXG5cbiAgQHBhdGhuYW1lOiAtPlxuICAgIEB1cmwoKS5wYXRobmFtZVxuXG4gIEBpc1NlcnA6IC0+XG4gICAgQGdldFNlcnBFbmdpbmUoKT9cblxuICBAZ2V0U2VycEVuZ2luZTogLT5cbiAgICBzd2l0Y2hcbiAgICAgIHdoZW4gQGhvc3RuYW1lKCkgaXMgJ3d3dy5iaW5nLmNvbScgYW5kXG4gICAgICBAcGF0aG5hbWUoKSBpcyAnL3NlYXJjaCdcbiAgICAgICAgJ2JpbmcnXG5cbiAgICAgIHdoZW4gL3NlYXJjaFxcLnlhaG9vXFwuLy50ZXN0IEBob3N0bmFtZSgpXG4gICAgICAgICd5YWhvbydcblxuICAgICAgd2hlbiAvKHd3d3xlbmNyeXB0ZWQpXFwuZ29vZ2xlXFwuLisvLnRlc3QoQGhvc3RuYW1lKCkpIGFuZFxuICAgICAgL1xcLyhzZWFyY2h8d2ViaHApPyQvLnRlc3QgQHBhdGhuYW1lKClcbiAgICAgICAgJ2dvb2dsZSdcblxuICBAZ2V0U2VycENvbmZpZzogLT5cbiAgICBTRVJQX0NPTkZJR1tAZ2V0U2VycEVuZ2luZSgpXVxuXG4gIEBnZXRTZWFyY2hUZXJtOiAtPlxuICAgIHRlcm0gPSBAZ2V0UGFyYW1ldGVyICdbcXBdJ1xuICAgIGRlY29kZVVSSUNvbXBvbmVudCh0ZXJtKS5yZXBsYWNlKC9cXCsvZywgJyAnKSB1bmxlc3MgXy5pc1VuZGVmaW5lZCB0ZXJtXG5cbiAgQGdldFN0YXJ0SW5kZXg6IC0+XG4gICAgcmV0dXJuIG51bGwgdW5sZXNzIEBnZXRTZXJwRW5naW5lKCkgaXMgJ2dvb2dsZSdcbiAgICBAZ2V0UGFyYW1ldGVyKCdzdGFydCcpIG9yIDBcblxuICAjIGxvb2tzIGZvciBhIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXIgaW4gYm90aCA/Li4gYW5kICMuLlxuICBAZ2V0UGFyYW1ldGVyOiAocGFyYW0pIC0+XG4gICAgcGFyYW1zID0gd2luZG93LmxvY2F0aW9uLmhhc2ggb3Igd2luZG93LmxvY2F0aW9uLnNlYXJjaFxuICAgIChuZXcgUmVnRXhwIFwiW1xcP1xcJlxcI10je3BhcmFtfVxcPShbXiZdKilcIikuZXhlYyhwYXJhbXMpP1sxXVxuXG4gICMgTG90cyBvZiB3YXlzIHRvIHNwZWNpZnkgbWV0YSB0YWdzLi5cbiAgQHJlYWRNZXRhVGFnOiAobmFtZSkgLT5cbiAgICAoJCBcIm1ldGFbbmFtZT0nI3tuYW1lfSddXCIpLnByb3AoJ2NvbnRlbnQnKSBvclxuICAgICgkIFwibWV0YVtwcm9wZXJ0eT0nI3tuYW1lfSddXCIpLnByb3AoJ2NvbnRlbnQnKSBvclxuICAgICgkIFwibWV0YVtuYW1lPScje25hbWV9J11cIikuYXR0cigndmFsdWUnKSBvclxuICAgICgkIFwibWV0YVtwcm9wZXJ0eT0nI3tuYW1lfSddXCIpLmF0dHIgJ3ZhbHVlJ1xuXG4gIEBpc0JsYWNrbGlzdGVkOiAtPlxuICAgIGZvciB1cmxSZSBpbiBCTEFDS0xJU1RfVVJMU1xuICAgICAgcmV0dXJuIHRydWUgaWYgdXJsUmUudGVzdCBAaHJlZigpXG5cbiAgICByZXR1cm4gZmFsc2VcbiIsIiQgPSByZXF1aXJlICdqcXVlcnknXG57Q29sbGVjdGlvbn0gPSByZXF1aXJlICdiYWNrYm9uZSdcblBhZ2VFbGVtZW50ID0gcmVxdWlyZSAnbW9kZWxzL3BhZ2VfZWxlbWVudCdcbkdlb2xvY2F0aW9uID0gcmVxdWlyZSAnbW9kZWxzL2dlb2xvY2F0aW9uJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFBhZ2VBdHRyaWJ1dGVzIGV4dGVuZHMgQ29sbGVjdGlvblxuICBnZW9sb2NhdGlvbjogR2VvbG9jYXRpb24uZ2V0SW5zdGFuY2UoKVxuXG4gIGluaXRpYWxpemU6IC0+XG4gICAgQGxpc3RlblRvIEBnZW9sb2NhdGlvbiwgJ2NoYW5nZScsIEB1cGRhdGVMb2NhdGlvblxuXG4gIGlzVmFsaWQ6IC0+XG4gICAgQG1vZGVscy5sZW5ndGggPiAwXG5cbiAgc3luYzogKG1ldGhvZCkgLT5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpIHVubGVzcyBtZXRob2QgaXMgJ3JlYWQnXG5cbiAgICBAZ2VvbG9jYXRpb24uZmV0Y2goKSB1bmxlc3MgQGdlb2xvY2F0aW9uLmlzVmFsaWQoKVxuXG4gICAgbG9hZFRpbWUgPVxuICAgICAgKHBlcmZvcm1hbmNlLnRpbWluZy5sb2FkRXZlbnRFbmQgLSBwZXJmb3JtYW5jZS50aW1pbmcucmVzcG9uc2VFbmQpIC8gMTAwMFxuXG4gICAgQHJlc2V0IFtcbiAgICAgIG5ldyBQYWdlRWxlbWVudFxuICAgICAgICB0YWc6ICdNZXRhIFJvYm90cydcbiAgICAgICAgc2VsZWN0b3I6ICdtZXRhW25hbWU9XCJyb2JvdHNcIl0nXG4gICAgICAgIGF0dHJpYnV0ZTogJ2NvbnRlbnQnXG4gICAgICBuZXcgUGFnZUVsZW1lbnRcbiAgICAgICAgdGFnOiAnUmVsPVwiY2Fub25pY2FsXCInXG4gICAgICAgIHNlbGVjdG9yOiAnbGlua1tyZWw9XCJjYW5vbmljYWxcIl0nXG4gICAgICAgIGF0dHJpYnV0ZTogJ2hyZWYnXG4gICAgICBuZXcgUGFnZUVsZW1lbnRcbiAgICAgICAgdGFnOiAnUGFnZSBMb2FkIFRpbWUnXG4gICAgICAgIGNvbnRlbnQ6IFwiI3tsb2FkVGltZX0gc2Vjb25kc1wiXG4gICAgICAgIHVybDogJ2h0dHA6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc3BlZWQvcGFnZXNwZWVkL2luc2lnaHRzLz91cmw9JyArXG4gICAgICAgICAgd2luZG93LnRvcC5kb2N1bWVudC5sb2NhdGlvbi5ocmVmXG4gICAgICBuZXcgUGFnZUVsZW1lbnRcbiAgICAgICAgdGFnOiAnR29vZ2xlIENhY2hlIFVSTCdcbiAgICAgICAgdXJsOiBcImh0dHA6Ly9nb29nbGUuY29tL3NlYXJjaD9xPWNhY2hlOlwiICtcbiAgICAgICAgICB3aW5kb3cudG9wLmRvY3VtZW50LmxvY2F0aW9uLmhyZWZcbiAgICAgIG5ldyBQYWdlRWxlbWVudFxuICAgICAgICB0YWc6ICdJUCBBZGRyZXNzJ1xuICAgICAgICBjb250ZW50OiAnJ1xuICAgICAgbmV3IFBhZ2VFbGVtZW50XG4gICAgICAgIHRhZzogJ0NvdW50cnknXG4gICAgICAgIGNvbnRlbnQ6ICcnXG4gICAgXVxuXG4gICAgQHVwZGF0ZUxvY2F0aW9uKClcblxuICB1cGRhdGVMb2NhdGlvbjogLT5cbiAgICAoQGZpbmRXaGVyZSB0YWc6ICdDb3VudHJ5Jyk/LnNldCAnY29udGVudCcsIEBnZW9sb2NhdGlvbi5nZXQgJ2NvdW50cnlfbmFtZSdcbiAgICAoQGZpbmRXaGVyZSB0YWc6ICdJUCBBZGRyZXNzJyk/LnNldCAnY29udGVudCcsIEBnZW9sb2NhdGlvbi5nZXQgJ2lwJ1xuIiwiJCA9IHJlcXVpcmUgJ2pxdWVyeSdcbl8gPSByZXF1aXJlICd1bmRlcnNjb3JlJ1xue01vZGVsfSA9IHJlcXVpcmUgJ2JhY2tib25lJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFBhZ2VFbGVtZW50IGV4dGVuZHMgTW9kZWxcbiAgZGVmYXVsdHM6XG4gICAgdGFnOiAnJyAgICAgICAgICAgICAjIGVsZW1lbnQgdGFnXG4gICAgY29udGVudDogJycgICAgICAgICAjIGNvbnRlbnQgb2YgdGhlIGVsZW1lbnRcbiAgICBjb250ZW50Q2xhc3M6ICcnICAgICMgY2xhc3MgZm9yIGNvbnRlbnRcbiAgICB1cmw6ICcnICAgICAgICAgICAgICMgdXJsIHRvIGxpbmsgdG8sIGlmIGFueVxuICAgIHNlbGVjdG9yOiBudWxsICAgICAgIyB0aGUganF1ZXJ5IHNlbGVjdG9yXG4gICAgbWV0YU5hbWU6IG51bGwgICAgICAjIGxvb2sgZm9yIG1ldGFbbmFtZV09PyAoY2FzZSBpbnNlbnNpdGl2ZSlcbiAgICBsZW5ndGg6ICctLScgICAgICAgICMgdGhlIGxlbmd0aCBvZiBjb250ZW50XG4gICAgc2hvd0xlbmd0aDogdHJ1ZSAgICAjIHNob3cgbGVuZ3RoIGluIHRoZSB2aWV3XG4gICAgbXVsdGlwbGVFcnJvcjogZmFsc2UgICAjIHdlcmUgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIHRoZSBlbGVtZW50IGZvdW5kP1xuICAgIHNob3VsZE9ubHlCZU9uZTogZmFsc2UgIyBzaG93IGVycm9yIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGluc3RhbmNlcz9cbiAgICBhdHRyaWJ1dGU6IG51bGwgICAgICMgZWxlbWVudCBhdHRyaWJ1dGUgdG8gdXNlIGZvciBAY29udGVudFxuICAgIHRydW5jYXRlOiBudWxsICAgICAgIyB0cnVuY2F0ZSBAY29udGVudCB0byBhIHNwZWNpZmljIGxlbmd0aD9cbiAgICBjb25jYXRlbmF0ZTogZmFsc2UgICMgY29uY2F0ZW5hdGUgdGV4dCBvZiBhbGwgbWF0Y2hlZCBlbGVtZW50c1xuXG4gIGluaXRpYWxpemU6IC0+XG4gICAgQHVwZGF0ZUF0dHJpYnV0ZXMoKVxuICAgIEBsaXN0ZW5UbyB0aGlzLCAnY2hhbmdlJywgQHVwZGF0ZUF0dHJpYnV0ZXNcblxuICB1cGRhdGVBdHRyaWJ1dGVzOiAtPlxuICAgIGF0dHJzID0gXy5jbG9uZSBAYXR0cmlidXRlc1xuXG4gICAgIyBpZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIHVzZSBpdCB0byBkZXRlcm1pbmUgY29udGVudFxuICAgICRlbCA9ICgkIGF0dHJzLnNlbGVjdG9yKSBpZiBhdHRycy5zZWxlY3RvclxuXG4gICAgaWYgYXR0cnMubWV0YU5hbWU/XG4gICAgICAkZWwgPSAoJCAnbWV0YVtuYW1lXScpLmZpbHRlciAtPlxuICAgICAgICB0aGlzLm5hbWUudG9Mb3dlckNhc2UoKSBpcyBhdHRycy5tZXRhTmFtZVxuXG4gICAgaWYgJGVsP1xuICAgICAgaWYgYXR0cnMuY29uY2F0ZW5hdGU/XG4gICAgICAgICMgam9pbiB0aGUgdGV4dCBvZiBhbGwgdGhlIGVsZW1lbnRzIHRvZ2V0aGVyXG4gICAgICAgIHRleHRzID0gZm9yIGl0ZW0gaW4gJGVsXG4gICAgICAgICAgaWYgYXR0cnMuYXR0cmlidXRlP1xuICAgICAgICAgICAgKCQgaXRlbSkuYXR0ciBhdHRycy5hdHRyaWJ1dGVcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAoJCBpdGVtKS50ZXh0KClcblxuICAgICAgICBhdHRycy5jb250ZW50ID0gdGV4dHMuam9pbiAgJyBcXHUyMDIyICdcblxuICAgICAgZWxzZSBpZiBhdHRycy5hdHRyaWJ1dGU/XG4gICAgICAgICMgdXNlIHRoZSBnaXZlbiBhdHRyaWJ1dGUgZm9yIHRoZSBjb250ZW50XG4gICAgICAgIGF0dHJzLmNvbnRlbnQgPSAkZWwuYXR0ciBhdHRycy5hdHRyaWJ1dGVcblxuICAgICAgZWxzZVxuICAgICAgICAjIGp1c3QgdXNlIHRoZSBlbGVtZW50J3MgdGV4dFxuICAgICAgICBhdHRycy5jb250ZW50ID0gJGVsLnRleHQoKVxuXG4gICAgICBhdHRycy5jb250ZW50ID0gJC50cmltIGF0dHJzLmNvbnRlbnRcbiAgICAgIGF0dHJzLm11bHRpcGxlRXJyb3IgPSBhdHRycy5zaG91bGRPbmx5QmVPbmUgYW5kICRlbC5sZW5ndGggPiAxXG5cbiAgICBhdHRycy5jb250ZW50ID0gYXR0cnMudXJsIHVubGVzcyBhdHRycy5jb250ZW50XG5cbiAgICAjIGNvbGxhcHNlIG11dGxpcGxlIHNwYWNlcyBpbnRvIG9uZS4gIENoYXJhY3RlciBjb3VudCBzaG91bGRcbiAgICAjIGJlIGJhc2VkIG9uIHdoYXQgdGhlIHVzZXIgc2VlcyBpbiB0aGUgYnJvd3Nlci5cbiAgICBhdHRycy5jb250ZW50ID0gYXR0cnMuY29udGVudC5yZXBsYWNlIC9cXHMrL2csICcgJ1xuICAgIGF0dHJzLmxlbmd0aCA9IGF0dHJzLmNvbnRlbnQubGVuZ3RoLnRvTG9jYWxlU3RyaW5nKClcbiAgICBhdHRycy5sZW5ndGggPSAnLS0nIGlmIGF0dHJzLmxlbmd0aCBpcyAnMCcgb3IgJGVsPy5sZW5ndGggaXMgMFxuXG4gICAgYXR0cnMuY29udGVudCA9ICdOb3QgZm91bmQnIGlmICRlbD8ubGVuZ3RoIGlzIDBcblxuICAgIGlmIGF0dHJzLnRydW5jYXRlPyBhbmQgYXR0cnMuY29udGVudC5sZW5ndGggPiBhdHRycy50cnVuY2F0ZVxuICAgICAgYXR0cnMuY29udGVudCA9IGF0dHJzLmNvbnRlbnQuc3Vic3RyKDAsIGF0dHJzLnRydW5jYXRlKSArICcuLi4nXG5cbiAgICBAc2V0IGF0dHJzXG4iLCIkID0gcmVxdWlyZSAnanF1ZXJ5J1xue0NvbGxlY3Rpb259ID0gcmVxdWlyZSAnYmFja2JvbmUnXG5QYWdlRWxlbWVudCA9IHJlcXVpcmUgJ21vZGVscy9wYWdlX2VsZW1lbnQnXG5HZW9sb2NhdGlvbiA9IHJlcXVpcmUgJ21vZGVscy9nZW9sb2NhdGlvbidcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBQYWdlRWxlbWVudHMgZXh0ZW5kcyBDb2xsZWN0aW9uXG4gIGdlb2xvY2F0aW9uOiBHZW9sb2NhdGlvbi5nZXRJbnN0YW5jZSgpXG5cbiAgaW5pdGlhbGl6ZTogLT5cbiAgICBAbGlzdGVuVG8gQGdlb2xvY2F0aW9uLCAnY2hhbmdlJywgQHVwZGF0ZUxvY2F0aW9uXG5cbiAgaXNWYWxpZDogLT5cbiAgICBAbW9kZWxzLmxlbmd0aCA+IDBcblxuICBzeW5jOiAobWV0aG9kKSAtPlxuICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJykgdW5sZXNzIG1ldGhvZCBpcyAncmVhZCdcblxuICAgIEBnZW9sb2NhdGlvbi5mZXRjaCgpIHVubGVzcyBAZ2VvbG9jYXRpb24uaXNWYWxpZCgpXG5cbiAgICBkb2MgPSB3aW5kb3cudG9wLmRvY3VtZW50XG4gICAgY29kZUxlbiA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaHRtbCcpWzBdLmlubmVySFRNTC5sZW5ndGhcbiAgICB0ZXh0VG9Db2RlUmF0aW8gPSAoKCgkICdodG1sJykudGV4dCgpLmxlbmd0aCAvIGNvZGVMZW4pICogMTAwKS50b0ZpeGVkIDJcbiAgICBAcmVzZXQgW1xuICAgICAgbmV3IFBhZ2VFbGVtZW50XG4gICAgICAgIHRhZzogJ1VSTCdcbiAgICAgICAgY29udGVudDogZG9jLmxvY2F0aW9uLmhyZWZcbiAgICAgICAgY29udGVudENsYXNzOiAnZmxhZyB1cydcbiAgICAgIG5ldyBQYWdlRWxlbWVudFxuICAgICAgICB0YWc6ICdQYWdlIFRpdGxlJ1xuICAgICAgICBzZWxlY3RvcjogJ3RpdGxlJ1xuICAgICAgbmV3IFBhZ2VFbGVtZW50XG4gICAgICAgIHRhZzogJ01ldGEgRGVzY3JpcHRpb24nXG4gICAgICAgIG1ldGFOYW1lOiAnZGVzY3JpcHRpb24nXG4gICAgICAgIGF0dHJpYnV0ZTogJ2NvbnRlbnQnXG4gICAgICAgIHNob3VsZE9ubHlCZU9uZTogdHJ1ZVxuICAgICAgbmV3IFBhZ2VFbGVtZW50XG4gICAgICAgIHRhZzogJ01ldGEgS2V5d29yZHMnXG4gICAgICAgIG1ldGFOYW1lOiAna2V5d29yZHMnXG4gICAgICAgIGF0dHJpYnV0ZTogJ2NvbnRlbnQnXG4gICAgICAgIHNob3VsZE9ubHlCZU9uZTogdHJ1ZVxuICAgICAgbmV3IFBhZ2VFbGVtZW50XG4gICAgICAgIHRhZzogJ0gxJ1xuICAgICAgICBzZWxlY3RvcjogJ2gxJ1xuICAgICAgICBjb25jYXRlbmF0ZTogdHJ1ZVxuICAgICAgbmV3IFBhZ2VFbGVtZW50XG4gICAgICAgIHRhZzogJ0gyJ1xuICAgICAgICBzZWxlY3RvcjogJ2gyJ1xuICAgICAgICBjb25jYXRlbmF0ZTogdHJ1ZVxuICAgICAgbmV3IFBhZ2VFbGVtZW50XG4gICAgICAgIHRhZzogJ0JvbGQvU3Ryb25nJ1xuICAgICAgICBzZWxlY3RvcjogJ2Isc3Ryb25nJ1xuICAgICAgICBjb25jYXRlbmF0ZTogdHJ1ZVxuICAgICAgbmV3IFBhZ2VFbGVtZW50XG4gICAgICAgIHRhZzogJ0l0YWxpYy9lbSdcbiAgICAgICAgc2VsZWN0b3I6ICdpLGVtJ1xuICAgICAgICBjb25jYXRlbmF0ZTogdHJ1ZVxuICAgICAgbmV3IFBhZ2VFbGVtZW50XG4gICAgICAgIHRhZzogJ0FsdCBUZXh0J1xuICAgICAgICBzZWxlY3RvcjogJ2ltZ1thbHRdW2FsdCE9XCJcIl0nXG4gICAgICAgIGF0dHJpYnV0ZTogJ2FsdCdcbiAgICAgICAgY29uY2F0ZW5hdGU6IHRydWVcbiAgICBdXG5cbiAgICBAdXBkYXRlTG9jYXRpb24oKVxuXG4gIHVwZGF0ZUxvY2F0aW9uOiAtPlxuICAgIGNvZGUgPSBAZ2VvbG9jYXRpb24uZ2V0KCdjb3VudHJ5X2NvZGUnKT8udG9Mb3dlckNhc2UoKVxuICAgIChAZmluZFdoZXJlIHRhZzogJ1VSTCcpPy5zZXQgJ2NvbnRlbnRDbGFzcycsIFwiZmxhZyAje2NvZGV9XCJcbiIsIl8gPSByZXF1aXJlICd1bmRlcnNjb3JlJ1xue01vZGVsfSA9IHJlcXVpcmUgJ2JhY2tib25lJ1xuU2V0dGluZ3MgPSByZXF1aXJlICdtb2RlbHMvc2V0dGluZ3MnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUHJvZmlsZSBleHRlbmRzIE1vZGVsXG4gIHNldHRpbmdzOiBTZXR0aW5ncy5nZXRJbnN0YW5jZSgpXG5cbiAgZGVmYXVsdHM6XG4gICAgbmFtZTogJydcbiAgICBlbmdpbmU6ICdnb29nbGUnXG4gICAgZGlzYWJsZVBlcnNvbmFsaXphdGlvbjogZmFsc2VcbiAgICBjb3VudHJ5OiAnVVMnXG4gICAgcmVnaW9uOiAnJ1xuICAgIGNpdHk6ICcnXG5cbiAgc3luYzogKG1ldGhvZCkgLT5cbiAgICBwcm9maWxlcyA9IF8uY2xvbmUgQHNldHRpbmdzLmdldCAncHJvZmlsZXMnXG4gICAgcHJvZmlsZSA9IF8uZmluZCBwcm9maWxlcywgKHApID0+IHAuaWQgaXMgQGdldCAnaWQnXG5cbiAgICBzd2l0Y2ggbWV0aG9kXG4gICAgICB3aGVuICd1cGRhdGUnXG4gICAgICAgIF8uZXh0ZW5kIHByb2ZpbGUsIEBhdHRyaWJ1dGVzXG4gICAgICAgIEBzYXZlUHJvZmlsZXMgcHJvZmlsZXNcblxuICAgICAgd2hlbiAnY3JlYXRlJ1xuICAgICAgICBtYXhJZCA9IF8ubWF4IChwLmlkIGZvciBwIGluIHByb2ZpbGVzKVxuICAgICAgICBAc2V0ICdpZCcsIG1heElkICsgMVxuXG4gICAgICAgIHByb2ZpbGVzLnB1c2ggQGF0dHJpYnV0ZXNcbiAgICAgICAgQHNhdmVQcm9maWxlcyBwcm9maWxlc1xuXG4gICAgICB3aGVuICdkZWxldGUnXG4gICAgICAgIHByb2ZpbGVzID0gXy53aXRob3V0IHByb2ZpbGVzLCBwcm9maWxlXG4gICAgICAgIEBzYXZlUHJvZmlsZXMgcHJvZmlsZXNcblxuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IgXCJ7I21ldGhvZH0gbm90IGltcGxlbWVudGVkXCJcblxuICBzYXZlUHJvZmlsZXM6IChwcm9maWxlcykgLT5cbiAgICBAc2V0dGluZ3Muc2V0ICdwcm9maWxlcycsIHByb2ZpbGVzXG4gICAgQHNldHRpbmdzLnNhdmUoKVxuIiwie0NvbGxlY3Rpb259ID0gcmVxdWlyZSAnYmFja2JvbmUnXG5Qcm9maWxlID0gcmVxdWlyZSAnbW9kZWxzL3Byb2ZpbGUnXG5TZXR0aW5ncyA9IHJlcXVpcmUgJ21vZGVscy9zZXR0aW5ncydcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBQcm9maWxlcyBleHRlbmRzIENvbGxlY3Rpb25cbiAgc2V0dGluZ3M6IFNldHRpbmdzLmdldEluc3RhbmNlKClcbiAgbW9kZWw6IFByb2ZpbGVcblxuICBpbml0aWFsaXplOiAtPlxuICAgIEBmZXRjaCgpXG4gICAgQGxpc3RlblRvIEBzZXR0aW5ncywgJ2NoYW5nZTpwcm9maWxlcycsIEBmZXRjaFxuXG4gIHN5bmM6IChtZXRob2QpIC0+XG4gICAgc3dpdGNoIG1ldGhvZFxuICAgICAgd2hlbiAncmVhZCdcbiAgICAgICAgQHNldCBAc2V0dGluZ3MuZ2V0ICdwcm9maWxlcydcbiIsIkJhY2tib25lID0gcmVxdWlyZSAnYmFja2JvbmUnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUmVnaW9ucyBleHRlbmRzIEJhY2tib25lLkNvbGxlY3Rpb25cbiAgY291bnRyeTogJ1VTJ1xuXG4gIHVybDogLT5cbiAgICBcImh0dHBzOi8vZDJlZWlwY3JjZGxlNi5jbG91ZGZyb250Lm5ldC9tb3piYXIvcmVnaW9ucy8je0Bjb3VudHJ5fS5qc29uXCJcbiIsIl8gPSByZXF1aXJlICd1bmRlcnNjb3JlJ1xuJCA9IHJlcXVpcmUgJ2pxdWVyeSdcbntNb2RlbH0gPSByZXF1aXJlICdiYWNrYm9uZSdcblBhZ2UgPSByZXF1aXJlICdtb2RlbHMvcGFnZSdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTZW1hbnRpY3MgZXh0ZW5kcyBNb2RlbFxuICAjIGh0dHA6Ly9taWNyb2Zvcm1hdHMub3JnL3dpa2kvbWljcm9mb3JtYXRzLTJcbiAgbWljcm9mb3JtYXRzMkNsYXNzZXMgPSBbXG4gICAgJ2gtYWRyJ1xuICAgICdoLWNhcmQnXG4gICAgJ2gtZW50cnknXG4gICAgJ2gtZXZlbnQnXG4gICAgJ2gtZmVlZCdcbiAgICAnaC1nZW8nXG4gICAgJ2gtaXRlbSdcbiAgICAnaC1saXN0aW5nJ1xuICAgICdoLXByb2R1Y3QnXG4gICAgJ2gtcmVjaXBlJ1xuICAgICdoLXJlc3VtZSdcbiAgICAnaC1yZXZpZXcnXG4gICAgJ2gtcmV2aWV3LWFnZ3JlZ2F0ZSdcbiAgXVxuXG4gIGRlZmF1bHRzOlxuICAgIGhhc1NjaGVtYTogbnVsbFxuICAgIGhhc1R3aXR0ZXI6IG51bGxcbiAgICBwYWdlVXJsOiBQYWdlLmhyZWYoKVxuICAgIHJpY2hTbmlwcGV0VG9vbFVybDpcbiAgICAgICdodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWJtYXN0ZXJzL3N0cnVjdHVyZWQtZGF0YS90ZXN0aW5nLXRvb2wnICtcbiAgICAgIFwiP3VybD0je2VuY29kZVVSSUNvbXBvbmVudCBQYWdlLmhyZWYoKX1cIlxuICAgIG9wZW5HcmFwaFRvb2xVcmw6XG4gICAgICAnaHR0cHM6Ly9kZXZlbG9wZXJzLmZhY2Vib29rLmNvbS90b29scy9kZWJ1Zy9vZy9vYmplY3Q/cT0nICtcbiAgICAgIGVuY29kZVVSSUNvbXBvbmVudCBQYWdlLmhyZWYoKVxuXG4gIHVybDogLT5cbiAgICBAZ2V0ICdyaWNoU25pcHBldFRvb2xVcmwnXG5cbiAgc3luYzogKG1ldGhvZCkgLT5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpIHVubGVzcyBtZXRob2QgaXMgJ3JlYWQnXG5cbiAgICBAc2V0XG4gICAgICBkZXNjcmlwdGlvbjogKCQgJ21ldGFbbmFtZT1cImRlc2NyaXB0aW9uXCJdJykucHJvcCAnY29udGVudCdcbiAgICAgIGhhc1NjaGVtYTogKCQgJ1tpdGVtc2NvcGVdW2l0ZW10eXBlXj1cImh0dHA6Ly9zY2hlbWEub3JnL1wiXScpLmxlbmd0aFxuICAgICAgaGFzT3BlbkdyYXBoOlxuICAgICAgICBQYWdlLnJlYWRNZXRhVGFnKCdvZzp0aXRsZScpIG9yXG4gICAgICAgIFBhZ2UucmVhZE1ldGFUYWcoJ29nOnR5cGUnKSBvclxuICAgICAgICBQYWdlLnJlYWRNZXRhVGFnKCdvZzppbWFnZScpIG9yXG4gICAgICAgIFBhZ2UucmVhZE1ldGFUYWcoJ29nOnVybCcpIG9yXG4gICAgICAgIFBhZ2UucmVhZE1ldGFUYWcoJ29nOmRlc2NyaXB0aW9uJykgb3JcbiAgICAgICAgUGFnZS5yZWFkTWV0YVRhZygnb2c6YXVkaW8nKSBvclxuICAgICAgICBQYWdlLnJlYWRNZXRhVGFnKCdvZzp2aWRlbycpXG4gICAgICBoYXNUd2l0dGVyOlxuICAgICAgICBQYWdlLnJlYWRNZXRhVGFnKCd0d2l0dGVyOmNhcmQnKVxuICAgICAgaGFzTWljcm9mb3JtYXRzOlxuICAgICAgICAoJCAnLnZjYXJkJykubGVuZ3RoIG9yXG4gICAgICAgIF8uZmluZCBAbWljcm9mb3JtYXRzMkNsYXNzZXMsIChjbGFzc05hbWUpIC0+XG4gICAgICAgICAgKCQgXCIuI3tjbGFzc05hbWV9XCIpLmxlbmd0aFxuXG4gIHZhbGlkYXRlOiAoYXR0cnMpIC0+XG4gICAgJ0RhdGEgbm90IGxvYWRlZCcgaWYgXy5pc051bGwgYXR0cnMuaGFzU2NoZW1hXG4iLCIkID0gcmVxdWlyZSAnanF1ZXJ5J1xue01vZGVsfSA9IHJlcXVpcmUgJ2JhY2tib25lJ1xuUGFnZSA9IHJlcXVpcmUgJ21vZGVscy9wYWdlJ1xuU2VycFJlc3VsdHNNZXRyaWNzID0gcmVxdWlyZSAnbW9kZWxzL3NlcnBfcmVzdWx0c19tZXRyaWNzJ1xuXG4jIHRoaXMgbW9kZWwgcGFyc2VzIHRoZSBnaXZlbiBzZXJwIGJsb2NrICgkZWwpIGludG8gY29tcG9uZW50XG4jIHBhcnRzXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgU2VycEF0dHJpYnV0ZXMgZXh0ZW5kcyBNb2RlbFxuICAkZWw6IG51bGxcblxuICBkZWZhdWx0czpcbiAgICBlbDogbnVsbFxuICAgIHVybDogbnVsbFxuICAgIHRpdGxlOiBudWxsXG4gICAgZGVzY3JpcHRpb246IG51bGxcbiAgICBtZXRyaWNzOiBudWxsXG5cbiAgaW5pdGlhbGl6ZTogKGF0dHJpYnV0ZXMpIC0+XG4gICAgc3VwZXJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVkIGF0dHJpYnV0ZSAkZWwgbm90IHNldCEnKSB1bmxlc3MgQGdldCAnZWwnXG4gICAgQCRlbCA9ICgkIEBnZXQgJ2VsJylcblxuICAgIHVybCA9IEBnZXRVcmwoKVxuICAgIG1ldHJpY3MgPSBTZXJwUmVzdWx0c01ldHJpY3MuZ2V0SW5zdGFuY2UoKS5nZXRQYWdlTWV0cmljcyB1cmxcbiAgICBtZXRyaWNzLnNldCBwb3NpdGlvbjogYXR0cmlidXRlcy5wb3NpdGlvblxuXG4gICAgQHNldFxuICAgICAgdXJsOiB1cmxcbiAgICAgIHRpdGxlOiBAZ2V0VGl0bGUoKVxuICAgICAgZGVzY3JpcHRpb246IEBnZXREZXNjcmlwdGlvbigpXG4gICAgICBtZXRyaWNzOiBtZXRyaWNzXG5cbiAgZ2V0VXJsOiAtPlxuICAgICRocmVmID0gQCRlbC5maW5kIFBhZ2UuZ2V0U2VycENvbmZpZygpLmhyZWZcbiAgICBzd2l0Y2ggUGFnZS5nZXRTZXJwRW5naW5lKClcbiAgICAgIHdoZW4gJ2dvb2dsZScsICdiaW5nJyB0aGVuICRocmVmLmF0dHIgJ2hyZWYnXG4gICAgICB3aGVuICd5YWhvbycgdGhlbiAkaHJlZi50ZXh0KClcblxuICBnZXRUaXRsZTogLT5cbiAgICBAJGVsLmZpbmQoUGFnZS5nZXRTZXJwQ29uZmlnKCkuaHJlZikudGV4dCgpXG5cbiAgZ2V0RGVzY3JpcHRpb246IC0+XG4gICAgJGRlc2MgPSBAJGVsLmZpbmQoUGFnZS5nZXRTZXJwQ29uZmlnKCkuZGVzY3JpcHRpb24pXG4gICAgc3dpdGNoIFBhZ2UuZ2V0U2VycEVuZ2luZSgpXG4gICAgICB3aGVuICdnb29nbGUnIHRoZW4gJGRlc2MuY2xvbmUoKS5jaGlsZHJlbignLmYnKS5yZW1vdmUoKS5lbmQoKS50ZXh0KClcbiAgICAgIGVsc2UgJGRlc2MudGV4dCgpXG4iLCJfID0gcmVxdWlyZSAndW5kZXJzY29yZSdcbiQgPSByZXF1aXJlICdqcXVlcnknXG57Q29sbGVjdGlvbn0gPSByZXF1aXJlICdiYWNrYm9uZSdcblBhZ2UgPSByZXF1aXJlICdtb2RlbHMvcGFnZSdcblVybE1ldHJpY3MgPSByZXF1aXJlICdtb2RlbHMvdXJsX21ldHJpY3MnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgU2VycFJlc3VsdHNNZXRyaWNzIGV4dGVuZHMgQ29sbGVjdGlvblxuICAjIGtlZXAgYSBzaW5nbGUgaW5zdGFuY2UgYXJvdW5kIHNvIHdlIGNhbiByZXVzZSBtZXRyaWNzXG4gICMgYmV0d2VlbiBzZXJwIHJlc3VsdHMgYW5kIGtleXdvcmQgZGlmZmljdWx0eVxuICBAc2VycFJlc3VsdHNNZXRyaWNzOiBudWxsXG4gIEBnZXRJbnN0YW5jZTogLT5cbiAgICBAc2VycFJlc3VsdHNNZXRyaWNzID89IG5ldyBTZXJwUmVzdWx0c01ldHJpY3NcblxuICAjIHJldHVybnMgVXJsTWV0cmljcyBmb3IgdGhlIGdpdmVuIHVybCwgYWRkaW5nIGl0IGlmIGl0IGRvZXNuJ3QgYWxyZWFkeVxuICAjIGV4aXN0XG4gIGdldFBhZ2VNZXRyaWNzOiAodXJsKSAtPlxuICAgIG1ldHJpY3MgPSBAZmluZFdoZXJlIHBhZ2VVcmw6IHVybFxuICAgIG1ldHJpY3MgPz0gQGFkZCBuZXcgVXJsTWV0cmljcyBwYWdlVXJsOiB1cmxcblxuICAjIHZhbGlkIGlmIGFsbCBtZXRyaWNzIGhhdmUgYmVlbiBsb2FkZWRcbiAgIyBpZiB1cmxzIGlzIHNwZWNpZmllZCwgb25seSBjaGVja3MgdGhvc2UgdXJscy5cbiAgaXNWYWxpZDogKHVybHMpIC0+XG4gICAgbW9kZWxzID0gQGdldE1ldHJpY3NGb3JVcmxzIHVybHNcbiAgICBfLmlzVW5kZWZpbmVkIF8uZmluZCBtb2RlbHMsIChtb2RlbCkgLT4gbm90IG1vZGVsLmlzVmFsaWQoKVxuXG4gIGlzTG9hZGVkOiAodXJscykgLT5cbiAgICBtb2RlbHMgPSBAZ2V0TWV0cmljc0ZvclVybHMgdXJsc1xuICAgIF8uaXNVbmRlZmluZWQgXy5maW5kIG1vZGVscywgKG1vZGVsKSAtPiBub3QgbW9kZWwuaXNMb2FkZWRcblxuICBnZXRNZXRyaWNzRm9yVXJsczogKHVybHMpIC0+XG4gICAgbW9kZWxzID0gaWYgdXJscyB0aGVuIEBmaW5kTWV0cmljc0J5VXJscyh1cmxzKSBlbHNlIEBtb2RlbHNcblxuICBmaW5kTWV0cmljc0J5VXJsczogKHVybHMpIC0+XG4gICAgbW9kZWwgZm9yIG1vZGVsIGluIEBtb2RlbHMgd2hlbiBtb2RlbC5nZXQoJ3BhZ2VVcmwnKSBpbiB1cmxzXG4iLCJfID0gcmVxdWlyZSAndW5kZXJzY29yZSdcbntNb2RlbH0gPSByZXF1aXJlICdiYWNrYm9uZSdcblVzZXIgPSByZXF1aXJlICdtb2RlbHMvdXNlcidcblNldHRpbmdzID0gcmVxdWlyZSAnbW9kZWxzL3NldHRpbmdzJ1xuUHJvZmlsZXMgPSByZXF1aXJlICdtb2RlbHMvcHJvZmlsZXMnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgU2VycFRvb2JhciBleHRlbmRzIE1vZGVsXG4gIHNldHRpbmdzOiBTZXR0aW5ncy5nZXRJbnN0YW5jZSgpXG4gIHVzZXI6IFVzZXIuZ2V0SW5zdGFuY2UoKVxuXG4gIHByb2ZpbGVzOiBuZXcgUHJvZmlsZXNcblxuICBpbml0aWFsaXplOiAtPlxuICAgIEB1cGRhdGVQcm9maWxlKClcbiAgICBAbGlzdGVuVG8gQHNldHRpbmdzLCAnY2hhbmdlOnNlbGVjdGVkUHJvZmlsZUlkJywgQHVwZGF0ZVByb2ZpbGVcbiAgICBAbGlzdGVuVG8gQHVzZXIsICdjaGFuZ2UnLCA9PiBAdHJpZ2dlciAnY2hhbmdlJ1xuXG4gIHVwZGF0ZVByb2ZpbGU6IC0+XG4gICAgcHJvZmlsZSA9IEBwcm9maWxlcy5nZXQoQHNldHRpbmdzLmdldCAnc2VsZWN0ZWRQcm9maWxlSWQnKVxuICAgIHByb2ZpbGUgPSBAcHJvZmlsZXMuYXQgMCB1bmxlc3MgcHJvZmlsZT9cbiAgICBAc2V0ICdwcm9maWxlJywgcHJvZmlsZVxuXG4gIHRvSlNPTjogLT5cbiAgICBfLmV4dGVuZCBfLmNsb25lKEBhdHRyaWJ1dGVzKSxcbiAgICAgIHVzZXI6IEB1c2VyLnRvSlNPTigpXG4gICAgICBwcm9maWxlOiBAZ2V0KCdwcm9maWxlJykudG9KU09OKClcbiIsIl8gPSByZXF1aXJlICd1bmRlcnNjb3JlJ1xuQmFja2JvbmUgPSByZXF1aXJlICdiYWNrYm9uZSdcblNpbXBsZVN0b3JhZ2UgPSByZXF1aXJlICdzZGsvc2ltcGxlLXN0b3JhZ2UnXG5cbiMgTm90ZTogcmV0dXJucyBhbiBpbnN0YW50aWF0ZWQgaW5zdGFuY2UgLS0gdGhlcmUgc2hvdWxkIG9ubHkgYmUgb25lXG4jIHNldHRpbmdzIG9iamVjdCBpbiBtZW1vcnkuXG4jXG4jIFNldHRpbmdzIGFyZSBzdG9yZWQgaW5cbiMgfi9MaWJyYXJ5L0FwcGxpY2F0aW9uIFN1cHBvcnQvR29vZ2xlL0Nocm9tZS9EZWZhdWx0L1N5bmMgRXh0ZW5zaW9uIFNldHRpbmdzXG4jIGRlbGV0ZSB0aGlzIHRvIHJlc2V0IHRvIGEgZnJlc2ggc3RhdGUuXG4jXG5cbiMgdmVyc2lvbiBvZiBzZXR0aW5ncyBzY2hlbWEuICAgaW5jcmVtZW50IHdoZW4gbmV3IHNldHRpbmdzIGFyZSBhZGRlZC5cblNFVFRJTkdTX1ZFUlNJT04gPSAxXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgU2V0dGluZ3MgZXh0ZW5kcyBCYWNrYm9uZS5Nb2RlbFxuICBAc2V0dGluZ3M6IG51bGxcbiAgQHNhdmVkQXR0cmlidXRlczogbnVsbFxuXG4gIEBnZXRJbnN0YW5jZTogLT5cbiAgICBAc2V0dGluZ3MgPz0gbmV3IFNldHRpbmdzXG5cbiAgZGVmYXVsdHM6XG4gICAgdmVyc2lvbjogU0VUVElOR1NfVkVSU0lPTlxuXG4gICAgaXNNb3piYXJPbjogbnVsbFxuXG4gICAgIyBkb24ndCBzaG93IHRvb2xiYXIsIGJ1dCBzaG93IGJhZGdlIGluIGJ1dHRvblxuICAgIGlzQnV0dG9uT246IG51bGxcblxuICAgICMgdXNlIHRoZSBsaWdodCB0aGVtZT9cbiAgICBpc0xpZ2h0VGhlbWU6IGZhbHNlXG5cbiAgICAjIGRvY2tlZCBvbiBib3R0b20/XG4gICAgaXNEb2NrZWRPbkJvdHRvbTogZmFsc2VcblxuICAgICMgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgdXNlciBvbiBtaXhwYW5lbFxuICAgIG1peHBhbmVsSWQ6IG51bGxcblxuICAgICMgdGltZSBvZiBsYXN0IGFjdGl2ZSB1c2VyIGV2ZW50IHNlbnQgdG8gbWl4cGFuZWxcbiAgICBsYXN0TWl4cGFuZWxBY3RpdmVVc2VyOiAwXG5cbiAgICAjIHNlYXJjaCBwcm9maWxlc1xuICAgIHNlbGVjdGVkUHJvZmlsZUlkOiAxXG4gICAgcHJvZmlsZXM6IFtcbiAgICAgIGlkOiAxXG4gICAgICBuYW1lOiAnR29vZ2xlIFVTIChub24tcGVyc29uYWxpemVkKSdcbiAgICAgIGVuZ2luZTogJ2dvb2dsZSdcbiAgICAgIGRpc2FibGVQZXJzb25hbGl6YXRpb246IHRydWVcbiAgICAgIGNvdW50cnk6ICdVUydcbiAgICAgIHJlZ2lvbjogJydcbiAgICAgIGNpdHk6ICcnXG4gICAgLFxuICAgICAgaWQ6IDJcbiAgICAgIG5hbWU6ICdCaW5nIFVTJ1xuICAgICAgZW5naW5lOiAnYmluZydcbiAgICAgIGRpc2FibGVQZXJzb25hbGl6YXRpb246IGZhbHNlXG4gICAgICBjb3VudHJ5OiAnVVMnXG4gICAgICByZWdpb246ICcnXG4gICAgICBjaXR5OiAnJ1xuICAgICxcbiAgICAgIGlkOiAzXG4gICAgICBuYW1lOiAnWWFob28gVVMnXG4gICAgICBlbmdpbmU6ICd5YWhvbydcbiAgICAgIGRpc2FibGVQZXJzb25hbGl6YXRpb246IGZhbHNlXG4gICAgICBjb3VudHJ5OiAnVVMnXG4gICAgICByZWdpb246ICcnXG4gICAgICBjaXR5OiAnJ1xuICAgIF1cblxuICAgICMgY29uZmlndXJhYmxlIHJhbmtpbmdzIHRvIHJldHJpZXZlXG4gICAgbWV0cmljc0NvbHM6IFsnZnRycCcsICdmc3BzYyddXG5cbiAgICAjIGNhY2hlZCB1c2VyIGNyZWRlbnRpYWxzXG4gICAgdXNlcjpcbiAgICAgIGFjY2Vzc19pZDogJydcbiAgICAgIGV4cGlyZXM6IDBcbiAgICAgIGxldmVsOiAnbWVtYmVyJ1xuXG4gICAgb25ib2FyZGluZzpcbiAgICAgIHBhZ2VTdGVwOiAnbGVnYWN5LXVzZXInXG4gICAgICBzZXJwU3RlcDogJ2xlZ2FjeS11c2VyJ1xuICAgICAgcGFnZUhpZ2hsaWdodEJ1dHRvbnM6IFtdXG4gICAgICBzZXJwSGlnaGxpZ2h0QnV0dG9uczogW11cblxuICAgICMgbmV3IGluc3RhbGw/XG4gICAgaXNOZXdJbnN0YWxsOiBmYWxzZVxuXG4gIGluaXRpYWxpemU6IC0+XG4gICAgQGZldGNoKClcblxuICAgICMgcmVhZCAoYW5kIHRyaWdnZXIgY2hhbmdlKSBpZiBzb21lb25lIChpLmUuIHRoZSBjaHJvbWUgYnV0dG9uKVxuICAgICMgY2hhbmdlZCBzZXR0aW5nc1xuICAgIGNocm9tZT8uc3RvcmFnZS5vbkNoYW5nZWQuYWRkTGlzdGVuZXIgPT5cbiAgICAgIEBmZXRjaCgpXG5cbiAgICBzZWxmPy5wb3J0Py5vbiAnc2V0dGluZ3NDaGFuZ2VkJywgKGF0dHJpYnV0ZXMpID0+XG4gICAgICBAc2V0IGF0dHJpYnV0ZXNcblxuICBvbk5ld0luc3RhbGw6IC0+XG4gICAgQHNldFxuICAgICAgaXNNb3piYXJPbjogdHJ1ZVxuICAgICAgaXNCdXR0b25PbjogdHJ1ZVxuICAgICAgaXNMaWdodFRoZW1lOiB0cnVlXG4gICAgICBvbmJvYXJkaW5nOlxuICAgICAgICBwYWdlU3RlcDogJ2ludHJvJ1xuICAgICAgICBzZXJwU3RlcDogJ2ludHJvJ1xuXG4gICAgQHNhdmUoKVxuXG4gIHRvZ2dsZU1vemJhcjogLT5cbiAgICAjIG1vemJhcitidXR0b24gLT4gYnV0dG9uIC0+IG5vbmVcbiAgICBzd2l0Y2hcbiAgICAgIHdoZW4gQGdldCAnaXNNb3piYXJPbicgdGhlbiBAc2V0IGlzTW96YmFyT246IGZhbHNlXG4gICAgICB3aGVuIEBnZXQgJ2lzQnV0dG9uT24nIHRoZW4gQHNldCBpc0J1dHRvbk9uOiBmYWxzZVxuICAgICAgZWxzZSBAc2V0IGlzQnV0dG9uT246IHRydWUsIGlzTW96YmFyT246IHRydWVcblxuICAgIEByZXNldFBhbmVsU3RhdGUoKVxuICAgIEBzYXZlKClcblxuICB0b2dnbGVEb2NrUG9zaXRpb246IC0+XG4gICAgQHNldCAnaXNEb2NrZWRPbkJvdHRvbScsIG5vdCBAZ2V0ICdpc0RvY2tlZE9uQm90dG9tJ1xuICAgIEBzYXZlKClcblxuICByZXNldFBhbmVsU3RhdGU6IC0+XG4gICAgQHNldFxuICAgICAgc2VsZWN0ZWRQYW5lbDogJydcbiAgICAgIGhpZ2hsaWdodExpbmtzOiBbXVxuICAgICAgaGlnaGxpZ2h0S2V5d29yZDogJydcbiAgICAgIGluZm9QYW5lbFRhYjogJ3BhZ2UtZWxlbWVudHMnXG5cbiAgc3luYzogKG1ldGhvZCkgLT5cbiAgICBzd2l0Y2ggbWV0aG9kXG4gICAgICB3aGVuICdjcmVhdGUnLCAndXBkYXRlJywgJ3BhdGNoJ1xuICAgICAgICByZXR1cm4gaWYgXy5pc0VxdWFsIEBhdHRyaWJ1dGVzLCBAc2F2ZWRBdHRyaWJ1dGVzXG4gICAgICAgIGNocm9tZT8uc3RvcmFnZS5zeW5jLnNldCBAYXR0cmlidXRlc1xuICAgICAgICBpZiBTaW1wbGVTdG9yYWdlPy5zdG9yYWdlP1xuICAgICAgICAgIFNpbXBsZVN0b3JhZ2Uuc3RvcmFnZVtrZXldID0gdmFsdWUgZm9yIGtleSwgdmFsdWUgb2YgQGF0dHJpYnV0ZXNcblxuICAgICAgICBzZWxmPy5wb3J0Py5lbWl0ICdzZXR0aW5nc0NoYW5nZWQnLCBAYXR0cmlidXRlc1xuXG4gICAgICB3aGVuICdyZWFkJ1xuICAgICAgICBjaHJvbWU/LnN0b3JhZ2Uuc3luYy5nZXQgQGF0dHJpYnV0ZXMsIChhdHRycykgPT5cbiAgICAgICAgICBAdXBkYXRlQXR0cmlidXRlcyBhdHRyc1xuXG4gICAgICAgIGlmIFNpbXBsZVN0b3JhZ2Uuc3RvcmFnZT9cbiAgICAgICAgICBAdXBkYXRlQXR0cmlidXRlcyBTaW1wbGVTdG9yYWdlLnN0b3JhZ2VcblxuICAgICAgd2hlbiAnZGVsZXRlJ1xuICAgICAgICBrZXlzID0gKGtleSBmb3Iga2V5IG9mIEBhdHRyaWJ1dGVzKVxuICAgICAgICBjaHJvbWU/LnN0b3JhZ2Uuc3luYy5yZW1vdmUga2V5c1xuXG4gIHVwZGF0ZUF0dHJpYnV0ZXM6IChhdHRycykgLT5cbiAgICAjIGNyZWF0ZSBhIGRlZXAgY2xvbmUgb2YgYXR0cnNcbiAgICBAc2F2ZWRBdHRyaWJ1dGVzID0gSlNPTi5wYXJzZSBKU09OLnN0cmluZ2lmeSBhdHRyc1xuXG4gICAgQHNldCBAdXBkYXRlU2V0dGluZ3MgYXR0cnNcbiAgICBAc2F2ZSgpIHVubGVzcyBfLmlzRXF1YWwgQGF0dHJpYnV0ZXMsIEBzYXZlZEF0dHJpYnV0ZXNcblxuICB1cGRhdGVTZXR0aW5nczogKGF0dHJzKSAtPlxuICAgIGF0dHJzLm1peHBhbmVsSWQgPz0gQGdlbmVyYXRlVW5pcXVlSWQoKVxuXG4gICAgaWYgXy5pc051bGwoYXR0cnMuaXNCdXR0b25Pbikgb3IgXy5pc1VuZGVmaW5lZChhdHRycy5pc0J1dHRvbk9uKVxuICAgICAgYXR0cnMuaXNCdXR0b25PbiA9IGF0dHJzLmlzTW96YmFyT25cblxuICAgIGlmIF8uaXNOdWxsIGF0dHJzLnZlcnNpb25cbiAgICAgIGF0dHJzLm1ldHJpY3NDb2xzLnB1c2ggJ2ZzcHNjJ1xuXG4gICAgYXR0cnMudmVyc2lvbiA9IFNFVFRJTkdTX1ZFUlNJT05cbiAgICBhdHRyc1xuXG4gIGdlbmVyYXRlVW5pcXVlSWQ6IC0+XG4gICAgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDE1KSArXG4gICAgICBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcgMiwgMTVcbiIsIl8gPSByZXF1aXJlICd1bmRlcnNjb3JlJ1xue01vZGVsfSA9IHJlcXVpcmUgJ2JhY2tib25lJ1xuQnJvd3NlciA9IHJlcXVpcmUgJ21vZGVscy9icm93c2VyJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFRhYlNldHRpbmdzIGV4dGVuZHMgTW9kZWxcbiAgZGVmYXVsdHM6XG4gICAgaGlnaGxpZ2h0TGlua3M6IG51bGxcbiAgICBoaWdobGlnaHRLZXl3b3JkOiAnJ1xuXG4gIHN5bmM6IChtZXRob2QsIG1vZGVsLCBvcHRpb25zKSAtPlxuICAgIHN3aXRjaCBtZXRob2RcbiAgICAgIHdoZW4gJ2NyZWF0ZScsICd1cGRhdGUnLCAncGF0Y2gnXG4gICAgICAgIEJyb3dzZXIuc2VuZE1lc3NhZ2UgJ3NldFRhYlNldHRpbmdzJywgQHRvSlNPTigpXG5cbiAgICAgIHdoZW4gJ3JlYWQnXG4gICAgICAgIEJyb3dzZXIuc2VuZE1lc3NhZ2UgJ2dldFRhYlNldHRpbmdzJywgbnVsbCwgKHJlc3BvbnNlKSAtPlxuICAgICAgICAgIHJlc3BvbnNlID89XG4gICAgICAgICAgICBoaWdobGlnaHRMaW5rczogW11cbiAgICAgICAgICAgIGhpZ2hsaWdodEtleXdvcmQ6ICcnXG5cbiAgICAgICAgICBvcHRpb25zLnN1Y2Nlc3MuY2FsbCBtb2RlbCwgcmVzcG9uc2VcblxuICB0b2dnbGVIaWdobGlnaHRMaW5rOiAodHlwZSwgaXNPbikgLT5cbiAgICBsaW5rcyA9IEBnZXQoJ2hpZ2hsaWdodExpbmtzJykgb3IgW11cbiAgICAjIHVzZSBjb25jYXQgaW5zdGVhZCBvZiBwdXNoIHNvIHdlIGRvbid0IG1vZGlmeSB0aGUgb3JpZ2luYWwgYXJyYXlcbiAgICBsaW5rcyA9IGxpbmtzLmNvbmNhdCh0eXBlKSBpZiBpc09uIGFuZCBsaW5rcy5pbmRleE9mKHR5cGUpIGlzIC0xXG4gICAgbGlua3MgPSBfLndpdGhvdXQobGlua3MsIHR5cGUpIHVubGVzcyBpc09uXG5cbiAgICBAc2V0ICdoaWdobGlnaHRMaW5rcycsIGxpbmtzXG5cbiAgaXNWYWxpZDogLT5cbiAgICBAZ2V0KCdoaWdobGlnaHRMaW5rcycpIGlzbnQgbnVsbFxuIiwiQmFja2JvbmUgPSByZXF1aXJlICdiYWNrYm9uZSdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBUb29sdGlwIGV4dGVuZHMgQmFja2JvbmUuTW9kZWxcbiAgZGVmYXVsdHM6XG4gICAgdGV4dDogJydcbiAgICB0b3A6IDBcbiAgICBsZWZ0OiAwXG4gICAgcGxhY2VtZW50OiAnYmVsb3cnXG4iLCJfID0gcmVxdWlyZSAndW5kZXJzY29yZSdcbiQgPSByZXF1aXJlICdqcXVlcnknXG57TW9kZWx9ID0gcmVxdWlyZSAnYmFja2JvbmUnXG5QYWdlID0gcmVxdWlyZSAnbW9kZWxzL3BhZ2UnXG5Ud2l0dGVyVXNlciA9IHJlcXVpcmUgJ21vZGVscy90d2l0dGVyX3VzZXInXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgVHdpdHRlciBleHRlbmRzIE1vZGVsXG4gIGRlZmF1bHRzOlxuICAgIGlzTG9hZGVkOiBmYWxzZVxuICAgIGlzU3VwcG9ydGVkOiB0cnVlXG4gICAgY2FyZFR5cGU6IG51bGxcbiAgICBpbWFnZTogbnVsbFxuICAgIGRlc2NyaXB0aW9uOiBudWxsXG4gICAgdGl0bGU6IG51bGxcblxuICBjcmVhdG9yOiBuZXcgVHdpdHRlclVzZXJcbiAgc2l0ZTogbmV3IFR3aXR0ZXJVc2VyXG4gIHN1cHBvcnRlZENhcmRUeXBlczpcbiAgICBbJ3N1bW1hcnknLCAnc3VtbWFyeV9sYXJnZV9pbWFnZScsICdwcm9kdWN0JywgJ3Bob3RvJywgJ2dhbGxlcnknLCAncGxheWVyJ11cblxuICBpbml0aWFsaXplOiAtPlxuICAgIEBsaXN0ZW5UbyBAY3JlYXRvciwgJ2NoYW5nZScsID0+IEB0cmlnZ2VyICdjaGFuZ2UnXG4gICAgQGxpc3RlblRvIEBzaXRlLCAnY2hhbmdlJywgPT4gQHRyaWdnZXIgJ2NoYW5nZSdcblxuICBzeW5jOiAobWV0aG9kLCBtb2RlbCwgb3B0aW9ucykgLT5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQnKSB1bmxlc3MgbWV0aG9kIGlzICdyZWFkJ1xuXG4gICAgIyBjaG9wIG9mZiB0aGUgbGVhZGluZyAnQCdcbiAgICBAc2l0ZS5zZXQgJ2lkJywgUGFnZS5yZWFkTWV0YVRhZygndHdpdHRlcjpzaXRlJylcbiAgICBAc2l0ZS5mZXRjaCgpXG5cbiAgICBAY3JlYXRvci5zZXQgJ2lkJywgUGFnZS5yZWFkTWV0YVRhZygndHdpdHRlcjpjcmVhdG9yJylcbiAgICBAY3JlYXRvci5mZXRjaCgpXG5cbiAgICBjYXJkVHlwZSA9IFBhZ2UucmVhZE1ldGFUYWcgJ3R3aXR0ZXI6Y2FyZCdcbiAgICBpc1N1cHBvcnRlZCA9IGNhcmRUeXBlIGluIEBzdXBwb3J0ZWRDYXJkVHlwZXNcblxuICAgIG9wdGlvbnMuc3VjY2Vzc1xuICAgICAgaXNMb2FkZWQ6IHRydWVcbiAgICAgIGhhc1R3aXR0ZXI6IFBhZ2UucmVhZE1ldGFUYWcgJ3R3aXR0ZXI6Y2FyZCdcbiAgICAgIGNhcmRUeXBlOiBQYWdlLnJlYWRNZXRhVGFnICd0d2l0dGVyOmNhcmQnXG4gICAgICBpbWFnZTpcbiAgICAgICAgUGFnZS5yZWFkTWV0YVRhZygndHdpdHRlcjppbWFnZScpIG9yXG4gICAgICAgIFBhZ2UucmVhZE1ldGFUYWcoJ3R3aXR0ZXI6aW1hZ2U6c3JjJykgb3JcbiAgICAgICAgUGFnZS5yZWFkTWV0YVRhZygnb2c6aW1hZ2UnKVxuICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgIFBhZ2UucmVhZE1ldGFUYWcoJ3R3aXR0ZXI6ZGVzY3JpcHRpb24nKSBvclxuICAgICAgICBQYWdlLnJlYWRNZXRhVGFnKCdvZzpkZXNjcmlwdGlvbicpXG4gICAgICB0aXRsZTpcbiAgICAgICAgUGFnZS5yZWFkTWV0YVRhZygndHdpdHRlcjp0aXRsZScpIG9yXG4gICAgICAgIFBhZ2UucmVhZE1ldGFUYWcoJ29nOnRpdGxlJylcbiAgICAgIGxhYmVsMTogUGFnZS5yZWFkTWV0YVRhZyAndHdpdHRlcjpsYWJlbDEnXG4gICAgICBkYXRhMTogUGFnZS5yZWFkTWV0YVRhZyAndHdpdHRlcjpkYXRhMSdcbiAgICAgIGxhYmVsMjogUGFnZS5yZWFkTWV0YVRhZyAndHdpdHRlcjpsYWJlbDInXG4gICAgICBkYXRhMjogUGFnZS5yZWFkTWV0YVRhZyAndHdpdHRlcjpkYXRhMidcbiAgICAgIGltYWdlMDogUGFnZS5yZWFkTWV0YVRhZyAndHdpdHRlcjppbWFnZTAnXG4gICAgICBpbWFnZTE6IFBhZ2UucmVhZE1ldGFUYWcgJ3R3aXR0ZXI6aW1hZ2UxJ1xuICAgICAgaW1hZ2UyOiBQYWdlLnJlYWRNZXRhVGFnICd0d2l0dGVyOmltYWdlMidcbiAgICAgIGltYWdlMzogUGFnZS5yZWFkTWV0YVRhZyAndHdpdHRlcjppbWFnZTMnXG4gICAgICBwbGF5ZXI6IFBhZ2UucmVhZE1ldGFUYWcgJ3R3aXR0ZXI6cGxheWVyJ1xuXG4gIHZhbGlkYXRlOiAoYXR0cnMpIC0+XG4gICAgJ0RhdGEgbm90IGxvYWRlZCcgdW5sZXNzIGF0dHJzLmlzTG9hZGVkXG5cbiAgdG9KU09OOiAtPlxuICAgIF8uY2xvbmUgXy5leHRlbmQgQGF0dHJpYnV0ZXMsXG4gICAgICBzaXRlOiBAc2l0ZS50b0pTT04oKSxcbiAgICAgIGNyZWF0b3I6IEBjcmVhdG9yLnRvSlNPTigpXG4iLCJfID0gcmVxdWlyZSAndW5kZXJzY29yZSdcbiQgPSByZXF1aXJlICdqcXVlcnknXG57TW9kZWx9ID0gcmVxdWlyZSAnYmFja2JvbmUnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgVHdpdHRlclVzZXIgZXh0ZW5kcyBNb2RlbFxuICBkZWZhdWx0czpcbiAgICBoYW5kbGU6IG51bGxcbiAgICBuYW1lOiBudWxsXG4gICAgaW1hZ2U6IG51bGxcblxuICB1cmxSb290OiAnaHR0cHM6Ly90d2l0dGVyLmNvbS8nXG5cbiAgaW5pdGlhbGl6ZTogLT5cbiAgICBAbGlzdGVuVG8gdGhpcywgJ2NoYW5nZTppZCcsID0+XG4gICAgICByZXR1cm4gdW5sZXNzIEBnZXQgJ2lkJ1xuXG4gICAgICAjIGlkIGlzIHdpdGhvdXQgQCwgaGFuZGxlIGlzIEBpZFxuICAgICAgaWQgPSBAZ2V0KCdpZCcpLnJlcGxhY2UgL15cXEAvLCAnJ1xuICAgICAgQHNldCBpZDogaWQsIGhhbmRsZTogXCJAI3tpZH1cIlxuXG4gIGZldGNoOiAob3B0aW9ucykgLT5cbiAgICByZXR1cm4gdW5sZXNzIEBoYXMgJ2lkJ1xuICAgIHN1cGVyIF8uZXh0ZW5kIGRhdGFUeXBlOiAnaHRtbCcsIG9wdGlvbnNcblxuICBwYXJzZTogKHJlc3ApIC0+XG4gICAgJHJlc3AgPSAoJCByZXNwKVxuXG4gICAgaW1hZ2U6ICRyZXNwLmZpbmQoJy5wcm9maWxlLXBpY3R1cmUgLmF2YXRhcicpLnByb3AgJ3NyYydcbiAgICBuYW1lOiAkcmVzcC5maW5kKCcucHJvZmlsZS1jYXJkLWlubmVyIC5mdWxsbmFtZSAucHJvZmlsZS1maWVsZCcpLnRleHQoKVxuIiwiXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG5CYWNrYm9uZSA9IHJlcXVpcmUgJ2JhY2tib25lJ1xuQW5hbHl0aWNzID0gcmVxdWlyZSAnbW9kZWxzL2FuYWx5dGljcydcbkJyb3dzZXIgPSByZXF1aXJlICdtb2RlbHMvYnJvd3NlcidcblNldHRpbmdzID0gcmVxdWlyZSAnbW9kZWxzL3NldHRpbmdzJ1xuVXNlciA9IHJlcXVpcmUgJ21vZGVscy91c2VyJ1xubW96Q29scyA9IHJlcXVpcmUgJ21vZGVscy9tb3pfY29scydcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBVcmxNZXRyaWNzIGV4dGVuZHMgQmFja2JvbmUuTW9kZWxcbiAgQHVybE1ldHJpY3M6IG51bGxcbiAgQGdldEluc3RhbmNlOiAtPlxuICAgIEB1cmxNZXRyaWNzID89IG5ldyBVcmxNZXRyaWNzKClcblxuICB1c2VyOiBVc2VyLmdldEluc3RhbmNlKClcbiAgYW5hbHl0aWNzOiBBbmFseXRpY3MuZ2V0SW5zdGFuY2UoKVxuICBzZXR0aW5nczogU2V0dGluZ3MuZ2V0SW5zdGFuY2UoKVxuXG4gIGRlZmF1bHRzOlxuICAgIHJvb3REb21haW46IGRvY3VtZW50LmxvY2F0aW9uLmhvc3RuYW1lXG4gICAgcGFnZVVybDogZG9jdW1lbnQubG9jYXRpb24uaHJlZlxuICAgIHVwYTogJy0tJ1xuICAgIHVtcnA6ICctLSdcbiAgICB1dHJwOiAnLS0nXG4gICAgbmljZVVpZDogJy0tJ1xuICAgIG5pY2VVaXBsOiAnLS0nXG4gICAgcGRhOiAnLS0nXG4gICAgbmljZVB1aWQ6ICctLSdcbiAgICBuaWNlUGlkOiAnLS0nXG4gICAgbmljZUZ1aWQ6ICctLSdcbiAgICBuaWNlRmlwbDogJy0tJ1xuICAgIG5pY2VGc3BzYzogJy0tJ1xuICAgIHBvc2l0aW9uOiBudWxsXG5cbiAgaW5pdGlhbGl6ZTogKG9wdHMpIC0+XG4gICAgQHVwZGF0ZVJvb3REb21haW4oKVxuICAgIEBsaXN0ZW5UbyB0aGlzLCAnY2hhbmdlOnBhZ2VVcmwnLCBAdXBkYXRlUm9vdERvbWFpblxuXG4gICAgIyBzb21ldGltZXMgbHNhcGkgY2FsbHMgZmFpbCBvciBhcmUgYmxvY2tlZCwgd2Ugc2hvdWxkIGF0IGxlYXN0XG4gICAgIyByZW1lbWJlciB3ZSB0cmllZC5cbiAgICBAbGlzdGVuVG8gdGhpcywgJ2Vycm9yJywgPT5cbiAgICAgIEBpc0xvYWRlZCA9IHRydWVcblxuICAgIHN1cGVyXG5cbiAgICBAbGlzdGVuVG8gQHVzZXIsICdjaGFuZ2UnLCA9PiBAZmV0Y2goKVxuICAgIEBsaXN0ZW5UbyBAc2V0dGluZ3MsICdjaGFuZ2U6bWV0cmljc0NvbHMnLCA9PiBAZmV0Y2goKVxuICAgIEBsaXN0ZW5UbyB0aGlzLCAnY2hhbmdlJywgPT5cbiAgICAgIEJyb3dzZXIuc2VuZE1lc3NhZ2UgJ21ldHJpY3NDaGFuZ2VkJywgQHRvSlNPTigpXG5cbiAgZmV0Y2g6IChvcHRpb25zKSAtPlxuICAgIHVubGVzcyBAdXNlci5pc1ZhbGlkKClcbiAgICAgIEB1c2VyLmZldGNoKG9wdGlvbnMpXG4gICAgICByZXR1cm5cblxuICAgIHJldHVybiBpZiBAaXNGZXRjaGluZyBvciBAaXNMb2FkZWRcbiAgICBAaXNGZXRjaGluZyA9IHRydWVcblxuICAgICMgdGhpcyB3aWxsIGJlIGNhbGxlZCBhZ2FpbiBvbmNlIHVzZXIgaGFzIGJlZW4gbG9hZGVkXG4gICAgc3VwZXJcblxuICAjIEhBQ0sgLS0gdGVtcG9yYXJ5IGZpeCB1bnRpbCB0aGUgZml4IGZvclxuICAjICBodHRwczovL3Nlb21vei5hdGxhc3NpYW4ubmV0L2Jyb3dzZS9TQVZBTk5BLTI5NDBcbiAgIyBwcm9wb2dhdGVzIG91dCwgZXN0aW1hdGVkIEp1bmUgMjB0aCAyMDE1IG9yIHNvLlxuICBmZXRjaFJvb3RTcGFtU2NvcmU6IC0+XG4gICAgY29scyA9IG1vekNvbHMuZ2V0Qml0cyBbJ2ZzcHNjJ11cblxuICAgICQuZ2V0IFwiaHR0cHM6Ly9sc2FwaS5zZW9tb3ouY29tL2xpbmtzY2FwZS91cmwtbWV0cmljcy9cIiArXG4gICAgXCIje0BnZXQgJ3Jvb3REb21haW4nfT9Db2xzPSN7Y29sc30mI3tAdXNlci5hdXRoUVMoKX1cIiwgKHJlc3ApID0+XG4gICAgICBAc2V0XG4gICAgICAgIGZzcHNjOiByZXNwLmZzcHNjIC0gMSBpZiByZXNwLmZzcHNjP1xuICAgICAgICBuaWNlRnNwc2M6IGlmIHJlc3AuZnNwc2M/IHRoZW4gXCIje3Jlc3AuZnNwc2MtMX0vMTdcIlxuICAgICAgICBub0ZzcHNjOiByZXNwLmZzcHNjIGlzIDBcblxuICB2YWxpZGF0ZTogKGF0dHJzKSAtPlxuICAgICdEYXRhIG5vdCBsb2FkZWQnIGlmIGF0dHJzLnVwYSBpcyBAZGVmYXVsdHMudXBhXG5cbiAgdXBkYXRlUm9vdERvbWFpbjogLT5cbiAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgJ2EnXG4gICAgZWwuaHJlZiA9IEBnZXQgJ3BhZ2VVcmwnXG4gICAgQHNldCAncm9vdERvbWFpbicsIGVsLmhvc3RuYW1lXG5cbiAgdXJsOiAtPlxuICAgIHBhZ2VVcmwgPSBlbmNvZGVVUklDb21wb25lbnQgQGdldCgncGFnZVVybCcpLnJlcGxhY2UgL15odHRwW3NdKjpcXC9cXC8vLCAnJ1xuXG4gICAgXCJodHRwczovL2xzYXBpLnNlb21vei5jb20vbGlua3NjYXBlL3VybC1tZXRyaWNzL1wiICtcbiAgICAgIFwiI3twYWdlVXJsfT9Db2xzPSN7QGdldENvbHMoKX0mI3tAdXNlci5hdXRoUVMoKX1cIlxuXG4gIHBhcnNlOiAocmVzcCkgLT5cbiAgICBAaXNGZXRjaGluZyA9IGZhbHNlXG4gICAgQGlzTG9hZGVkID0gdHJ1ZVxuXG4gICAgaWYgcmVzcC5mc3BzYyBpcyAwIHRoZW4gQGZldGNoUm9vdFNwYW1TY29yZSgpXG5cbiAgICBfLmV4dGVuZCByZXNwLFxuICAgICAgbmljZVVlaWQ6IHJlc3AudWVpZD8udG9Mb2NhbGVTdHJpbmcoKVxuICAgICAgbmljZUZlaWQ6IHJlc3AuZmVpZD8udG9Mb2NhbGVTdHJpbmcoKVxuICAgICAgbmljZVBlaWQ6IHJlc3AucGVpZD8udG9Mb2NhbGVTdHJpbmcoKVxuICAgICAgbmljZVVpZDogcmVzcC51aWQ/LnRvTG9jYWxlU3RyaW5nKClcbiAgICAgIG5pY2VQaWQ6IHJlc3AucGlkPy50b0xvY2FsZVN0cmluZygpXG4gICAgICBuaWNlVWlwbDogcmVzcC51aXBsPy50b0xvY2FsZVN0cmluZygpXG4gICAgICB1bXJwOiByZXNwLnVtcnA/LnRvRml4ZWQgMlxuICAgICAgZm1ycDogcmVzcC5mbXJwPy50b0ZpeGVkIDJcbiAgICAgIHBtcnA6IHJlc3AucG1ycD8udG9GaXhlZCAyXG4gICAgICBwbXJwUGN0OiBNYXRoLnJvdW5kIHJlc3AucG1ycCAqIDEwXG4gICAgICB1dHJwOiByZXNwLnV0cnA/LnRvRml4ZWQgMlxuICAgICAgZnRycDogcmVzcC5mdHJwPy50b0ZpeGVkIDJcbiAgICAgIHB0cnA6IHJlc3AucHRycD8udG9GaXhlZCAyXG4gICAgICBwdHJwUGN0OiBNYXRoLnJvdW5kIHJlc3AucHRycCAqIDEwXG4gICAgICB1dHJwUGN0OiBNYXRoLnJvdW5kIHJlc3AudXRycCAqIDEwXG4gICAgICB1bXJwUGN0OiBNYXRoLnJvdW5kIHJlc3AudW1ycCAqIDEwXG4gICAgICBuaWNlRmlwbDogcmVzcC5maXBsPy50b0xvY2FsZVN0cmluZygpXG4gICAgICBuaWNlRnVpZDogcmVzcC5mdWlkPy50b0xvY2FsZVN0cmluZygpXG4gICAgICBuaWNlUHVpZDogcmVzcC5wdWlkPy50b0xvY2FsZVN0cmluZygpXG4gICAgICBuaWNlVXBhOiBNYXRoLnJvdW5kIHJlc3AudXBhXG4gICAgICBuaWNlUGRhOiBNYXRoLnJvdW5kIHJlc3AucGRhXG4gICAgICBmc3BzYzogcmVzcC5mc3BzYyAtIDEgaWYgcmVzcC5mc3BzYz9cbiAgICAgIG5pY2VGc3BzYzogaWYgcmVzcC5mc3BzYz8gdGhlbiBcIiN7cmVzcC5mc3BzYy0xfS8xN1wiXG4gICAgICBub0ZzcHNjOiByZXNwLmZzcHNjIGlzIDBcblxuICBnZXRDb2xzOiAtPlxuICAgICMgdGhlc2UgYXJlIHRoZSB2YWx1ZXMgd2UgYWx3YXlzIHJlcXVlc3RcbiAgICBjb2xzID0gWyd1cGEnLCAndWlkJywgJ3BkYScsICd1ZWlkJywgJ2ZtcnAnXVxuXG4gICAgaWYgQHVzZXIuZ2V0ICdpc1BybydcbiAgICAgIGNvbHMgPSBjb2xzLmNvbmNhdCBbXG4gICAgICAgICd1aXBsJywgJ3B1aWQnLCAncGlkJywgJ2Z1aWQnLFxuICAgICAgICAnZmlwbCcsICdmZWlkJywgJ3BlaWQnXG4gICAgICBdXG5cbiAgICBjb2xzID0gY29scy5jb25jYXQgXy53aXRob3V0IEBzZXR0aW5ncy5nZXQoJ21ldHJpY3NDb2xzJyksICdsaW5rcydcbiAgICBtb3pDb2xzLmdldEJpdHMgY29sc1xuXG4gIHRvSlNPTjogLT5cbiAgICBfLmNsb25lIF8uZXh0ZW5kIEBhdHRyaWJ1dGVzLFxuICAgICAgdXNlcjogQHVzZXIudG9KU09OKClcbiAgICAgIGJhcjFvbjogaWYgQGF0dHJpYnV0ZXMuZnNwc2MgPiAwIHRoZW4gJ29uJ1xuICAgICAgYmFyMm9uOiBpZiBAYXR0cmlidXRlcy5mc3BzYyA+IDYgdGhlbiAnb24nXG4gICAgICBiYXIzb246IGlmIEBhdHRyaWJ1dGVzLmZzcHNjID4gMTIgdGhlbiAnb24nXG5cblxuIiwiXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG4kID0gcmVxdWlyZSAnanF1ZXJ5J1xuQmFja2JvbmUgPSByZXF1aXJlICdiYWNrYm9uZSdcblBhZ2UgPSByZXF1aXJlICdtb2RlbHMvcGFnZSdcblNldHRpbmdzID0gcmVxdWlyZSAnbW9kZWxzL3NldHRpbmdzJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFVzZXIgZXh0ZW5kcyBCYWNrYm9uZS5Nb2RlbFxuICBAdXNlcjogbnVsbFxuICBAZ2V0SW5zdGFuY2U6IC0+XG4gICAgQHVzZXIgPz0gbmV3IFVzZXJcblxuICBzZXR0aW5nczogU2V0dGluZ3MuZ2V0SW5zdGFuY2UoKVxuICB1cmw6ICdodHRwczovL21vei5jb20vdXNlcnMvbGV2ZWw/c3JjPW1vemJhcidcbiAgZmV0Y2hlZDogZmFsc2VcblxuICBpbml0aWFsaXplOiAtPlxuICAgIEBsaXN0ZW5UbyB0aGlzLCAnY2hhbmdlOmxldmVsJywgQHVwZGF0ZVByb0ZsYWdcbiAgICBAbGlzdGVuVG8gQHNldHRpbmdzLCAnY2hhbmdlOnVzZXInLCA9PiBAZmV0Y2goKVxuXG4gIGZldGNoOiAob3B0aW9ucykgLT5cbiAgICByZXR1cm4gdW5sZXNzIEBzZXR0aW5ncy5nZXQgJ2lzQnV0dG9uT24nXG5cbiAgICBAc2V0IEBzZXR0aW5ncy5nZXQgJ3VzZXInXG5cbiAgICAjIGlmIG91ciBjcmVkZW50aWFscyBoYXZlbid0IGV4cGlyZWQgYW5kIHdlJ3JlIG5vdCBvbiBtb3ouY29tXG4gICAgIyBhc3N1bWUgbG9nZ2VkIGluIHN0YXRlIGhhc24ndCBjaGFuZ2VkLlxuICAgIHJldHVybiBpZiBAaXNWYWxpZCgpIGFuZCBQYWdlLmhvc3RuYW1lKCkuaW5kZXhPZignbW96LmNvbScpIGlzIC0xXG5cbiAgICAjIHdlIG9ubHkgbmVlZCB0byBkbyB0aGlzIG9uY2UgcGVyIHBhZ2VcbiAgICByZXR1cm4gaWYgQGZldGNoZWRcbiAgICBAZmV0Y2hlZCA9IHRydWVcblxuICAgICMgbG9jYWxseSBzdG9yZWQgc2V0dGluZ3MgYXJlbid0IHZhbGlkLCBncmFiIHRoZW0gZnJvbSB0aGUgc2VydmVyXG4gICAgIyBhbmQgc2F2ZVxuICAgIG9wdGlvbnMgPz0ge31cbiAgICBvcHRpb25zLnN1Y2Nlc3MgPSA9PiBAc2F2ZSgpXG5cbiAgICBzdXBlciBvcHRpb25zXG5cbiAgc2F2ZTogLT5cbiAgICBAc2V0dGluZ3Muc2V0ICd1c2VyJywgQHRvSlNPTigpXG4gICAgQHNldHRpbmdzLnNhdmUoKVxuXG4gIHVwZGF0ZVByb0ZsYWc6IC0+XG4gICAgQHNldCAnaXNQcm8nLCBAZ2V0KCdsZXZlbCcpIGlzbnQgJ21lbWJlcidcblxuICBwYXJzZTogKHJlc3ApIC0+XG4gICAgXy5leHRlbmQgcmVzcCxcbiAgICAgIGFjY2Vzc19pZDogZGVjb2RlVVJJQ29tcG9uZW50IHJlc3AuYWNjZXNzX2lkXG4gICAgICBzaWduYXR1cmU6IGRlY29kZVVSSUNvbXBvbmVudCByZXNwLnNpZ25hdHVyZVxuICAgICAgaXNQcm86IHJlc3AubGV2ZWwgaXNudCAnbWVtYmVyJ1xuXG4gIHZhbGlkYXRlOiAoYXR0cnMpIC0+XG4gICAgJ1VzZXIgZXhwaXJlZCcgaWYgbmV3IERhdGUoKGF0dHJzLmV4cGlyZXMgb3IgMCkgKiAxMDAwKSA8IERhdGUubm93KClcblxuICBhdXRoUVM6IC0+XG4gICAgJC5wYXJhbVxuICAgICAgQWNjZXNzSUQ6IEBnZXQgJ2FjY2Vzc19pZCdcbiAgICAgIEV4cGlyZXM6IEBnZXQgJ2V4cGlyZXMnXG4gICAgICBTaWduYXR1cmU6IEBnZXQgJ3NpZ25hdHVyZSdcbiIsIkJhc2VFbGVtZW50ID0gcmVxdWlyZSAndmlld3MvYmFzZV9lbGVtZW50J1xuUGFnZSA9IHJlcXVpcmUgJ21vZGVscy9wYWdlJ1xuRGlzcGF0Y2hlciA9IHJlcXVpcmUgJ3ZpZXdzL2V2ZW50X2Rpc3BhdGNoZXInXG50ZW1wbGF0ZSA9IHJlcXVpcmUgJ3RlbXBsYXRlcy9hZGRyZXNzX2Jhcl9oaWdobGlnaHQnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQWRkcmVzc0JhckhpZ2hsaWdodCBleHRlbmRzIEJhc2VFbGVtZW50XG4gIGlkOiAnbW96YmFyLWFkZHJlc3MtYmFyLWhpZ2hsaWdodC0jcmFuZG9tLWtleSdcbiAgY2xhc3NOYW1lOiAnbW96YmFyLWFkZHJlc3MtYmFyLWhpZ2hsaWdodC0jcmFuZG9tLWtleSdcbiAgZWxlbWVudENzc0NsYXNzOiAnYWRkcmVzcy1iYXItaGlnaGxpZ2h0J1xuICBlbGVtZW50VGVtcGxhdGU6IHRlbXBsYXRlXG5cbiAgaW5pdGlhbGl6ZTogLT5cbiAgICBkaXNwYXRjaGVyID0gRGlzcGF0Y2hlci5nZXRJbnN0YW5jZSgpXG4gICAgZGlzcGF0Y2hlci5vbiAnYWRkcmVzcy1iYXItaGlnaGxpZ2h0OnNob3cnLCA9PiBAcmVuZGVyKClcbiAgICBkaXNwYXRjaGVyLm9uICdhZGRyZXNzLWJhci1oaWdobGlnaHQ6aGlkZScsID0+IEByZW1vdmUoKVxuIiwiJCA9IHJlcXVpcmUgJ2pxdWVyeSdcbkJhc2VFbGVtZW50ID0gcmVxdWlyZSAndmlld3MvYmFzZV9lbGVtZW50J1xuT3ZlcmxheSA9IHJlcXVpcmUgJ3ZpZXdzL292ZXJsYXknXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQmFzZURpYWxvZyBleHRlbmRzIEJhc2VFbGVtZW50XG4gICMgZnJvbSBCYXNlRWxlbWVudFxuICBlbGVtZW50Q3NzQ2xhc3M6ICdkaWFsb2cnXG4gIGVsZW1lbnRWaWV3Q2xhc3M6IG51bGxcbiAgb3ZlcmxheTogbnVsbFxuXG4gIGlkOiAnbW96YmFyLWhlbHAtZGlhbG9nLSNyYW5kb20ta2V5J1xuXG4gICMgb3B0aW9uczpcbiAgIyAgIHRvcDogMFxuICAjICAgYm90dG9tOiAwXG4gICMgICBsZWZ0OiAwXG4gICMgICBhcnJvdzogJ3RvcHxib3R0b218bm9uZSdcbiAgaW5pdGlhbGl6ZTogKEBvcHRpb25zKSAtPlxuICAgIHN1cGVyXG4gICAgQG92ZXJsYXkgPSBuZXcgT3ZlcmxheSgpXG4gICAgQG92ZXJsYXkub24gJ2NsaWNrZWQnLCA9PiBAb3ZlcmxheUNsaWNrZWQoKVxuXG4gIHJlbmRlcjogLT5cbiAgICBzdXBlclxuICAgIEBvdmVybGF5LnJlbmRlcigpXG5cbiAgc2V0RWxlbWVudFJvb3Q6IChAZWxlbWVudFJvb3QpIC0+XG4gICAgc3VwZXJcbiAgICBAJGVsZW1lbnRSb290LmFkZENsYXNzIFwiYXJyb3ctI3tAb3B0aW9ucy5hcnJvd31cIiBpZiBAb3B0aW9ucz8uYXJyb3dcblxuICBvdmVybGF5Q2xpY2tlZDogLT5cbiAgICBAcmVtb3ZlKClcblxuICByZW1vdmU6IC0+XG4gICAgc3VwZXJcbiAgICBAb3ZlcmxheS5yZW1vdmUoKVxuIiwiJCA9IHJlcXVpcmUgJ2pxdWVyeSdcblNldHRpbmdzID0gcmVxdWlyZSAnbW9kZWxzL3NldHRpbmdzJ1xuSGFuZGxlYmFycyA9IHJlcXVpcmUgJ2hhbmRsZWJhcnMnXG5Ccm93c2VyID0gcmVxdWlyZSAnbW9kZWxzL2Jyb3dzZXInXG5CYXNlVmlldyA9IHJlcXVpcmUgJ3ZpZXdzL2Jhc2VfdmlldydcbnRlbXBsYXRlID0gcmVxdWlyZSAndGVtcGxhdGVzL2Jhc2VfZWxlbWVudCdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBCYXNlRWxlbWVudCBleHRlbmRzIEJhc2VWaWV3XG4gIHNldHRpbmdzOiBTZXR0aW5ncy5nZXRJbnN0YW5jZSgpXG4gIHRhZ05hbWU6ICdpZnJhbWUnXG4gIGNsYXNzTmFtZTogJ21vemJhci0jcmFuZG9tLWtleSdcblxuICAjIGhhbmRsZWJhcnMgdGVtcGxhdGUgdG8gcmVuZGVyIGluIHRoZSBpZnJhbWUgYm9keVxuICBlbGVtZW50VGVtcGxhdGU6IG51bGxcblxuICAjIGNoaWxkIGNsYXNzIGF0dGFjaGVkIHRvIHRoZSBib2R5IGVsZW1lbnRcbiAgZWxlbWVudENzc0NsYXNzOiBudWxsXG5cbiAgIyBjbGFzcyAobm90IGluc3RhbmNlKSBvZiB0aGUgdmlldyBjb250cm9sbGluZyB0aGVcbiAgIyBpZnJhbWVcbiAgZWxlbWVudFZpZXdDbGFzczogbnVsbFxuXG4gICMgbW9kZWwgcGFzc2VkIHRvIGVsZW1lbnRWaWV3Q2xhc3NcbiAgZWxlbWVudFZpZXdNb2RlbDogbnVsbFxuXG4gICMgaW5zdGFudGlhdGVkIEBlbGVtZW50Vmlld0NsYXNzLCBjcmVhdGVkXG4gICMgYnkgQHJlbmRlcigpXG4gIGVsZW1lbnRWaWV3OiBudWxsXG5cbiAgIyByb290IGVsZW1lbnQgaW5zaWRlIHNoYWRvd1xuICBlbGVtZW50Um9vdDogbnVsbFxuICAkZWxlbWVudFJvb3Q6IG51bGxcblxuICBpbml0aWFsaXplOiAob3B0aW9ucykgLT5cbiAgICBAc2V0dGluZ3Mub24gJ2NoYW5nZTppc0xpZ2h0VGhlbWUnLCA9PiBAdXBkYXRlVGhlbWUoKVxuXG4gICMgb3ZlcnJpZGUgdGhpcyB0byBjaGFuZ2UgdGhlIGVsZW1lbnQncyBwYXJlbnRcbiAgcGFyZW50RWxlbWVudDogLT5cbiAgICAkICdib2R5J1xuXG4gICMgb3ZlcnJpZGUgdG8gY2hhbmdlIGhvdyB0aGUgZWxlbWVudCBpcyBhZGRlZCB0byB0aGUgRE9NXG4gICMgcmV0dXJucyB0aGUgYWRkZWQgZWxlbW5ldC5cbiAgYWRkVG9ET006IC0+XG4gICAgQCRlbC5hcHBlbmRUbyBAcGFyZW50RWxlbWVudCgpXG5cbiAgcmVuZGVyOiAtPlxuICAgIGlmIEBpc0luRE9NKClcbiAgICAgIHJldHVyblxuXG4gICAgZWwgPSBAYWRkVG9ET00oKVxuICAgIEBzZXRFbGVtZW50IGVsXG5cbiAgICBodG1sID0gdGVtcGxhdGVcbiAgICAgIGVsZW1lbnRDc3NDbGFzczogQGVsZW1lbnRDc3NDbGFzc1xuICAgICAgaHRtbDogbmV3IEhhbmRsZWJhcnMuU2FmZVN0cmluZyBAZWxlbWVudFRlbXBsYXRlPyBAdGVtcGxhdGVPcHRpb25zKClcblxuICAgIEBlbC5vbmxvYWQgPSA9PiBAZnJhbWVMb2FkZWQoKVxuXG4gICAgQCRlbC5wcm9wXG4gICAgICBmcmFtZUJvcmRlcjogMFxuICAgICAgc2Nyb2xsaW5nOiAnbm8nXG4gICAgICBhbGxvd1RyYW5zcGFyZW5jeTogdHJ1ZVxuICAgICAgc3JjZG9jOiBodG1sXG5cbiAgIyBPdmVycmlkZSB0byBwcm92aWRlIG9wdGlvbnMgdG8gZWxlbWVudFRlbXBsYXRlKClcbiAgdGVtcGxhdGVPcHRpb25zOiAtPlxuXG4gIGZyYW1lTG9hZGVkOiAtPlxuICAgIEBzZXRFbGVtZW50Um9vdCBAZWwuY29udGVudERvY3VtZW50LmJvZHlcbiAgICBAdXBkYXRlVGhlbWUoKVxuXG4gICAgIyBhcHBseSBjc3MuICAgV2UncmUgZG9pbmcgaXQgaGVyZSBpbnN0ZWFkIG9mIGFwcGx5aW5nIGl0IHRvIHRoZVxuICAgICMgdGVtcGxhdGUsIGFzIHRoZSBsYXR0ZXIgY3JlYXRlcyBiaWcgbWVtb3J5IGlzc3VlcyBmb3IgY2hyb21lLlxuICAgIEJyb3dzZXIuZ2V0ICdzdHlsZXMvdG9vbGJhci5jc3MnLCAoY3NzKSA9PlxuICAgICAgc3R5bGUgPSBAZWwuY29udGVudERvY3VtZW50LmNyZWF0ZUVsZW1lbnQgJ3N0eWxlJ1xuICAgICAgc3R5bGUudHlwZSA9ICd0ZXh0L2NzcydcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkIEBlbC5jb250ZW50RG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKVxuXG4gICAgICAoJCAnaGVhZCcsIEBlbC5jb250ZW50RG9jdW1lbnQpLmFwcGVuZCBzdHlsZVxuXG4gICAgaWYgQGVsZW1lbnRWaWV3Q2xhc3M/XG4gICAgICBAZWxlbWVudFZpZXcgPSBuZXcgQGVsZW1lbnRWaWV3Q2xhc3NcbiAgICAgICAgZWw6IEBlbGVtZW50Um9vdFxuICAgICAgICBtb2RlbDogQGVsZW1lbnRWaWV3TW9kZWxcbiAgICAgICAgaG9zdDogdGhpc1xuXG4gICAgICBAZWxlbWVudFZpZXcucmVuZGVyKClcblxuICBzZXRFbGVtZW50Um9vdDogKEBlbGVtZW50Um9vdCkgLT5cbiAgICBAJGVsZW1lbnRSb290ID0gKCQgQGVsZW1lbnRSb290KVxuXG4gIHVwZGF0ZVRoZW1lOiAtPlxuICAgIEAkZWxlbWVudFJvb3Q/LnRvZ2dsZUNsYXNzICdsaWdodCcsIEBzZXR0aW5ncy5nZXQgJ2lzTGlnaHRUaGVtZSdcblxuICByZW1vdmU6IC0+XG4gICAgaWYgQGVsZW1lbnRWaWV3Py5yZW1vdmU/XG4gICAgICBAZWxlbWVudFZpZXcucmVtb3ZlID0+XG4gICAgICAgICMgY29mZmVlbGludCBjb21wbGFpbnMgYWJvdXQgZmF0IGFycm93cywgYnV0IGFjdHVhbGx5IG5lZWQgaXQgZm9yIHN1cGVyXG4gICAgICAgICMgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jbHV0Y2hza2kvY29mZmVlbGludC9pc3N1ZXMvMjE0XG4gICAgICAgIHRoaXNcbiAgICAgICAgc3VwZXJcbiAgICBlbHNlXG4gICAgICBzdXBlclxuIiwiXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG5CYXNlVmlldyA9IHJlcXVpcmUgJ3ZpZXdzL2Jhc2VfdmlldydcblxuIyB0aGlzIGlzIHRoZSBiYXNlIHZpZXcgY2xhc3MgZm9yIHRoZSB2YXJpb3VzIHRhYnMgb24gdGhlIGluZm8gcGFuZWxcbiNcbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQmFzZVBhbmVsVGFiIGV4dGVuZHMgQmFzZVZpZXdcbiAgdGFibGVIZWlnaHQ6IG51bGxcblxuICAjIHNldCB0aGVzZSBpbiBpbmhlcml0aW5nIHZpZXdzXG4gIGNsYXNzTmFtZTogbnVsbFxuICB0ZW1wbGF0ZTogbnVsbFxuXG4gIHNldFRhYmxlSGVpZ2h0OiAoaGVpZ2h0KSAtPlxuICAgIEB0YWJsZUhlaWdodCA9IGhlaWdodFxuICAgIEAkZWwuZmluZCgnLnNjcm9sbGFibGUnKVxuICAgICAgLmhlaWdodChAdGFibGVIZWlnaHQpXG4gICAgICAucGVyZmVjdFNjcm9sbGJhciAndXBkYXRlJ1xuXG4gIGdldFRhYmxlSGVpZ2h0OiAtPlxuICAgIEB0YWJsZUhlaWdodFxuXG4gIHJlbmRlcjogLT5cbiAgICBAbW9kZWwuZmV0Y2goKSB1bmxlc3MgQG1vZGVsLmlzVmFsaWQoKVxuICAgIEAkZWwuaHRtbCBAdGVtcGxhdGUgXy5leHRlbmQgQG1vZGVsLnRvSlNPTigpLCBjbGFzc05hbWU6IEBjbGFzc05hbWVcblxuICAgIEAkZWwuZmluZCgnLnNjcm9sbGFibGUnKS5oZWlnaHQgQHRhYmxlSGVpZ2h0IGlmIEB0YWJsZUhlaWdodD9cbiAgICBAdGFibGVIZWlnaHQgPSBAJGVsLmZpbmQoJy5zY3JvbGxhYmxlJykuaGVpZ2h0KCkgdW5sZXNzIEB0YWJsZUhlaWdodD9cblxuICAgIEAkZWwuZmluZCgnLnNjcm9sbGFibGUnKS5wZXJmZWN0U2Nyb2xsYmFyKClcbiIsIiQgPSByZXF1aXJlICdqcXVlcnknXG5fID0gcmVxdWlyZSAndW5kZXJzY29yZSdcbkJhY2tib25lID0gcmVxdWlyZSAnYmFja2JvbmUnXG5CYWNrYm9uZS4kID0gJFxuRGlzcGF0Y2hlciA9IHJlcXVpcmUgJ3ZpZXdzL2V2ZW50X2Rpc3BhdGNoZXInXG5PbmJvYXJkaW5nID0gcmVxdWlyZSAnbW9kZWxzL29uYm9hcmRpbmcnXG5TZXR0aW5ncyA9IHJlcXVpcmUgJ21vZGVscy9zZXR0aW5ncydcblBhZ2UgPSByZXF1aXJlICdtb2RlbHMvcGFnZSdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBCYXNlVmlldyBleHRlbmRzIEJhY2tib25lLlZpZXdcbiAgZGlzcGF0Y2hlcjogRGlzcGF0Y2hlci5nZXRJbnN0YW5jZSgpXG4gIHNldHRpbmdzOiBTZXR0aW5ncy5nZXRJbnN0YW5jZSgpXG5cbiAgIyBvdmVycmlkZSB0aGlzIHRvIGNoYW5nZSB3aGVyZSB0b29sdGlwcyBzaG91bGQgc2hvdyB1cFxuICB0b29sdGlwUGxhY2VtZW50OiAnYmVsb3cnXG4gIGhvc3Q6IG51bGxcbiAgdGltZW91dDogbnVsbFxuXG4gIGluaXRpYWxpemU6IChvcHRpb25zKSAtPlxuICAgIEBzZXRIb3N0IG9wdGlvbnMuaG9zdCBpZiBvcHRpb25zP1xuXG4gICAgdGlwU2VsZWN0b3IgPSAnW2RhdGEtdG9vbHRpcF0nXG4gICAgQCRlbC5vbiBcIm1vdXNlZW50ZXIuYmFzZVZpZXdFdmVudHMje0BjaWR9XCIsIHRpcFNlbGVjdG9yLCAoZSkgPT5cbiAgICAgIEBzdGFydFRvb2x0aXBUaW1lb3V0IGVcbiAgICBAJGVsLm9uIFwibW91c2VsZWF2ZS5iYXNlVmlld0V2ZW50cyN7QGNpZH1cIiwgdGlwU2VsZWN0b3IsIChlKSA9PlxuICAgICAgQGhpZGVUb29sdGlwIGVcblxuICAgIEBvbmJvYXJkaW5nID0gT25ib2FyZGluZy5nZXRJbnN0YW5jZSgpXG4gICAgQGxpc3RlblRvIEBvbmJvYXJkaW5nLCAnY2hhbmdlOnNlcnBIaWdobGlnaHRzJywgQHNob3dPbmJvYXJkaW5nSGlnaGxpZ2h0c1xuICAgIEBsaXN0ZW5UbyBAb25ib2FyZGluZywgJ2NoYW5nZTpwYWdlSGlnaGxpZ2h0cycsIEBzaG93T25ib2FyZGluZ0hpZ2hsaWdodHNcbiAgICBAbGlzdGVuVG8gQG9uYm9hcmRpbmcsICdjaGFuZ2U6c2hhcmVkSGlnaGxpZ2h0cycsIEBzaG93T25ib2FyZGluZ0hpZ2hsaWdodHNcblxuICByZW5kZXI6IC0+XG4gICAgQHNob3dPbmJvYXJkaW5nSGlnaGxpZ2h0cygpXG5cbiAgc2V0SG9zdDogKEBob3N0KSAtPlxuXG4gIGlzSW5ET006IC0+XG4gICAgJC5jb250YWlucyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIEBlbFxuXG4gIHN0YXJ0VG9vbHRpcFRpbWVvdXQ6IChlKSAtPlxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgICR0YXJnZXQgPSAoJCBlLmN1cnJlbnRUYXJnZXQpXG4gICAgJGNvbnRhaW5lciA9ICR0YXJnZXQuY2xvc2VzdCAnLnRvb2x0aXAtY29udGFpbmVyJ1xuICAgICRwYXJlbnQgPSAoJCBlLmN1cnJlbnRUYXJnZXQub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5mcmFtZUVsZW1lbnQpXG5cbiAgICBzaG93SGlnaGxpZ2h0ID0gJHRhcmdldC5oYXNDbGFzcyAnaGlnaGxpZ2h0J1xuXG4gICAgdGV4dCA9IGlmIHNob3dIaWdobGlnaHRcbiAgICAgICR0YXJnZXQuZmluZCgnLm9uYm9hcmRpbmctdGV4dCcpLmh0bWwoKVxuICAgIGVsc2VcbiAgICAgICR0YXJnZXQuZGF0YSAndG9vbHRpcCdcblxuICAgIHJldHVybiB1bmxlc3MgdGV4dFxuXG4gICAgb2Zmc2V0ID0gJHRhcmdldC5vZmZzZXQoKVxuICAgIHBhcmVudE9mZnNldCA9ICRwYXJlbnQub2Zmc2V0KClcblxuICAgIGlmIEB0b29sdGlwUGxhY2VtZW50IGlzICdiZWxvdydcbiAgICAgIHRvcCA9IHBhcmVudE9mZnNldC50b3BcbiAgICAgIHRvcCArPSBpZiAkY29udGFpbmVyLmxlbmd0aCB0aGVuICRjb250YWluZXIuaGVpZ2h0KCkgZWxzZSAkcGFyZW50LmhlaWdodCgpXG4gICAgZWxzZVxuICAgICAgdG9wID0gcGFyZW50T2Zmc2V0LnRvcFxuICAgICAgdG9wICs9ICRjb250YWluZXIub2Zmc2V0KCkudG9wIGlmICRjb250YWluZXIubGVuZ3RoXG5cbiAgICB0b3AgLT0gKCQgd2luZG93KS5zY3JvbGxUb3AoKVxuXG4gICAgbGVmdCA9IG9mZnNldC5sZWZ0ICsgcGFyZW50T2Zmc2V0LmxlZnQgKyAoJHRhcmdldC5vdXRlcldpZHRoKCkgLyAyKVxuICAgIGlmIHNob3dIaWdobGlnaHRcbiAgICAgIGlmIG9mZnNldC5sZWZ0IDwgMzAwIHRoZW4gbGVmdCArPSAxMDA7IGxlYW4gPSAnbGVhbi1sZWZ0J1xuICAgICAgaWYgb2Zmc2V0LmxlZnQgPiA2MDAgdGhlbiBsZWZ0IC09IDEwMDsgbGVhbiA9ICdsZWFuLXJpZ2h0J1xuICAgICAgaWYgb2Zmc2V0LmxlZnQgPiAoJCB3aW5kb3cpLndpZHRoKCkgLSAxMDBcbiAgICAgICAgbGVmdCAtPSA1MFxuICAgICAgICBsZWFuID0gJ2xlYW4tZmFyLXJpZ2h0J1xuXG4gICAgb3B0cyA9XG4gICAgICB0b3A6IHRvcFxuICAgICAgbGVmdDogbGVmdFxuICAgICAgdGV4dDogdGV4dFxuICAgICAgcGxhY2VtZW50OiBAdG9vbHRpcFBsYWNlbWVudFxuICAgICAgbGVhbjogbGVhbiBvciAnJ1xuXG4gICAgZXZlbnROYW1lID0gaWYgc2hvd0hpZ2hsaWdodFxuICAgICAgJ29uYm9hcmRpbmc6c2hvdy1oaWdobGlnaHQnXG4gICAgZWxzZVxuICAgICAgJ3Rvb2x0aXA6c3RhcnQtdGltZW91dCdcblxuICAgIEBkaXNwYXRjaGVyLnRyaWdnZXIgZXZlbnROYW1lLCBvcHRzXG5cbiAgICBpZiBzaG93SGlnaGxpZ2h0XG4gICAgICAjIHJlbW92ZSB0aGUgaGlnaGxpZ2h0IGFmdGVyIDUwbXNcbiAgICAgIEB0aW1lb3V0ID0gc2V0VGltZW91dCA9PlxuICAgICAgICBAb25ib2FyZGluZy5yZW1vdmVIaWdobGlnaHRzICR0YXJnZXQuYXR0cignY2xhc3MnKS5zcGxpdCAnICdcbiAgICAgICwgNTBcblxuICBzaG93T25ib2FyZGluZ0hpZ2hsaWdodHM6IC0+XG4gICAgQCRlbC5maW5kKCcuYnRuJykucmVtb3ZlQ2xhc3MgJ2hpZ2hsaWdodCdcblxuICAgIGJ1dHRvbnMgPSBAb25ib2FyZGluZy5nZXRIaWdobGlnaHRzKClcbiAgICByZXR1cm4gdW5sZXNzIGJ1dHRvbnMgYW5kIGJ1dHRvbnMubGVuZ3RoXG5cbiAgICBmb3IgYnV0dG9uIGluIGJ1dHRvbnNcbiAgICAgIEAkZWwuZmluZChcIi5idG4uI3tidXR0b259XCIpLmFkZENsYXNzICdoaWdobGlnaHQnXG5cbiAgaGlkZVRvb2x0aXA6IC0+XG4gICAgQGRpc3BhdGNoZXIudHJpZ2dlciAndG9vbHRpcDpoaWRlJ1xuICAgIGNsZWFyVGltZW91dCBAdGltZW91dFxuXG4gIHJlbW92ZTogKGNvbXBsZXRlKSAtPlxuICAgIEAkZWw/Lm9mZiBcIi5iYXNlVmlld0V2ZW50cyN7QGNpZH1cIlxuICAgIHN1cGVyIGlmIEAkZWxcblxuICAgIGNvbXBsZXRlPygpXG4iLCJ7RXZlbnRzfSA9IHJlcXVpcmUgJ2JhY2tib25lJ1xuQW5hbHl0aWNzID0gcmVxdWlyZSAnbW9kZWxzL2FuYWx5dGljcydcbkJyb3dzZXIgPSByZXF1aXJlICdtb2RlbHMvYnJvd3NlcidcblNldHRpbmdzID0gcmVxdWlyZSAnbW9kZWxzL3NldHRpbmdzJ1xuVGFiU2V0dGluZ3MgPSByZXF1aXJlICdtb2RlbHMvdGFiX3NldHRpbmdzJ1xue2RhdGF9ID0gcmVxdWlyZSAnc2RrL3NlbGYnXG5wYWdlTW9kID0gcmVxdWlyZSAnc2RrL3BhZ2UtbW9kJ1xudWkgPSByZXF1aXJlICdzZGsvdWknXG5cbiMgaGVpZ2h0IG9mIHRoZSBzY2FsZSBiYXJcbkJBUl9IRUlHSFRfUENUID0gMjBcbiMgd2lkdGgvaGVpZ2h0IG9mIHRoZSBib3JkZXJcbkJBUl9CT1JERVJfUENUID0gNVxuXG4jIE5vdGU6IG5vdCB1c2luZyBhIGJhY2tib25lIHZpZXcgZHVlIHRvIGl0J3NcbiMgZGVwZW5kZW5jeS9hc3N1bXB0aW9ucyBhcm91bmQgaGF2aW5nIGpxdWVyeSwgYSBkb20sIGV0Yy5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQ2hyb21lQnV0dG9uXG4gIEBzZXR0aW5nczogbnVsbFxuICBAdGFiczoge31cbiAgQG9uSWNvbnM6XG4gICAgMTk6ICdpbWFnZXMvbW96aWNvbl8xOXgxOS5wbmcnXG4gICAgMzg6ICdpbWFnZXMvbW96aWNvbl8zOHgzOC5wbmcnXG5cbiAgQG9mZkljb25zOlxuICAgIDE5OiAnaW1hZ2VzL21vemljb25fb2ZmXzE5eDE5LnBuZydcbiAgICAzODogJ2ltYWdlcy9tb3ppY29uX29mZl8zOHgzOC5wbmcnXG5cbiAgQGZpcmVmb3hXaWRnZXQ6IG51bGxcbiAgQGZpcmVmb3hXb3JrZXJzOiBbXVxuXG4gIEBpbml0aWFsaXplOiAtPlxuICAgIEBzZXR0aW5ncyA9IFNldHRpbmdzLmdldEluc3RhbmNlKClcblxuICAgICMgaW5pdCBzZXR0aW5ncyBmcm9tIGxvY2FsIHN0b3JhZ2VcbiAgICBjaHJvbWU/LnJ1bnRpbWUub25TdGFydHVwPy5hZGRMaXN0ZW5lciA9PlxuICAgICAgQHNldHRpbmdzLnJlc2V0UGFuZWxTdGF0ZSgpXG4gICAgICBAc2V0dGluZ3Muc2F2ZSgpXG5cbiAgICBAc2V0dGluZ3Mub24gJ2NoYW5nZTppc0J1dHRvbk9uIGNoYW5nZTppc01vemJhck9uJywgPT5cbiAgICAgIEByZW5kZXIoKVxuXG4gICAgaWYgdWkuQWN0aW9uQnV0dG9uP1xuICAgICAgIyB3ZSdyZSBpbiBmaXJlZm94LCBzbyBubyB3b3JrZXJzIGhhdmUgYmVlbiBjcmVhdGVkIHlldC5cbiAgICAgICMgbWFrZSBzdXJlIHNldHRpbmdzIGFyZSBpbiBhIGNsZWFuIHN0YXRlLlxuICAgICAgQHNldHRpbmdzLnJlc2V0UGFuZWxTdGF0ZSgpXG4gICAgICBAc2V0dGluZ3Muc2F2ZSgpXG5cbiAgICAgICMgIGJyb2FkY2FzdCBhbnkgY2hhbmdlcyBtYWRlIHRvIHNldHRpbmdzIGZyb20gdGhlIGNocm9tZVxuICAgICAgQHNldHRpbmdzLm9uICdjaGFuZ2UnLCA9PiBAc2V0dGluZ3NDaGFuZ2VkIG51bGwsIEBzZXR0aW5ncy50b0pTT04oKVxuXG4gICAgQGluaXRpYWxpemVDaHJvbWVMaXN0ZW5lcnMoKSBpZiBCcm93c2VyLmlzQ2hyb21lKClcblxuICAgICMgYnV0dG9uIGZvciBmaXJlZm94XG4gICAgQGZpcmVmb3hXaWRnZXQgPSB1aS5BY3Rpb25CdXR0b24/KFxuICAgICAgaWQ6ICdtb3piYXItYnV0dG9uJ1xuICAgICAgbGFiZWw6ICdTaG93L0hpZGUgTW96YmFyJ1xuICAgICAgaWNvbjogZGF0YT8udXJsIEBvZmZJY29uc1snMTknXVxuICAgICAgb25DbGljazogPT5cbiAgICAgICAgQHNldHRpbmdzLnRvZ2dsZU1vemJhcigpXG4gICAgKVxuXG4gICAgIyBwYWdlIG1vZGlmaWVyIGZvciBmaXJlZm94XG4gICAgcGFnZU1vZC5QYWdlTW9kPyhcbiAgICAgIGluY2x1ZGU6ICcqJ1xuICAgICAgYXR0YWNoVG86IFsnZXhpc3RpbmcnLCAndG9wJ11cbiAgICAgIGNvbnRlbnRTY3JpcHRGaWxlOiBbXG4gICAgICAgIGRhdGEudXJsICdzY3JpcHRzL2pxdWVyeS5qcydcbiAgICAgICAgZGF0YS51cmwgJ3NjcmlwdHMvdW5kZXJzY29yZS5qcydcbiAgICAgICAgZGF0YS51cmwgJ3NjcmlwdHMvYmFja2JvbmUuanMnXG4gICAgICAgIGRhdGEudXJsICdzY3JpcHRzL3BlcmZlY3Qtc2Nyb2xsYmFyLmpzJ1xuICAgICAgICBkYXRhLnVybCAnc2NyaXB0cy9qcXVlcnkubW91c2V3aGVlbC5qcydcbiAgICAgICAgZGF0YS51cmwgJ3NjcmlwdHMvanF1ZXJ5LmhpZ2hsaWdodC5qcydcbiAgICAgICAgZGF0YS51cmwgJ3NjcmlwdHMvcmF2ZW4uanMnXG4gICAgICAgIGRhdGEudXJsICdzY3JpcHRzL2NvbnRlbnRfcGFnZS5qcydcbiAgICAgIF1cbiAgICAgIGNvbnRlbnRTdHlsZUZpbGU6IFtkYXRhLnVybCAnc3R5bGVzL2NvbnRlbnRfcGFnZS5jc3MnXVxuICAgICAgIyBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMTA4MjE2Mi9cbiAgICAgIGNvbnRlbnRTY3JpcHRPcHRpb25zOlxuICAgICAgICAnc3R5bGVzL3Rvb2xiYXIuY3NzJzogZGF0YS5sb2FkICdzdHlsZXMvdG9vbGJhci5jc3MnXG5cbiAgICAgIG9uQXR0YWNoOiAod29ya2VyKSA9PiBAYXR0YWNoV29ya2VyIHdvcmtlclxuICAgIClcblxuICAgIHRoaXNcblxuICBAaW5pdGlhbGl6ZUNocm9tZUxpc3RlbmVyczogLT5cbiAgICBjaHJvbWUucnVudGltZS5vbkluc3RhbGxlZC5hZGRMaXN0ZW5lciAocmVhc29uKSA9PlxuICAgICAgQHNldHRpbmdzLnNldCBleHRlbnNpb25WZXJzaW9uOiBjaHJvbWUuYXBwLmdldERldGFpbHMoKS52ZXJzaW9uXG4gICAgICBpZiByZWFzb24ucmVhc29uIGlzICd1cGRhdGUnIHRoZW4gcmV0dXJuIEBzZXR0aW5ncy5zYXZlKClcblxuICAgICAgQHNldHRpbmdzLm9uTmV3SW5zdGFsbCgpXG4gICAgICBBbmFseXRpY3MuZ2V0SW5zdGFuY2UoKS50cmFja05ld0luc3RhbGwoKVxuXG4gICAgY2hyb21lLmJyb3dzZXJBY3Rpb24ub25DbGlja2VkLmFkZExpc3RlbmVyID0+XG4gICAgICBAc2V0dGluZ3MudG9nZ2xlTW96YmFyKClcblxuICAgIGNocm9tZS5ydW50aW1lLm9uTWVzc2FnZS5hZGRMaXN0ZW5lciAocmVxdWVzdCwgc2VuZGVyLCByZXNwb25zZSkgPT5cbiAgICAgIEBtZXNzYWdlUmVjZWl2ZWQgcmVxdWVzdCwgc2VuZGVyLCByZXNwb25zZVxuXG4gICAgZmlsdGVyID1cbiAgICAgIHVybHM6IFsnPGFsbF91cmxzPiddXG4gICAgICB0eXBlczogWydtYWluX2ZyYW1lJ11cblxuICAgICMgVE9ETzogdXNlIHRoZSBkZWNsYXJhdGl2ZVdlYlJlcXVlc3QgQVBJIGFuZCBtb3ZlIGJhY2sgdG8gRXZlbnQgUGFnZXNcbiAgICAjICBvbmNlIGF2YWlsYWJsZSAoY3VycmVudGx5IG9ubHkgd29ya3Mgb24gYmV0YSBhbmQgZGV2IGNoYW5uZWxzKS5cbiAgICAjICB1c2luZyBldmVudCBwYWdlcyB3aWxsIGJlIHF1aWNrZXIgYW5kIHVzZSBsZXNzIG1lbW9yeS5cbiAgICAjICBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL2RlY2xhcmF0aXZlV2ViUmVxdWVzdFxuICAgIGNocm9tZS53ZWJSZXF1ZXN0Lm9uQmVmb3JlUmVxdWVzdC5hZGRMaXN0ZW5lciAoZGV0YWlscykgPT5cbiAgICAgIEBiZWZvcmVSZXF1ZXN0IGRldGFpbHNcbiAgICAsIGZpbHRlclxuXG4gICAgY2hyb21lLndlYlJlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQuYWRkTGlzdGVuZXIgKGRldGFpbHMpID0+XG4gICAgICBAaGVhZGVyc1JlY2VpdmVkIGRldGFpbHNcbiAgICAsIGZpbHRlclxuXG4gICAgY2hyb21lLndlYlJlcXVlc3Qub25CZWZvcmVSZWRpcmVjdC5hZGRMaXN0ZW5lciAoZGV0YWlscykgPT5cbiAgICAgIEBiZWZvcmVSZWRpcmVjdCBkZXRhaWxzXG4gICAgLCBmaWx0ZXJcblxuICAgIGNocm9tZS53ZWJSZXF1ZXN0Lm9uQ29tcGxldGVkLmFkZExpc3RlbmVyIChkZXRhaWxzKSA9PlxuICAgICAgQGNvbXBsZXRlZCBkZXRhaWxzXG4gICAgLCBmaWx0ZXJcblxuICBAaW5pdGlhbGl6ZVRhYjogKGlkKSAtPlxuICAgIEB0YWJzW2lkXSA/PVxuICAgICAgdGFiU2V0dGluZ3M6IG5ldyBUYWJTZXR0aW5nc1xuICAgICAgcmVkaXJlY3Q6IGZhbHNlXG5cbiAgQGF0dGFjaFdvcmtlcjogKHdvcmtlcikgLT5cbiAgICBAZmlyZWZveFdvcmtlcnMucHVzaCB3b3JrZXJcbiAgICBAaW5pdGlhbGl6ZVRhYiB3b3JrZXIudGFiLmlkXG5cbiAgICB3b3JrZXIub24gJ2RldGFjaCcsID0+XG4gICAgICBAZmlyZWZveFdvcmtlcnMuc3BsaWNlKGksIDEpIGZvciB3LCBpIGluIEBmaXJlZm94V29ya2VycyB3aGVuIHcgaXMgd29ya2VyXG5cbiAgICB3b3JrZXIucG9ydC5lbWl0ICdzZXR0aW5nc0NoYW5nZWQnLCBAc2V0dGluZ3MudG9KU09OKClcblxuICAgIHdvcmtlci5wb3J0Lm9uICdzZXR0aW5nc0NoYW5nZWQnLCAoYXR0cmlidXRlcykgPT5cbiAgICAgIEBzZXR0aW5nc0NoYW5nZWQgd29ya2VyLCBhdHRyaWJ1dGVzXG5cbiAgICB3b3JrZXIucG9ydC5vbiAnc2V0VGFiU2V0dGluZ3MnLCAoZGF0YSkgPT5cbiAgICAgIEBzZXRUYWJTZXR0aW5ncyB3b3JrZXIudGFiLmlkLCBkYXRhXG5cbiAgICB3b3JrZXIucG9ydC5vbiAnZ2V0VGFiU2V0dGluZ3MnLCA9PlxuICAgICAgd29ya2VyLnBvcnQuZW1pdCAnZ2V0VGFiU2V0dGluZ3M6cmVzcG9uc2UnLCBAZ2V0VGFiU2V0dGluZ3Mgd29ya2VyLnRhYi5pZFxuXG4gIEBzZXR0aW5nc0NoYW5nZWQ6IChmcm9tV29ya2VyLCBhdHRyaWJ1dGVzKSAtPlxuICAgIEBzZXR0aW5ncy5zZXQgYXR0cmlidXRlc1xuICAgIEBzZXR0aW5ncy5zYXZlKClcblxuICAgIGZvciB3b3JrZXIgaW4gQGZpcmVmb3hXb3JrZXJzIHdoZW4gd29ya2VyIGlzbnQgZnJvbVdvcmtlclxuICAgICAgd29ya2VyLnBvcnQuZW1pdCAnc2V0dGluZ3NDaGFuZ2VkJywgYXR0cmlidXRlc1xuXG4gIEByZW5kZXI6IC0+XG4gICAgY2hyb21lPy50YWJzLnF1ZXJ5IHt9LCAodGFicykgPT5cbiAgICAgIEByZW5kZXJUYWJJZCB0YWIuaWQgZm9yIHRhYiBpbiB0YWJzXG5cbiAgQHJlbmRlclRhYklkOiAodGFiSWQpIC0+XG4gICAgaXNNb3piYXJPbiA9IEBzZXR0aW5ncy5nZXQgJ2lzTW96YmFyT24nXG4gICAgaXNCdXR0b25PbiA9IEBzZXR0aW5ncy5nZXQgJ2lzQnV0dG9uT24nXG4gICAgaWNvbnMgPSBpZiBpc0J1dHRvbk9uIHRoZW4gcGF0aDogQG9uSWNvbnMgZWxzZSBwYXRoOiBAb2ZmSWNvbnNcbiAgICB0aXRsZSA9ICdNb3pCYXIgZnJvbSBNb3pcXG4oQ3RybCtTaGlmdCtBbHQrTSknXG5cbiAgICBAZmlyZWZveFdpZGdldD8uaWNvbiA9IGRhdGE/LnVybCBpY29ucy5wYXRoWycxOSddXG5cbiAgICBpZiBpc0J1dHRvbk9uIGFuZCBub3QgaXNNb3piYXJPbiBhbmQgbm90IF8uaXNVbmRlZmluZWQgQHRhYnNbdGFiSWRdPy5kYVxuICAgICAgaWNvbnMgPSBpbWFnZURhdGE6IEBnZXROdW1iZXJJY29ucyBAdGFic1t0YWJJZF0uZGFcbiAgICAgIHRpdGxlID0gJ0RvbWFpbiBBdXRob3JpdHkgZm9yIHRoaXMgZG9tYWluJ1xuXG4gICAgY2hyb21lPy5icm93c2VyQWN0aW9uLnNldEljb24gXy5leHRlbmQgaWNvbnMsIHt0YWJJZH1cbiAgICBjaHJvbWU/LmJyb3dzZXJBY3Rpb24uc2V0VGl0bGUge3RhYklkLCB0aXRsZX1cblxuICBAbWVzc2FnZVJlY2VpdmVkOiAocmVxdWVzdCwgc2VuZGVyLCByZXNwb25zZSkgLT5cbiAgICBzd2l0Y2ggcmVxdWVzdC50eXBlXG4gICAgICB3aGVuICdzdGF0dXMtaGlzdG9yeSdcbiAgICAgICAgcmVzcG9uc2UgQHRhYnNbc2VuZGVyLnRhYi5pZF0uc3RhdHVzZXNcbiAgICAgIHdoZW4gJ3NldFRhYlNldHRpbmdzJ1xuICAgICAgICBAc2V0VGFiU2V0dGluZ3Mgc2VuZGVyLnRhYi5pZCwgcmVxdWVzdC5kYXRhXG4gICAgICB3aGVuICdnZXRUYWJTZXR0aW5ncydcbiAgICAgICAgcmVzcG9uc2UgQGdldFRhYlNldHRpbmdzIHNlbmRlci50YWIuaWRcbiAgICAgIHdoZW4gJ21ldHJpY3NDaGFuZ2VkJ1xuICAgICAgICBAaW5pdGlhbGl6ZVRhYiBzZW5kZXIudGFiLmlkXG4gICAgICAgIEB0YWJzW3NlbmRlci50YWIuaWRdLmRhID0gcmVxdWVzdC5kYXRhLm5pY2VQZGFcbiAgICAgICAgQHJlbmRlclRhYklkIHNlbmRlci50YWIuaWRcblxuICBAYmVmb3JlUmVxdWVzdDogKGRldGFpbHMpIC0+XG4gICAgQGluaXRpYWxpemVUYWIgZGV0YWlscy50YWJJZFxuICAgIEB0YWJzW2RldGFpbHMudGFiSWRdLnN0YXR1c2VzID0gW10gdW5sZXNzIEB0YWJzW2RldGFpbHMudGFiSWRdLnJlZGlyZWN0XG5cbiAgQGJlZm9yZVJlZGlyZWN0OiAoZGV0YWlscykgLT5cbiAgICBAdGFic1tkZXRhaWxzLnRhYklkXS5yZWRpcmVjdCA9IHRydWVcblxuICBAaGVhZGVyc1JlY2VpdmVkOiAoZGV0YWlscykgLT5cbiAgICBAaW5pdGlhbGl6ZVRhYiBkZXRhaWxzLnRhYklkXG4gICAgQHRhYnNbZGV0YWlscy50YWJJZF0uc3RhdHVzZXMgPSBbXSB1bmxlc3MgQHRhYnNbZGV0YWlscy50YWJJZF0ucmVkaXJlY3RcbiAgICBAdGFic1tkZXRhaWxzLnRhYklkXS5zdGF0dXNlcy5wdXNoXG4gICAgICBzdGF0dXM6IGRldGFpbHMuc3RhdHVzTGluZVxuICAgICAgdXJsOiBkZXRhaWxzLnVybFxuXG4gIEBjb21wbGV0ZWQ6IChkZXRhaWxzKSAtPlxuICAgIEBpbml0aWFsaXplVGFiIGRldGFpbHMudGFiSWRcbiAgICBAdGFic1tkZXRhaWxzLnRhYklkXS5yZWRpcmVjdCA9IGZhbHNlXG5cbiAgQHNldFRhYlNldHRpbmdzOiAoaWQsIGRhdGEpIC0+XG4gICAgQHRhYnNbaWRdPy50YWJTZXR0aW5ncy5zZXQgZGF0YVxuXG4gIEBnZXRUYWJTZXR0aW5nczogKGlkKSAtPlxuICAgIEB0YWJzW2lkXT8udGFiU2V0dGluZ3MudG9KU09OKClcblxuICBAZ2V0TnVtYmVySWNvbnM6IChuKSAtPlxuICAgIDE5OiBAY3JlYXRlTnVtYmVySWNvbihuLCAxOSwgMTkpLmdldENvbnRleHQoJzJkJykuZ2V0SW1hZ2VEYXRhIDAsIDAsIDE5LCAxOVxuICAgIDM4OiBAY3JlYXRlTnVtYmVySWNvbihuLCAzOCwgMzgpLmdldENvbnRleHQoJzJkJykuZ2V0SW1hZ2VEYXRhIDAsIDAsIDM4LCAzOFxuXG4gIEBjcmVhdGVOdW1iZXJJY29uOiAobiwgd2lkdGgsIGhlaWdodCkgLT5cbiAgICBib3JkZXIgPSBNYXRoLnJvdW5kIGhlaWdodCAqIChCQVJfQk9SREVSX1BDVCAvIDEwMClcblxuICAgIGJhckhlaWdodCA9IChCQVJfSEVJR0hUX1BDVC8xMDApICogaGVpZ2h0XG4gICAgYmFyWCA9IGJvcmRlclxuICAgIGJhclkgPSBoZWlnaHQgLSBiYXJIZWlnaHQgLSBib3JkZXJcbiAgICBiYXJXaWR0aCA9IHdpZHRoIC0gKGJvcmRlciAqIDIpXG5cbiAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50ICdjYW52YXMnXG4gICAgY2FudmFzLndpZHRoID0gd2lkdGhcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0XG5cbiAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQgJzJkJ1xuXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAnIzRlNWM1ZidcbiAgICBjb250ZXh0LmZpbGxSZWN0IDAsIDAsIHdpZHRoLCBoZWlnaHRcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyNlNmU4ZTgnXG4gICAgY29udGV4dC5maWxsUmVjdCBiYXJYLCBiYXJZLCBiYXJXaWR0aCwgYmFySGVpZ2h0XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjNGRiZGViJ1xuICAgIGNvbnRleHQuZmlsbFJlY3QgYmFyWCwgYmFyWSwgYmFyV2lkdGggKiAobiAvIDEwMCksIGJhckhlaWdodFxuXG4gICAgZm9udFNpemUgPSBpZiB3aWR0aCBpcyAxOSB0aGVuIDEwIGVsc2UgMjBcbiAgICBjb250ZXh0LmZvbnQgPSBcImJvbGQgI3tmb250U2l6ZX1weCBPcGVuIFNhbnMsIHNhbnMtc2VyaWZcIlxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyNlNmU4ZTgnXG4gICAgY29udGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJ1xuICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ21pZGRsZSdcbiAgICBjb250ZXh0LmZpbGxUZXh0IG4sIHdpZHRoIC8gMiwgKGhlaWdodCAtIGJhckhlaWdodCkgLyAyXG5cbiAgICBjYW52YXNcbiIsIkJhc2VWaWV3ID0gcmVxdWlyZSAndmlld3MvYmFzZV92aWV3J1xudGVtcGxhdGUgPSByZXF1aXJlICd0ZW1wbGF0ZXMvYnV0dG9uX25vdGlmaWNhdGlvbidcbmJyb3dzZXJCdXR0b24gPSByZXF1aXJlICd2aWV3cy9icm93c2VyX2J1dHRvbidcblVybE1ldHJpY3MgPSByZXF1aXJlICdtb2RlbHMvdXJsX21ldHJpY3MnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQnV0dG9uTm90aWZpY2F0aW9uIGV4dGVuZHMgQmFzZVZpZXdcbiAgZXZlbnRzOlxuICAgICdjbGljayAuY2xvc2UnOiAnY2xvc2UnXG5cbiAgcmVuZGVyOiAtPlxuICAgIEAkZWwuaHRtbCB0ZW1wbGF0ZSgpXG5cbiAgICB1cmxNZXRyaWNzID0gVXJsTWV0cmljcy5nZXRJbnN0YW5jZSgpXG4gICAgcGRhID0gdXJsTWV0cmljcy5nZXQgJ25pY2VQZGEnXG4gICAgcGRhID89IDEwMFxuXG4gICAgaW1nID0gQCRlbC5maW5kKCcuaWNvbicpWzBdXG4gICAgaWNvbiA9IGJyb3dzZXJCdXR0b24uY3JlYXRlTnVtYmVySWNvbiBwZGEsIDE5LCAxOVxuXG4gICAgaW1nLnNyYyA9IGljb24udG9EYXRhVVJMKClcblxuICBjbG9zZTogLT5cbiAgICBAaG9zdC5yZW1vdmUoKVxuICAgIHJldHVybiBmYWxzZVxuIiwiJCA9IHJlcXVpcmUgJ2pxdWVyeSdcbkJhc2VFbGVtZW50ID0gcmVxdWlyZSAndmlld3MvYmFzZV9lbGVtZW50J1xuQnV0dG9uTm90aWZpY2F0aW9uID0gcmVxdWlyZSAndmlld3MvYnV0dG9uX25vdGlmaWNhdGlvbidcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBCdXR0b25Ob3RpZmljYXRpb25FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnRcbiAgRElTUExBWV9NUzogMjUwMFxuXG4gIGVsZW1lbnRDc3NDbGFzczogJ2J1dHRvbi1ub3RpZmljYXRpb24nXG4gIGVsZW1lbnRWaWV3Q2xhc3M6IEJ1dHRvbk5vdGlmaWNhdGlvblxuXG4gIGlkOiAnbW96YmFyLWJ1dHRvbi1ub3RpZmljYXRpb24tI3JhbmRvbS1rZXknXG5cbiAgcmVuZGVyOiAtPlxuICAgIHN1cGVyXG4gICAgc2V0VGltZW91dCA9PlxuICAgICAgQCRlbGVtZW50Um9vdC5jbG9zZXN0KCdodG1sLCBib2R5JykuYW5pbWF0ZSBvcGFjaXR5OiAwLCA1MDAsID0+XG4gICAgICAgIEByZW1vdmUoKVxuICAgICwgQERJU1BMQVlfTVNcbiIsIiQgPSByZXF1aXJlICdqcXVlcnknXG5BbmFseXRpY3MgPSByZXF1aXJlICdtb2RlbHMvYW5hbHl0aWNzJ1xuQWRkcmVzc0JhckhpZ2hsaWdodCA9IHJlcXVpcmUgJ3ZpZXdzL2FkZHJlc3NfYmFyX2hpZ2hsaWdodCdcbkJ1dHRvbk5vdGlmaWNhdGlvbkVsZW1lbnQgPSByZXF1aXJlICd2aWV3cy9idXR0b25fbm90aWZpY2F0aW9uX2VsZW1lbnQnXG5EaXNwYXRjaGVyID0gcmVxdWlyZSAndmlld3MvZXZlbnRfZGlzcGF0Y2hlcidcbkhpZ2hsaWdodGVyID0gcmVxdWlyZSAndmlld3MvaGlnaGxpZ2h0ZXInXG5Nb3piYXJFbGVtZW50ID0gcmVxdWlyZSAndmlld3MvbW96YmFyX2VsZW1lbnQnXG5QYWdlID0gcmVxdWlyZSAnbW9kZWxzL3BhZ2UnXG5Vc2VyID0gcmVxdWlyZSAnbW9kZWxzL3VzZXInXG5TZXJwQXR0cmlidXRlcyA9IHJlcXVpcmUgJ21vZGVscy9zZXJwX2F0dHJpYnV0ZXMnXG5TZXJwRWxlbWVudCA9IHJlcXVpcmUgJ3ZpZXdzL3NlcnBfZWxlbWVudCdcblRvb2x0aXBFbGVtZW50ID0gcmVxdWlyZSAndmlld3MvdG9vbHRpcF9lbGVtZW50J1xuT25ib2FyZGluZ1RpcEVsZW1lbnQgPSByZXF1aXJlICd2aWV3cy9vbmJvYXJkaW5nX3RpcF9lbGVtZW50J1xuT25ib2FyZGluZ0RpYWxvZyA9IHJlcXVpcmUgJ3ZpZXdzL29uYm9hcmRpbmdfZGlhbG9nJ1xuS2V5d29yZERpZmZpY3VsdHlFbGVtZW50ID0gcmVxdWlyZSAndmlld3Mva2V5d29yZF9kaWZmaWN1bHR5X2VsZW1lbnQnXG5TZXR0aW5ncyA9IHJlcXVpcmUgJ21vZGVscy9zZXR0aW5ncydcbkJ1dHRvbk1ldHJpY3MgPSByZXF1aXJlICdtb2RlbHMvYnV0dG9uX21ldHJpY3MnXG5yZXF1aXJlICdoZWxwZXJzL2hhbmRsZWJhcnNfaGVscGVycydcbnJlcXVpcmUgJ2hlbHBlcnMvaGFuZGxlYmFyc19wYXJ0aWFscydcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBDb250ZW50UGFnZVxuICBAc2V0dGluZ3M6IFNldHRpbmdzLmdldEluc3RhbmNlKClcbiAgQGFuYWx5dGljczogQW5hbHl0aWNzLmdldEluc3RhbmNlKClcbiAgQGRpc3BhdGNoZXI6IERpc3BhdGNoZXIuZ2V0SW5zdGFuY2UoKVxuXG4gIEBtb3piYXI6IG51bGxcbiAgQHNlcnBJdGVtczogW11cbiAgQGRvbUNoYW5nZWRUaW1lcjogbnVsbFxuICBAdG9vbHRpcDogbmV3IFRvb2x0aXBFbGVtZW50XG4gIEBvbmJvYXJkaW5nVGlwOiBuZXcgT25ib2FyZGluZ1RpcEVsZW1lbnRcbiAgQGtleXdvcmREaWZmaWN1bHR5OiBudWxsXG4gIEB1c2VyOiBudWxsXG4gIEBidXR0b25NZXRyaWNzOiBudWxsXG5cbiAgIyB0cmFjayB0aGUgb3JpZ2luYWwgc3RhdGUgc28gd2Uga25vdyB3aGVuIGl0IGNoYW5nZXNcbiAgQHdhc0J1dHRvbk9uOiBudWxsXG4gIEB3YXNNb3piYXJPbjogbnVsbFxuXG4gIEBpbml0aWFsaXplOiAtPlxuICAgIEhpZ2hsaWdodGVyLmluaXRpYWxpemUoKVxuXG4gICAgKCQgZG9jdW1lbnQpLm9uICdrZXlkb3duJywgKGUpID0+IEBrZXlkb3duIGVcblxuICAgIEBtb3piYXJPbkNoYW5nZWQoKVxuXG4gICAgQHNldHRpbmdzLm9uICdjaGFuZ2U6aXNNb3piYXJPbicsID0+XG4gICAgICBAbW96YmFyT25DaGFuZ2VkKClcblxuICAgIGlmIFBhZ2UuaXNTZXJwKClcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgJ0RPTU5vZGVJbnNlcnRlZCcsID0+XG4gICAgICAgIEBkb21Ob2RlSW5zZXJ0ZWQoKVxuXG4gICAgQHVzZXIgPSBVc2VyLmdldEluc3RhbmNlKClcbiAgICBAdXNlci5vbiAnY2hhbmdlJywgPT4gQHVzZXJDaGFuZ2VkKClcblxuICAgIHJldHVybiB0aGlzXG5cbiAgQG1vemJhck9uQ2hhbmdlZDogLT5cbiAgICBpc01vemJhck9uID0gQHNldHRpbmdzLmdldCAnaXNNb3piYXJPbidcbiAgICBAd2FzTW96YmFyT24gPz0gaXNNb3piYXJPblxuXG4gICAgaWYgQHdhc01vemJhck9uIGlzbnQgaXNNb3piYXJPbiBhbmQgbm90IGlzTW96YmFyT25cbiAgICAgIHNldFRpbWVvdXQgLT5cbiAgICAgICAgKG5ldyBCdXR0b25Ob3RpZmljYXRpb25FbGVtZW50KS5yZW5kZXIoKVxuICAgICAgLCAyMDBcblxuICAgIGlmIEBzZXR0aW5ncy5nZXQoJ2lzQnV0dG9uT24nKSBhbmQgbm90IGlzTW96YmFyT25cbiAgICAgIEBidXR0b25NZXRyaWNzID89IG5ldyBCdXR0b25NZXRyaWNzKClcbiAgICAgIEBidXR0b25NZXRyaWNzLmZldGNoKClcblxuICAgIEB3YXNNb3piYXJPbiA9IGlzTW96YmFyT25cbiAgICBAcmVuZGVyKClcblxuICBAa2V5ZG93bjogKGUpIC0+XG4gICAgIyBDb21tYW5kIGtleSB0byB0dXJuIG1vemJvYXIgb24gYW5kIG9mZjpcbiAgICAjICAgQ3RybCtTaGlmdCtBbHQrbVxuICAgIGlmIGUud2hpY2ggaXMgNzcgYW5kIGUuY3RybEtleSBhbmQgZS5zaGlmdEtleSBhbmQgZS5hbHRLZXlcbiAgICAgIEBzZXR0aW5ncy50b2dnbGVNb3piYXIoKVxuXG4gIEBkb21Ob2RlSW5zZXJ0ZWQ6IC0+XG4gICAgY2xlYXJUaW1lb3V0IEBkb21DaGFuZ2VkVGltZXJcblxuICAgIGlmIG5vdCBAc2V0dGluZ3MuZ2V0KCdpc01vemJhck9uJykgb3IgUGFnZS5pc0JsYWNrbGlzdGVkKClcbiAgICAgIHJldHVyblxuXG4gICAgIyBnaXZlIHNvbWUgdGltZSBmb3IgYW55IG90aGVyIGRvbSBjaGFuZ2VzIHRvIGJlXG4gICAgIyBtYWRlIGJlZm9yZSByZS1yZW5kZXJpbmcgc2VycCBpdGVtcy5cbiAgICBAZG9tQ2hhbmdlZFRpbWVyID0gc2V0VGltZW91dCA9PlxuICAgICAgQHJlbmRlclNlcnBJdGVtcygpXG4gICAgICBAcmVuZGVyS2V5d29yZERpZmZpY3VsdHkoKSBpZiBQYWdlLmdldFNlcnBFbmdpbmUoKSBpcyAnZ29vZ2xlJ1xuICAgICwgMTAwXG5cbiAgQHJlbmRlcjogLT5cbiAgICBAYW5hbHl0aWNzLnRyYWNrQWN0aXZlVXNlcigpIGlmIEBzZXR0aW5ncy5nZXQgJ2lzQnV0dG9uT24nXG5cbiAgICBpZiBub3QgQHNldHRpbmdzLmdldCgnaXNNb3piYXJPbicpIG9yIFBhZ2UuaXNCbGFja2xpc3RlZCgpXG4gICAgICBAcmVtb3ZlKClcbiAgICAgIHJldHVyblxuXG4gICAgQG1vemJhciA/PSBuZXcgTW96YmFyRWxlbWVudCBpZDogJ21vemJhci0jcmFuZG9tLWtleSdcbiAgICBAbW96YmFyLnJlbmRlcigpXG5cbiAgICBAYWRkcmVzc0JhckhpZ2hsaWdodCA9IG5ldyBBZGRyZXNzQmFySGlnaGxpZ2h0KClcblxuICAgIEBvbmJvYXJkaW5nRGlhbG9nID0gbmV3IE9uYm9hcmRpbmdEaWFsb2coKVxuXG4gICAgQHJlbmRlclNlcnBJdGVtcygpIGlmIFBhZ2UuaXNTZXJwKClcbiAgICBAcmVuZGVyS2V5d29yZERpZmZpY3VsdHkoKVxuXG4gICAgQGFuYWx5dGljcy50cmFja0FjdGl2ZVVzZXIoKVxuXG4gIEByZW5kZXJTZXJwSXRlbXM6IC0+XG4gICAgIyBtYWtlIHN1cmUgYW55IGV4aXN0aW5nIGl0ZW1zIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgRE9NXG4gICAgIyBhcmUgY2xlYW5lZCB1cFxuICAgIEBzZXJwSXRlbXMgPSAoaXRlbSBmb3IgaXRlbSBpbiBAc2VycEl0ZW1zIHdoZW4gaXRlbS5pc0luRE9NKCkpXG5cbiAgICAjIGFkZCBuZXcgc2VycCBiYXJzIHRvIGFueSByZXN1bHRzIHRoYXQgZG9uJ3QgeWV0IGhhdmUgaXRcbiAgICAoJCBQYWdlLmdldFNlcnBDb25maWcoKS5zZWxlY3RvcilcbiAgICAgIC5ub3QoJzpoYXMoLm1vemJhci1zZXJwLWl0ZW0tI3JhbmRvbS1rZXkpJylcbiAgICAgIC5lYWNoIChpLCBlbCkgPT5cbiAgICAgICAgbW9kZWwgPSBuZXcgU2VycEF0dHJpYnV0ZXMgZWw6IGVsLCBwb3NpdGlvbjogaSsxXG4gICAgICAgIHNlcnBFbGVtZW50ID0gbmV3IFNlcnBFbGVtZW50IG1vZGVsOiBtb2RlbFxuXG4gICAgICAgIHNlcnBFbGVtZW50LnJlbmRlcigpXG4gICAgICAgIEBzZXJwSXRlbXMucHVzaCBzZXJwRWxlbWVudFxuXG4gIEByZW5kZXJLZXl3b3JkRGlmZmljdWx0eTogLT5cbiAgICByZXR1cm4gdW5sZXNzIEBzZXR0aW5ncy5nZXQgJ2lzTW96YmFyT24nXG4gICAgcmV0dXJuIHVubGVzcyBQYWdlLmdldFNlcnBFbmdpbmUoKSBpcyAnZ29vZ2xlJ1xuXG4gICAgQGtleXdvcmREaWZmaWN1bHR5ID89IG5ldyBLZXl3b3JkRGlmZmljdWx0eUVsZW1lbnRcbiAgICByZXR1cm4gaWYgQGtleXdvcmREaWZmaWN1bHR5LmlzSW5ET00oKVxuXG4gICAgIyBnb29nbGUgbGF6eS1sb2FkcyB0aGUgc2VhcmNoIGJveCwgc28gbWFrZSBzdXJlIGl0J3MgdGhlcmUuLlxuICAgIHJldHVybiB1bmxlc3MgQGtleXdvcmREaWZmaWN1bHR5LnBhcmVudEVsZW1lbnQoKS5sZW5ndGhcblxuICAgIEBrZXl3b3JkRGlmZmljdWx0eS5yZW5kZXIoKVxuXG4gIEB1c2VyQ2hhbmdlZDogLT5cbiAgICBpZiBAdXNlci5nZXQgJ2lzUHJvJ1xuICAgICAgQHJlbmRlcktleXdvcmREaWZmaWN1bHR5KClcbiAgICBlbHNlXG4gICAgICBAa2V5d29yZERpZmZpY3VsdHk/LnJlbW92ZSgpXG5cbiAgQHJlbW92ZTogLT5cbiAgICBAbW96YmFyPy5yZW1vdmUoKVxuICAgIEBtb3piYXIgPSBudWxsXG5cbiAgICBpdGVtLnJlbW92ZSgpIGZvciBpdGVtIGluIEBzZXJwSXRlbXNcbiAgICBAc2VycEl0ZW1zID0gW11cblxuICAgIEBrZXl3b3JkRGlmZmljdWx0eT8ucmVtb3ZlKClcbiAgICBAYWRkcmVzc0JhckhpZ2hsaWdodD8ucmVtb3ZlKClcbiAgICBAb25ib2FyZGluZ0RpYWxvZz8ucmVtb3ZlKClcbiIsIl8gPSByZXF1aXJlICd1bmRlcnNjb3JlJ1xuQmFja2JvbmUgPSByZXF1aXJlICdiYWNrYm9uZSdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBFdmVudERpc3BhdGNoZXJcbiAgQGV2ZW50RGlzcGF0Y2hlcjogbnVsbFxuICBAZ2V0SW5zdGFuY2U6IC0+XG4gICAgQGV2ZW50RGlzcGF0Y2hlciA/PSBuZXcgRXZlbnREaXNwYXRjaGVyKClcblxuICBfLmV4dGVuZCBAcHJvdG90eXBlLCBCYWNrYm9uZS5FdmVudHNcbiIsIkhlbHBWaWV3ID0gcmVxdWlyZSAndmlld3MvaGVscF92aWV3J1xuQmFzZURpYWxvZyA9IHJlcXVpcmUgJ3ZpZXdzL2Jhc2VfZGlhbG9nJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEhlbHBEaWFsb2cgZXh0ZW5kcyBCYXNlRGlhbG9nXG4gIGVsZW1lbnRDc3NDbGFzczogJ2RpYWxvZyBoZWxwLWRpYWxvZydcbiAgZWxlbWVudFZpZXdDbGFzczogSGVscFZpZXdcbiAgb3ZlcmxheTogbnVsbFxuXG4gIGlkOiAnbW96YmFyLWhlbHAtZGlhbG9nLSNyYW5kb20ta2V5J1xuXG4gIHJlbmRlcjogLT5cbiAgICBzdXBlclxuICAgIEAkZWwuY3NzXG4gICAgICB0b3A6IEBvcHRpb25zLnRvcFxuICAgICAgYm90dG9tOiBAb3B0aW9ucy5ib3R0b21cbiAgICAgIGxlZnQ6IEBvcHRpb25zLmxlZnQgLSBAJGVsLndpZHRoKCkgKyAyMFxuXG4iLCIkID0gcmVxdWlyZSAnanF1ZXJ5J1xuQW5hbHl0aWNzID0gcmVxdWlyZSAnbW9kZWxzL2FuYWx5dGljcydcbkJhc2VWaWV3ID0gcmVxdWlyZSAndmlld3MvYmFzZV92aWV3J1xuT25ib2FyZGluZyA9IHJlcXVpcmUgJ21vZGVscy9vbmJvYXJkaW5nJ1xuXG50ZW1wbGF0ZSA9IHJlcXVpcmUgJ3RlbXBsYXRlcy9oZWxwX2RpYWxvZydcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBIZWxwVmlldyBleHRlbmRzIEJhc2VWaWV3XG4gIGV2ZW50czpcbiAgICAnY2xpY2sgLnRvdXInOiAnc2hvd1RvdXInXG5cbiAgcmVuZGVyOiAtPlxuICAgIEAkZWwuaHRtbCB0ZW1wbGF0ZVxuXG4gICAgKCQgJyNtb3piYXItaGVscC1kaWFsb2ctI3JhbmRvbS1rZXknKVxuICAgICAgLmhpZGUoKVxuICAgICAgLnNsaWRlRG93biAnZmFzdCdcblxuICBzaG93VG91cjogLT5cbiAgICBAY2xvc2UoKVxuICAgIE9uYm9hcmRpbmcuZ2V0SW5zdGFuY2UoKS5yZXN0YXJ0KClcbiAgICBBbmFseXRpY3MuZ2V0SW5zdGFuY2UoKS50cmFja0luaXRpYXRlT25ib2FyZGluZygpXG5cbiAgY2xvc2U6IC0+XG4gICAgQGhvc3QucmVtb3ZlKClcbiAgICByZXR1cm4gZmFsc2VcblxuICByZW1vdmU6IChjYWxsYmFjaykgLT5cbiAgICAoJCAnI21vemJhci1oZWxwLWRpYWxvZy0jcmFuZG9tLWtleScpLnNsaWRlVXAgJ2Zhc3QnLCA9PlxuICAgICAgc3VwZXJcbiAgICAgIGNhbGxiYWNrPy5hcHBseSB0aGlzXG4iLCIkID0gcmVxdWlyZSAnanF1ZXJ5J1xuRGlzcGF0Y2hlciA9IHJlcXVpcmUgJ3ZpZXdzL2V2ZW50X2Rpc3BhdGNoZXInXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgSGlnaGxpZ2h0ZXJcbiAgQGRpc3BhdGNoZXI6IERpc3BhdGNoZXIuZ2V0SW5zdGFuY2UoKVxuICBAaGlnaGxpZ2h0T3B0czpcbiAgICBjbGFzc05hbWU6ICdtb3piYXItaGlnaGxpZ2h0LWtleXdvcmQtI3JhbmRvbS1rZXknXG5cbiAgQGluaXRpYWxpemU6IC0+XG4gICAgQGRpc3BhdGNoZXIub24gJ2hpZ2hsaWdodC1saW5rczpjaGFuZ2UnLCAodHlwZSwgaXNPbikgPT5cbiAgICAgIEBoaWdobGlnaHRMaW5rc0NoYW5nZSB0eXBlLCBpc09uXG5cbiAgICBAZGlzcGF0Y2hlci5vbiAnaGlnaGxpZ2h0LWtleXdvcmQ6Y2hhbmdlJywgKGtleXdvcmQpID0+XG4gICAgICBAaGlnaGxpZ2h0S2V5d29yZCBrZXl3b3JkXG5cbiAgQGhpZ2hsaWdodExpbmtzQ2hhbmdlOiAodHlwZSwgaXNPbikgLT5cbiAgICBpZiBpc09uIHRoZW4gQGhpZ2hsaWdodCB0eXBlIGVsc2UgQHVuaGlnaGxpZ2h0IHR5cGVcblxuICBAaGlnaGxpZ2h0OiAodHlwZSkgLT5cbiAgICB1bmxlc3MgdHlwZSBpcyAna2V5d29yZCdcbiAgICAgIEBnZXRFbGVtZW50cyh0eXBlKS5hZGRDbGFzcyBcIm1vemJhci1oaWdobGlnaHQtI3t0eXBlfS0jcmFuZG9tLWtleVwiXG5cbiAgQHVuaGlnaGxpZ2h0OiAodHlwZSkgLT5cbiAgICBpZiB0eXBlIGlzICdrZXl3b3JkJ1xuICAgICAgQHVuaGlnaGxpZ2h0S2V5d29yZCgpXG4gICAgZWxzZVxuICAgICAgQGdldEVsZW1lbnRzKHR5cGUpLnJlbW92ZUNsYXNzIFwibW96YmFyLWhpZ2hsaWdodC0je3R5cGV9LSNyYW5kb20ta2V5XCJcblxuICBAZ2V0RWxlbWVudHM6ICh0eXBlKSAtPlxuICAgIGxpbmtzID0gW11cblxuICAgIHN3aXRjaCB0eXBlXG4gICAgICB3aGVuICdmb2xsb3dlZCdcbiAgICAgICAgbGlua3MgPSBpZiBAaGFzTWV0YU5vRm9sbG93KCkgdGhlbiAkKCkgZWxzZSAoJCAnYTpub3QoW3JlbCo9Zm9sbG93XSknKVxuXG4gICAgICB3aGVuICduby1mb2xsb3dlZCdcbiAgICAgICAgbGlua3MgPSBpZiBAaGFzTWV0YU5vRm9sbG93KCkgdGhlbiAoJCAnYScpIGVsc2UgKCQgJ2FbcmVsKj1ub2ZvbGxvd10nKVxuXG4gICAgICB3aGVuICdleHRlcm5hbCdcbiAgICAgICAgbGlua3MgPSAoJCAnYVtocmVmXj1cImh0dHBcIl0nKS5ub3QgXCJhW2hyZWYqPScje2RvY3VtZW50LmxvY2F0aW9uLmhvc3R9J11cIlxuXG4gICAgICB3aGVuICdpbnRlcm5hbCdcbiAgICAgICAgbGlua3MgPSAoJCBcImFbaHJlZio9JyN7ZG9jdW1lbnQubG9jYXRpb24uaG9zdH0nXVwiKVxuICAgICAgICAgIC5hZGQgJ2E6bm90KFtocmVmXj1cImh0dHBcIl0pJ1xuXG4gICAgcmV0dXJuIGxpbmtzXG5cblxuICBAaGFzTWV0YU5vRm9sbG93OiAtPlxuICAgICMgY2FuJ3QgdXNlIGEgYmFzaWMgc2VsZWN0b3IgYXMgaXQnZCBiZSBjYXNlIHNlbnNpdGl2ZS4uXG4gICAgbWV0YSA9ICgkICdtZXRhW25hbWVdJykuZmlsdGVyIC0+XG4gICAgICByZXR1cm4gdGhpcy5uYW1lLnRvTG93ZXJDYXNlKCkgaXMgJ3JvYm90cycgYW5kXG4gICAgICAgIHRoaXMuY29udGVudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ25vZm9sbG93JykgPiAtMVxuXG4gICAgbWV0YS5sZW5ndGggPiAwXG5cbiAgQGhpZ2hsaWdodEtleXdvcmQ6IChrZXl3b3JkKSAtPlxuICAgIEB1bmhpZ2hsaWdodEtleXdvcmQoKVxuXG4gICAgKCQgJ2JvZHknKS5oaWdobGlnaHQga2V5d29yZCwgQGhpZ2hsaWdodE9wdHNcbiAgICAjIG1ha2Ugc3VyZSBub3RoaW5nIGluIHRoZSBtb3piYXIgaXMgaGlnaGxpZ2h0ZWRcbiAgICAoJCAnI21vemJhci0jcmFuZG9tLWtleScpLnVuaGlnaGxpZ2h0IEBoaWdobGlnaHRPcHRzXG5cbiAgQHVuaGlnaGxpZ2h0S2V5d29yZDogLT5cbiAgICAoJCAnYm9keScpLnVuaGlnaGxpZ2h0IEBoaWdobGlnaHRPcHRzXG4iLCJ7Vmlld30gPSByZXF1aXJlICdiYWNrYm9uZSdcbkJhc2VQYW5lbFRhYiA9IHJlcXVpcmUgJ3ZpZXdzL2Jhc2VfcGFuZWxfdGFiJ1xudGVtcGxhdGUgPSByZXF1aXJlICd0ZW1wbGF0ZXMvaHR0cF9zdGF0dXNfdGFiJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEh0dHBTdGF0dXMgZXh0ZW5kcyBCYXNlUGFuZWxUYWJcbiAgdGVtcGxhdGU6IHRlbXBsYXRlXG4iLCJCYXNlUGFuZWxUYWIgPSByZXF1aXJlICd2aWV3cy9iYXNlX3BhbmVsX3RhYidcbnRlbXBsYXRlID0gcmVxdWlyZSAndGVtcGxhdGVzL2luYm91bmRfbGlua3MnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgSW5ib3VuZExpbmtzIGV4dGVuZHMgQmFzZVBhbmVsVGFiXG4gIGNsYXNzTmFtZTogJ2luYm91bmQtbGlua3MnXG4gIHRlbXBsYXRlOiB0ZW1wbGF0ZVxuIiwiJCA9IHJlcXVpcmUgJ2pxdWVyeSdcbkFuYWx5dGljcyA9IHJlcXVpcmUgJ21vZGVscy9hbmFseXRpY3MnXG5Ccm93c2VyID0gcmVxdWlyZSAnbW9kZWxzL2Jyb3dzZXInXG5QYW5lbFZpZXcgPSByZXF1aXJlICd2aWV3cy9wYW5lbF92aWV3J1xuUGFnZUF0dHJpYnV0ZXMgPSByZXF1aXJlICd2aWV3cy9wYWdlX2F0dHJpYnV0ZXMnXG5QYWdlRWxlbWVudHMgPSByZXF1aXJlICd2aWV3cy9wYWdlX2VsZW1lbnRzJ1xuSHR0cFN0YXR1cyA9IHJlcXVpcmUgJ3ZpZXdzL2h0dHBfc3RhdHVzJ1xuSHR0cFN0YXR1c0xpc3QgPSByZXF1aXJlICdtb2RlbHMvaHR0cF9zdGF0dXNfbGlzdCdcbkluYm91bmRMaW5rcyA9IHJlcXVpcmUgJ3ZpZXdzL2luYm91bmRfbGlua3MnXG5TZW1hbnRpY3MgPSByZXF1aXJlICd2aWV3cy9zZW1hbnRpY3MnXG5QYWdlRWxlbWVudHNNb2RlbCA9IHJlcXVpcmUgJ21vZGVscy9wYWdlX2VsZW1lbnRzJ1xuUGFnZUF0dHJpYnV0ZXNNb2RlbCA9IHJlcXVpcmUgJ21vZGVscy9wYWdlX2F0dHJpYnV0ZXMnXG5VcmxNZXRyaWNzID0gcmVxdWlyZSAnbW9kZWxzL3VybF9tZXRyaWNzJ1xuU2VtYW50aWNzTW9kZWwgPSByZXF1aXJlICdtb2RlbHMvc2VtYW50aWNzJ1xudGVtcGxhdGUgPSByZXF1aXJlICd0ZW1wbGF0ZXMvaW5mb19wYW5lbCdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBJbmZvUGFuZWwgZXh0ZW5kcyBQYW5lbFZpZXdcbiAgUEFORUxfSEVJR0hUOiAzNTBcbiAgIyBib3R0b20gbWFyZ2luIHdoZW4gZXhwYW5kaW5nIHRoZSBwYW5lbCAnZnVsbCBzY3JlZW4nXG4gIEVYUEFOREVEX1BBTkVMX01BUkdJTjogNTBcblxuICBjbGFzc05hbWU6ICdpbmZvLXBhbmVsJ1xuICBhbmFseXRpY3M6IEFuYWx5dGljcy5nZXRJbnN0YW5jZSgpXG5cbiAgaXNGdWxsU2NyZWVuOiBmYWxzZVxuICBzZWxlY3RlZFRhYjogJ3BhZ2UtZWxlbWVudHMnXG4gIHRhYnM6IHt9XG4gIHRhYmxlSGVpZ2h0OiAwXG5cbiAgZXZlbnRzOlxuICAgICdjbGljayAudGFicyBsaSc6ICd0YWJDbGlja2VkJ1xuICAgICdjbGljayAuZXhwYW5kJzogJ3RvZ2dsZUZ1bGxTY3JlZW4nXG4gICAgJ21vdXNlZG93biAuZ3V0dGVyJzogJ3N0YXJ0RHJhZydcblxuICBpbml0aWFsaXplOiAob3B0aW9ucykgLT5cbiAgICBzdXBlclxuXG4gICAgQHRhYnMgPVxuICAgICAgJ3BhZ2UtZWxlbWVudHMnOiBuZXcgUGFnZUVsZW1lbnRzXG4gICAgICAgIG1vZGVsOiBuZXcgUGFnZUVsZW1lbnRzTW9kZWxcbiAgICAgICdnZW5lcmFsLWF0dHJpYnV0ZXMnOiBuZXcgUGFnZUF0dHJpYnV0ZXNcbiAgICAgICAgbW9kZWw6IG5ldyBQYWdlQXR0cmlidXRlc01vZGVsXG4gICAgICAnaW5ib3VuZC1saW5rcyc6IG5ldyBJbmJvdW5kTGlua3NcbiAgICAgICAgbW9kZWw6IFVybE1ldHJpY3MuZ2V0SW5zdGFuY2UoKVxuICAgICAgJ3NlbWFudGljcyc6IG5ldyBTZW1hbnRpY3NcbiAgICAgICAgbW9kZWw6IG5ldyBTZW1hbnRpY3NNb2RlbFxuICAgICAgJ2h0dHAtc3RhdHVzJzogbmV3IEh0dHBTdGF0dXNcbiAgICAgICAgbW9kZWw6IG5ldyBIdHRwU3RhdHVzTGlzdFxuXG4gICAgQGxpc3RlblRvIEBtb2RlbCwgJ2NoYW5nZScsIEByZW5kZXJcbiAgICBAbGlzdGVuVG8odGFiLm1vZGVsLCAnY2hhbmdlIHN5bmMnLCBAcmVuZGVyKSBmb3IgaywgdGFiIG9mIEB0YWJzXG5cbiAgdGFiQ2xpY2tlZDogKGV2ZW50KSAtPlxuICAgIEBzZWxlY3RlZFRhYiA9ICgkIGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEgJ3RhYidcblxuICAgIEB0cmFja1BhbmVsVmlldygpXG4gICAgQHJlbmRlcigpXG5cbiAgdHJhY2tQYW5lbFZpZXc6IC0+XG4gICAgQGFuYWx5dGljcy50cmFja1BhbmVsVmlldyBAc2VsZWN0ZWRUYWJcblxuICByZW5kZXI6IC0+XG4gICAgcmV0dXJuIHVubGVzcyBAaXNPcGVuXG4gICAgQG1vZGVsLmZldGNoKCkgdW5sZXNzIEBtb2RlbC5pc1ZhbGlkKClcblxuICAgIEAkZWwuaHRtbCB0ZW1wbGF0ZSBAbW9kZWwuYXQoMCk/LnRvSlNPTigpXG4gICAgQCRlbC5maW5kKFwiLnRhYnMgbGlbZGF0YS10YWI9I3tAc2VsZWN0ZWRUYWJ9XVwiKS5hZGRDbGFzcyAnYWN0aXZlJ1xuXG4gICAgIyBDdXJyZW50bHkgaHR0cC1zdGF0dXMgaXNuJ3Qgc3VwcG9ydGVkIGluIGZpcmVmb3guLlxuICAgIGlmIEJyb3dzZXIuYnJvd3Nlck5hbWUoKSBpcyAnZmlyZWZveCdcbiAgICAgIEAkZWwuZmluZCgnbGlbZGF0YS10YWI9XCJodHRwLXN0YXR1c1wiXScpLmhpZGUoKVxuXG4gICAgQHRhYnNbQHNlbGVjdGVkVGFiXS5zZXRFbGVtZW50IEAkZWwuZmluZCAnLnRhYidcbiAgICBAdGFic1tAc2VsZWN0ZWRUYWJdLnJlbmRlcigpXG5cbiAgICBAdGFibGVIZWlnaHQgPSBAdGFic1tAc2VsZWN0ZWRUYWJdPy5nZXRUYWJsZUhlaWdodCgpIHVubGVzcyBAdGFibGVIZWlnaHRcbiAgICBAdGFic1tAc2VsZWN0ZWRUYWJdLnNldFRhYmxlSGVpZ2h0IEB0YWJsZUhlaWdodFxuXG4gICAgQCRlbC5maW5kKCcuc2Nyb2xsYWJsZScpLnBlcmZlY3RTY3JvbGxiYXIoKVxuXG4gIG9wZW46IChjb21wbGV0ZSkgLT5cbiAgICBzdXBlclxuICAgIEByZW5kZXIoKVxuXG4gIHRvZ2dsZUZ1bGxTY3JlZW46IC0+XG4gICAgQGlzRnVsbFNjcmVlbiA9ICFAaXNGdWxsU2NyZWVuXG5cbiAgICBuZXdIZWlnaHQgPSBpZiBAaXNGdWxsU2NyZWVuXG4gICAgICAoJCB3aW5kb3cpLmlubmVySGVpZ2h0KCkgLSBARVhQQU5ERURfUEFORUxfTUFSR0lOXG4gICAgZWxzZVxuICAgICAgQFBBTkVMX0hFSUdIVFxuXG4gICAgY2hhbmdlID0gKEAkZWwuaGVpZ2h0KCkgLSBuZXdIZWlnaHQpLnRvU3RyaW5nKClcblxuICAgICMgdHJhbnNsYXRlICcyMDAnIHRvICctPTIwMCcsIGFuZCAnLTIwMCcgdG8gJys9MjAwJ1xuICAgIGNoYW5nZSA9IGNoYW5nZS5yZXBsYWNlKC8tLywgJys9JykucmVwbGFjZSAvXlxcZC8sICctPSQmJ1xuXG4gICAgJHRib2R5ID0gQCRlbC5maW5kKCd0YWJsZSB0Ym9keScpXG4gICAgJHRib2R5LmFuaW1hdGVcbiAgICAgIGhlaWdodDogY2hhbmdlLFxuICAgICAgQGhvc3QuUEFORUxfU1dJTkdfRFVSQVRJT04sXG4gICAgICAnc3dpbmcnLFxuICAgICAgPT5cbiAgICAgICAgQHRhYnNbQHNlbGVjdGVkVGFiXS5zZXRUYWJsZUhlaWdodCAkdGJvZHkuaGVpZ2h0KClcblxuICAgIEB1cGRhdGVQYW5lbEhlaWdodCBuZXdIZWlnaHRcblxuICBzdGFydERyYWc6IChlKSAtPlxuICAgIHN0YXJ0aW5nSGVpZ2h0ID0gQCRlbC5oZWlnaHQoKVxuICAgIHN0YXJ0aW5nVGFibGVIZWlnaHQgPSBAdGFic1tAc2VsZWN0ZWRUYWJdLmdldFRhYmxlSGVpZ2h0KClcblxuICAgIHN0YXJ0aW5nWSA9IGUucGFnZVlcblxuICAgICRkb2N1bWVudHMgPSAoJCBkb2N1bWVudCkuYWRkICgkICcjbW96YmFyLXdHQTdNaFJoUTNXUycpLmNvbnRlbnRzKClcblxuICAgICRkb2N1bWVudHMub24gJ21vdXNlbW92ZScsIChlKSA9PlxuICAgICAgZGVsdGEgPSBlLnBhZ2VZIC0gc3RhcnRpbmdZXG5cbiAgICAgIEAkZWwuaGVpZ2h0IHN0YXJ0aW5nSGVpZ2h0ICsgZGVsdGFcbiAgICAgIEB0YWJzW0BzZWxlY3RlZFRhYl0uc2V0VGFibGVIZWlnaHQgc3RhcnRpbmdUYWJsZUhlaWdodCArIGRlbHRhXG4gICAgICBAaG9zdC5zZXRQYW5lbEhlaWdodCBzdGFydGluZ0hlaWdodCArIGRlbHRhXG5cbiAgICAgICRkb2N1bWVudHMub24gJ21vdXNldXAnLCAoZSkgLT5cbiAgICAgICAgJGRvY3VtZW50cy5vZmYgJ21vdXNlbW92ZSdcbiIsIiQgPSByZXF1aXJlICdqcXVlcnknXG5BbmFseXRpY3MgPSByZXF1aXJlICdtb2RlbHMvYW5hbHl0aWNzJ1xuRGlzcGF0Y2hlciA9IHJlcXVpcmUgJ3ZpZXdzL2V2ZW50X2Rpc3BhdGNoZXInXG5CYXNlVmlldyA9IHJlcXVpcmUgJ3ZpZXdzL2Jhc2VfdmlldydcbnRlbXBsYXRlID0gcmVxdWlyZSAndGVtcGxhdGVzL2tleXdvcmRfZGlmZmljdWx0eSdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBLZXl3b3JkRGlmZmljdWx0eSBleHRlbmRzIEJhc2VWaWV3XG4gIGFuYWx5dGljczogQW5hbHl0aWNzLmdldEluc3RhbmNlKClcblxuICBldmVudHM6XG4gICAgJ2NsaWNrIC5hY3RpdmF0ZS1rZXl3b3JkLWRpZmZpY3VsdHknOiAnc2hvd0RpZmZpY3VsdHknXG5cbiAgaW5pdGlhbGl6ZTogKG9wdGlvbnMpIC0+XG4gICAgc3VwZXJcbiAgICBAbGlzdGVuVG8gQG1vZGVsLCAnY2hhbmdlJywgQHJlbmRlclxuICAgICgkIHdpbmRvdykub24gJ2hhc2hjaGFuZ2UnLCA9PiBAbW9kZWwucmVzZXQoKVxuXG4gIHJlbmRlcjogLT5cbiAgICBAJGVsLmh0bWwgdGVtcGxhdGUgQG1vZGVsLnRvSlNPTigpXG4gICAgQCRlbC5maW5kKCcubG9nZ2VkLW91dCcpLmNsaWNrID0+XG4gICAgICBAYW5hbHl0aWNzLnRyYWNrRXZlbnQgJ0tXRC9UcmlhbCBDVEEgQ2xpY2tlZCdcblxuICAgIHN1cGVyXG5cbiAgc2hvd0RpZmZpY3VsdHk6IC0+XG4gICAgQGhpZGVUb29sdGlwKClcbiAgICBAbW9kZWwuZmV0Y2goKVxuICAgIEBhbmFseXRpY3MudHJhY2tLZXl3b3JkRGlmZmljdWx0eSgpXG4iLCIkID0gcmVxdWlyZSAnanF1ZXJ5J1xuQmFzZUVsZW1lbnQgPSByZXF1aXJlICd2aWV3cy9iYXNlX2VsZW1lbnQnXG50ZW1wbGF0ZSA9IHJlcXVpcmUgJ3RlbXBsYXRlcy9rZXl3b3JkX2RpZmZpY3VsdHknXG5LZXl3b3JkRGlmZmljdWx0eSA9IHJlcXVpcmUgJ3ZpZXdzL2tleXdvcmRfZGlmZmljdWx0eSdcbktleXdvcmREaWZmaWN1bHR5TW9kZWwgPSByZXF1aXJlICdtb2RlbHMva2V5d29yZF9kaWZmaWN1bHR5J1xuUGFnZSA9IHJlcXVpcmUgJ21vZGVscy9wYWdlJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEtleXdvcmREaWZmaWN1bHR5RWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50XG4gIGlkOiAnbW96YmFyLWtleXdvcmQtZGlmZmljdWx0eS0jcmFuZG9tLWtleSdcblxuICBlbGVtZW50VGVtcGxhdGU6IHRlbXBsYXRlXG4gIGVsZW1lbnRDc3NDbGFzczogJ2tleXdvcmQtZGlmZmljdWx0eSdcbiAgZWxlbWVudFZpZXdDbGFzczogS2V5d29yZERpZmZpY3VsdHlcbiAgZWxlbWVudFZpZXdNb2RlbDogbmV3IEtleXdvcmREaWZmaWN1bHR5TW9kZWxcblxuICBwYXJlbnRFbGVtZW50OiAtPlxuICAgICgkIFBhZ2UuZ2V0U2VycENvbmZpZygpLnNlYXJjaEJveClcblxuICBhZGRUb0RPTTogLT5cbiAgICBAcGFyZW50RWxlbWVudCgpLmNzc1xuICAgICAgd2lkdGg6IDE5MFxuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcblxuICAgIEAkZWwuYXBwZW5kVG8gQHBhcmVudEVsZW1lbnQoKVxuIiwiXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG4kID0gcmVxdWlyZSAnanF1ZXJ5J1xuQW5hbHl0aWNzID0gcmVxdWlyZSAnbW9kZWxzL2FuYWx5dGljcydcblBhbmVsVmlldyA9IHJlcXVpcmUgJ3ZpZXdzL3BhbmVsX3ZpZXcnXG5saW5rc1BhbmVsID0gcmVxdWlyZSAndGVtcGxhdGVzL2xpbmtzX3BhbmVsJ1xuRGlzcGF0Y2hlciA9IHJlcXVpcmUgJ3ZpZXdzL2V2ZW50X2Rpc3BhdGNoZXInXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgTGlua3NQYW5lbCBleHRlbmRzIFBhbmVsVmlld1xuICBQQU5FTF9IRUlHSFQ6IDUwXG5cbiAgYW5hbHl0aWNzOiBBbmFseXRpY3MuZ2V0SW5zdGFuY2UoKVxuICBkaXNwYXRjaGVyOiBEaXNwYXRjaGVyLmdldEluc3RhbmNlKClcblxuICBpc09wZW46IGZhbHNlXG4gIGVsOiBsaW5rc1BhbmVsKClcblxuICBldmVudHM6XG4gICAgJ2NsaWNrIC5saW5rLXR5cGUnOiAndG9nZ2xlSGlnaGxpZ2h0J1xuICAgICdrZXl1cCAuc2VhcmNoIGlucHV0JzogJ2hpZ2hsaWdodEtleXdvcmQnXG5cbiAgaW5pdGlhbGl6ZTogKG9wdGlvbnMpIC0+XG4gICAgc3VwZXJcbiAgICBAbGlzdGVuVG8gQG1vZGVsLCAnY2hhbmdlJywgQHVwZGF0ZUZyb21UYWJTZXR0aW5nc1xuXG4gIHVwZGF0ZUZyb21UYWJTZXR0aW5nczogLT5cbiAgICBsaW5rcyA9IEBtb2RlbC5nZXQoJ2hpZ2hsaWdodExpbmtzJykgb3IgW11cbiAgICBAdG9nZ2xlU3RhdGUodHlwZSwgdHJ1ZSkgZm9yIHR5cGUgaW4gbGlua3NcblxuICAgICRrZXl3b3JkRWwgPSBAJGVsLmZpbmQgJy5zZWFyY2ggaW5wdXQnXG4gICAga2V5d29yZCA9IEBtb2RlbC5nZXQgJ2hpZ2hsaWdodEtleXdvcmQnXG5cbiAgICBpZiAka2V5d29yZEVsLnZhbCgpIGlzICcnIGFuZCBrZXl3b3JkIGlzbnQgJydcbiAgICAgICRrZXl3b3JkRWwudmFsIGtleXdvcmRcbiAgICAgIEBoaWdobGlnaHRLZXl3b3JkKCkgaWYgbGlua3MuaW5kZXhPZigna2V5d29yZCcpID4gLTFcblxuICB0b2dnbGVIaWdobGlnaHQ6IChlKSAtPlxuICAgICR0YXJnZXQgPSAoJCBlLmN1cnJlbnRUYXJnZXQpXG5cbiAgICB0eXBlID0gJHRhcmdldC5kYXRhICd0eXBlJ1xuICAgIGlzT24gPSAhJHRhcmdldC5oYXNDbGFzcyAnYWN0aXZlJ1xuXG4gICAgQHRvZ2dsZVN0YXRlIHR5cGUsIGlzT25cbiAgICBAbW9kZWwudG9nZ2xlSGlnaGxpZ2h0TGluayB0eXBlLCBpc09uXG4gICAgQG1vZGVsLnNhdmUoKVxuXG4gICAgaWYgaXNPbiBhbmQgdHlwZSBpcyAna2V5d29yZCdcbiAgICAgICRpbnB1dCA9IEAkZWwuZmluZCAnLnNlYXJjaCBpbnB1dCdcbiAgICAgICRpbnB1dC5mb2N1cygpIGlmICRpbnB1dC52YWwoKSBpcyAnJ1xuXG4gICAgICBAaGlnaGxpZ2h0S2V5d29yZCgpXG5cbiAgdG9nZ2xlU3RhdGU6ICh0eXBlLCBpc09uKSAtPlxuICAgIEAkZWwuZmluZChcIi5saW5rLXR5cGUuI3t0eXBlfVwiKS50b2dnbGVDbGFzcyAnYWN0aXZlJywgaXNPblxuICAgIEBkaXNwYXRjaGVyLnRyaWdnZXIgJ2hpZ2hsaWdodC1saW5rczpjaGFuZ2UnLCB0eXBlLCBpc09uXG5cbiAgaGlnaGxpZ2h0S2V5d29yZDogLT5cbiAgICAjIHR1cm4gb24gdGhlIGhpZ2hsaWdodCBidXR0b24sIGlmIGl0J3Mgbm90IGFscmVhZHkgYWN0aXZlXG4gICAgaXNPbiA9IEAkZWwuZmluZCgnLmxpbmstdHlwZS5rZXl3b3JkJykuaGFzQ2xhc3MgJ2FjdGl2ZSdcbiAgICBAdG9nZ2xlU3RhdGUgJ2tleXdvcmQnLCB0cnVlIHVubGVzcyBpc09uXG5cbiAgICBrZXl3b3JkID0gQCRlbC5maW5kKCcuc2VhcmNoIGlucHV0JykudmFsKClcbiAgICBAZGlzcGF0Y2hlci50cmlnZ2VyICdoaWdobGlnaHQta2V5d29yZDpjaGFuZ2UnLCBrZXl3b3JkXG5cbiAgICBAbW9kZWwudG9nZ2xlSGlnaGxpZ2h0TGluayAna2V5d29yZCcsIGlzT25cbiAgICBAbW9kZWwuc2V0ICdoaWdobGlnaHRLZXl3b3JkJywga2V5d29yZFxuICAgIEBtb2RlbC5zYXZlKClcblxuICB0cmFja1BhbmVsVmlldzogLT5cbiAgICBAYW5hbHl0aWNzLnRyYWNrUGFuZWxWaWV3ICdsaW5rcy1wYW5lbCdcblxuICBnZXRMaW5rVHlwZXM6IC0+XG4gICAgQCRlbC5maW5kKCcubGluay10eXBlJykubWFwIC0+ICgkIHRoaXMpLmF0dHIgJ2RhdGEtdHlwZSdcbiIsIiQgPSByZXF1aXJlICdqcXVlcnknXG5CYXNlRWxlbWVudCA9IHJlcXVpcmUgJ3ZpZXdzL2Jhc2VfZWxlbWVudCdcblByb2ZpbGVzRHJvcERvd24gPSByZXF1aXJlICd2aWV3cy9wcm9maWxlc19kcm9wX2Rvd24nXG5TZXR0aW5nc0RpYWxvZyA9IHJlcXVpcmUgJ3ZpZXdzL3NldHRpbmdzX2RpYWxvZydcbkhlbHBEaWFsb2cgPSByZXF1aXJlICd2aWV3cy9oZWxwX2RpYWxvZydcblRvb2xiYXIgPSByZXF1aXJlICd2aWV3cy90b29sYmFyJ1xudG9vbGJhclRlbXBsYXRlID0gcmVxdWlyZSAndGVtcGxhdGVzL3Rvb2xiYXInXG5Vc2VyID0gcmVxdWlyZSAnbW9kZWxzL3VzZXInXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgTW96YmFyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50XG4gIFRPT0xCQVJfSEVJR0hUOiA0M1xuXG4gICMgVGltZSBpdCB0YWtlcyBmb3IgYSBwYW5lbCB0byBleHBhbmQvY29udHJhY3RcbiAgUEFORUxfU1dJTkdfRFVSQVRJT046IDMwMFxuXG4gIGVsZW1lbnRWaWV3Q2xhc3M6IFRvb2xiYXJcbiAgZWxlbWVudFRlbXBsYXRlOiB0b29sYmFyVGVtcGxhdGVcblxuICBwcm9maWxlc0Ryb3BEb3duOiBudWxsXG4gIHByb2ZpbGVzRGlhbG9nOiBudWxsXG4gIHNldHRpbmdzRGlhbG9nOiBudWxsXG4gIGhlbHBEaWFsb2c6IG51bGxcbiAgdXNlcjogbnVsbFxuXG4gICMgbGlzdCBvZiBwYWdlIGVsZW1lbnRzIHdpdGggcG9zaXRpb246Zml4ZWQgYW5kIHRvcDowXG4gIHRvcEVsZW1lbnRzOiBudWxsXG5cbiAgaW5pdGlhbGl6ZTogLT5cbiAgICBzdXBlclxuICAgIEBzZXR0aW5ncy5vbiAnY2hhbmdlOmlzRG9ja2VkT25Cb3R0b20nLCA9PiBAdG9nZ2xlRG9ja1Bvc2l0aW9uKClcbiAgICBAdXNlciA9IFVzZXIuZ2V0SW5zdGFuY2UoKVxuICAgIEBsaXN0ZW5UbyBAdXNlciwgJ2NoYW5nZTppc1BybycsIEByZW5kZXJcblxuICByZW5kZXI6IC0+XG4gICAgc3VwZXJcbiAgICBpc0RvY2tlZE9uQm90dG9tID0gQHNldHRpbmdzLmdldCAnaXNEb2NrZWRPbkJvdHRvbSdcbiAgICBAJGVsLnRvZ2dsZUNsYXNzICdib3R0b20nLCBpc0RvY2tlZE9uQm90dG9tXG5cbiAgICB1bmxlc3MgaXNEb2NrZWRPbkJvdHRvbVxuICAgICAgKCQgJ2JvZHknKS5hZGRDbGFzcyAnbW96YmFyLW1hcmdpbi0jcmFuZG9tLWtleSdcblxuICAgICAgIyB0aGlzIGlzIGV4cGVuc2l2ZSB0aGUgZmlyc3QgdGltZSwgc28gZG8gaXRcbiAgICAgICMgYWZ0ZXIgd2UndmUgZmluaXNoZWQgcmVuZGVyaW5nXG4gICAgICBzZXRUaW1lb3V0ID0+XG4gICAgICAgIEB1cGRhdGVGaXhlZFRvcCBAVE9PTEJBUl9IRUlHSFRcbiAgICAgICwgMjBcblxuICB0ZW1wbGF0ZU9wdGlvbnM6IC0+XG4gICAgdXNlcjogVXNlci5nZXRJbnN0YW5jZSgpXG5cbiAgc2V0RWxlbWVudFJvb3Q6IC0+XG4gICAgc3VwZXJcbiAgICBAdXBkYXRlUGFuZWxPcmRlcigpXG5cbiAgdXBkYXRlRml4ZWRUb3A6IChoZWlnaHQpIC0+XG4gICAgQHRvcEVsZW1lbnRzID89ICgkICdib2R5IConKS5maWx0ZXIgLT5cbiAgICAgIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgQFxuXG4gICAgICBzdHlsZS5wb3NpdGlvbiBpcyAnZml4ZWQnIGFuZFxuICAgICAgc3R5bGUudG9wIGlzICcwcHgnIGFuZFxuICAgICAgbm90IC9ebW96YmFyLy50ZXN0IEAuaWRcblxuICAgICMgY2FuJ3QgdXNlIEB0b3BFbGVtZW50cy5jc3MoKSBhcyBpdCBkb2Vzbid0IHN1cHBvcnQgIWltcG9ydGFudFxuICAgIEB0b3BFbGVtZW50cy5lYWNoIC0+XG4gICAgICBALnN0eWxlLnNldFByb3BlcnR5ICd0b3AnLCBcIiN7aGVpZ2h0fXB4XCIsICdpbXBvcnRhbnQnXG5cbiAgdXBkYXRlUGFuZWxIZWlnaHQ6IChwYW5lbEhlaWdodCwgY29tcGxldGUpIC0+XG4gICAgbmV3SGVpZ2h0ID0gQGNhbGN1bGF0ZU1vYmFySGVpZ2h0IHBhbmVsSGVpZ2h0XG5cbiAgICAjIGlmIHdlJ3JlIGFscmVhZHkgYXQgdGhlIGNvcnJlY3QgaGVpZ2h0LCBieXBhc3MgdGhlIGFuaW1hdGlvbnNcbiAgICAjIHNvIHRoZSBjYWxsYmFjayBnZXRzIGV4ZWN1dGVkIGltbWVkaWF0ZWx5LlxuICAgIGlmIEAkZWwuaGVpZ2h0KCkgPT0gbmV3SGVpZ2h0XG4gICAgICBjb21wbGV0ZT8uYXBwbHkgQGVsXG4gICAgICByZXR1cm5cblxuICAgICgkICcubW96YmFyLW1hcmdpbi0jcmFuZG9tLWtleScpLmFuaW1hdGVcbiAgICAgICdtYXJnaW4tdG9wJzogbmV3SGVpZ2h0XG4gICAgICAsIEBQQU5FTF9TV0lOR19EVVJBVElPTlxuXG4gICAgQCRlbC5hbmltYXRlIGhlaWdodDogbmV3SGVpZ2h0LCBAUEFORUxfU1dJTkdfRFVSQVRJT04sICdzd2luZycsIGNvbXBsZXRlXG5cbiAgc2V0UGFuZWxIZWlnaHQ6IChwYW5lbEhlaWdodCkgLT5cbiAgICAjIHNldCB0aGUgcGFuZWwgaGVpZ2h0IHdpdGhvdXQgYW5pbWF0aW9uc1xuICAgIG5ld0hlaWdodCA9IEBjYWxjdWxhdGVNb2JhckhlaWdodCBwYW5lbEhlaWdodFxuICAgICgkICcubW96YmFyLW1hcmdpbi0jcmFuZG9tLWtleScpLmNzcyAnbWFyZ2luLXRvcCc6IG5ld0hlaWdodFxuICAgIEAkZWwuaGVpZ2h0IG5ld0hlaWdodFxuXG4gIGNhbGN1bGF0ZU1vYmFySGVpZ2h0OiAocGFuZWxIZWlnaHQpIC0+XG4gICAgcGFuZWxIZWlnaHQgKyBAZWxlbWVudFZpZXcudG9vbGJhckhlaWdodCgpXG5cbiAgdG9nZ2xlUHJvZmlsZXNEcm9wRG93bjogKG9wdGlvbnMpIC0+XG4gICAgaWYgQHByb2ZpbGVzRHJvcERvd24/LmlzSW5ET00oKVxuICAgICAgQHByb2ZpbGVzRHJvcERvd24ucmVtb3ZlKClcbiAgICAgIEBwcm9maWxlc0Ryb3BEb3duID0gbnVsbFxuICAgICAgcmV0dXJuXG5cbiAgICBAcHJvZmlsZXNEcm9wRG93biA9IG5ldyBQcm9maWxlc0Ryb3BEb3duIG9wdGlvbnNcbiAgICBAcHJvZmlsZXNEcm9wRG93bi5yZW5kZXIoKVxuXG4gIHRvZ2dsZVNldHRpbmdzRGlhbG9nOiAob3B0aW9ucykgLT5cbiAgICBpZiBAc2V0dGluZ3NEaWFsb2c/LmlzSW5ET00oKVxuICAgICAgQHNldHRpbmdzRGlhbG9nLnJlbW92ZSgpXG4gICAgICBAc2V0dGluZ3NEaWFsb2cgPSBudWxsXG4gICAgICByZXR1cm5cblxuICAgIEBzZXR0aW5nc0RpYWxvZyA9IG5ldyBTZXR0aW5nc0RpYWxvZyBvcHRpb25zXG4gICAgQHNldHRpbmdzRGlhbG9nLnJlbmRlcigpXG5cbiAgdG9nZ2xlSGVscERpYWxvZzogKG9wdGlvbnMpIC0+XG4gICAgaWYgQGhlbHBEaWFsb2c/LmlzSW5ET00oKVxuICAgICAgQGhlbHBEaWFsb2cucmVtb3ZlKClcbiAgICAgIEBoZWxwRGlhbG9nID0gbnVsbFxuICAgICAgcmV0dXJuXG5cbiAgICBAaGVscERpYWxvZyA9IG5ldyBIZWxwRGlhbG9nIG9wdGlvbnNcbiAgICBAaGVscERpYWxvZy5yZW5kZXIoKVxuXG4gIHRvZ2dsZURvY2tQb3NpdGlvbjogLT5cbiAgICBpc0RvY2tlZE9uQm90dG9tID0gQHNldHRpbmdzLmdldCAnaXNEb2NrZWRPbkJvdHRvbSdcbiAgICBpZiBpc0RvY2tlZE9uQm90dG9tXG4gICAgICB0b3AgPSAoJCB3aW5kb3cpLmhlaWdodCgpIC0gQFRPT0xCQVJfSEVJR0hUXG4gICAgICBtYXJnaW4gPSAwXG4gICAgZWxzZVxuICAgICAgdG9wID0gMFxuICAgICAgbWFyZ2luID0gQFRPT0xCQVJfSEVJR0hUXG5cbiAgICBAZWxlbWVudFZpZXcuY2xvc2VBbGxQYW5lbHMgPT5cbiAgICAgIEAkZWxcbiAgICAgICAgLmNzcyh0b3A6IEAkZWwucG9zaXRpb24oKS50b3AsIGJvdHRvbTogJ2F1dG8nKVxuICAgICAgICAuYW5pbWF0ZSB0b3A6IHRvcCwgPT5cbiAgICAgICAgICBAJGVsLmNzcyh0b3A6ICcnLCBib3R0b206ICcnKS50b2dnbGVDbGFzcyAnYm90dG9tJywgaXNEb2NrZWRPbkJvdHRvbVxuXG4gICAgICAoJCAnYm9keScpLmFuaW1hdGUgJ21hcmdpbi10b3AnOiBtYXJnaW4sID0+XG4gICAgICAgICgkICdib2R5JylcbiAgICAgICAgICAuY3NzKCdtYXJnaW4tdG9wJywgJycpXG4gICAgICAgICAgLnRvZ2dsZUNsYXNzICdtb3piYXItbWFyZ2luLSNyYW5kb20ta2V5Jywgbm90IGlzRG9ja2VkT25Cb3R0b21cbiAgICAgICAgQHVwZGF0ZUZpeGVkVG9wIDBcblxuICAgICAgQHVwZGF0ZVBhbmVsT3JkZXIoKVxuXG4gICMgd2hlbiBkb2NrZWQgb24gYm90dG9tLCB0aGUgcGFuZWwgc2hvdWxkIGFwcGVhciBiZWZvcmUgdGhlIHRvb2xiYXJcbiAgIyBpbiB0aGUgRE9NXG4gIHVwZGF0ZVBhbmVsT3JkZXI6IC0+XG4gICAgaWYgQHNldHRpbmdzLmdldCAnaXNEb2NrZWRPbkJvdHRvbSdcbiAgICAgIEAkZWxlbWVudFJvb3QuZmluZCgnLnRvb2xiYXInKS5iZWZvcmUgQCRlbGVtZW50Um9vdC5maW5kKCcucGFuZWwnKVxuICAgIGVsc2VcbiAgICAgIEAkZWxlbWVudFJvb3QuZmluZCgnLnRvb2xiYXInKS5hZnRlciBAJGVsZW1lbnRSb290LmZpbmQoJy5wYW5lbCcpXG5cblxuICByZW1vdmU6IC0+XG4gICAgKCQgJ2JvZHknKS5yZW1vdmVDbGFzcygnbW96YmFyLW1hcmdpbi0jcmFuZG9tLWtleScpLmNzcyAnbWFyZ2luLXRvcCc6ICcnXG4gICAgQHVwZGF0ZUZpeGVkVG9wIDBcbiAgICBzdXBlclxuIiwiJCA9IHJlcXVpcmUgJ2pxdWVyeSdcbkJhc2VEaWFsb2cgPSByZXF1aXJlICd2aWV3cy9iYXNlX2RpYWxvZydcbk9uYm9yZGluZ1ZpZXcgPSByZXF1aXJlICd2aWV3cy9vbmJvYXJkaW5nX3ZpZXcnXG5PbmJvYXJkaW5nTW9kZWwgPSByZXF1aXJlICdtb2RlbHMvb25ib2FyZGluZydcblBhZ2UgPSByZXF1aXJlICdtb2RlbHMvcGFnZSdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBPbmJvYXJkaW5nRGlhbG9nIGV4dGVuZHMgQmFzZURpYWxvZ1xuICBlbGVtZW50Q3NzQ2xhc3M6ICdkaWFsb2cgb25ib2FyZGluZy1kaWFsb2cnXG4gIGVsZW1lbnRWaWV3Q2xhc3M6IE9uYm9yZGluZ1ZpZXdcblxuICBpZDogJ21vemJhci1vbmJvYXJkaW5nLWRpYWxvZy0jcmFuZG9tLWtleSdcblxuICBpbml0aWFsaXplOiAtPlxuICAgIHN1cGVyXG4gICAgQG1vZGVsID0gQGVsZW1lbnRWaWV3TW9kZWwgPSBPbmJvYXJkaW5nTW9kZWwuZ2V0SW5zdGFuY2UoKVxuICAgIEBtb2RlbC5vbiAnY2hhbmdlOnBhZ2VTdGVwIGNoYW5nZTpzZXJwU3RlcCcsID0+IEBvbmJvYXJkaW5nU3RlcENoYW5nZWQoKVxuICAgIEBtb2RlbC5mZXRjaCgpXG5cbiAgICBAcmVuZGVyKClcblxuICByZW5kZXI6IC0+XG4gICAgaWYgbm90IEBpc0luT25ib2FyZGluZygpIHRoZW4gcmV0dXJuIEByZW1vdmUoKVxuXG4gICAgc3VwZXJcbiAgICBAb25ib2FyZGluZ1N0ZXBDaGFuZ2VkKClcblxuICBpc0luT25ib2FyZGluZzogLT5cbiAgICBzZXR0aW5nID0gaWYgUGFnZS5pc1NlcnAoKSB0aGVuICdzZXJwU3RlcCcgZWxzZSAncGFnZVN0ZXAnXG4gICAgc3RlcCA9IEBtb2RlbC5nZXQgc2V0dGluZ1xuXG4gICAgc3RlcCBub3QgaW4gWydsZWdhY3ktdXNlcicsICdjbG9zZWQnLCAnY29tcGxldGUnXVxuXG4gIG9uYm9hcmRpbmdTdGVwQ2hhbmdlZDogLT5cbiAgICBzZXR0aW5nID0gaWYgUGFnZS5pc1NlcnAoKSB0aGVuICdzZXJwU3RlcCcgZWxzZSAncGFnZVN0ZXAnXG4gICAgc3RlcCA9IEBtb2RlbC5nZXQgc2V0dGluZ1xuXG4gICAgQCRlbC5jc3MgdG9wOiAnJywgcmlnaHQ6ICcnXG5cbiAgICBzd2l0Y2ggc3RlcFxuICAgICAgd2hlbiAncGFnZS1ob3RzcG90cy1pbnRybycsICdzZXJwLWhvdHNwb3RzLWludHJvJ1xuICAgICAgICBAc2hvdygpOyBAb3ZlcmxheS5zZXRPcGFjaXR5IDBcbiAgICAgIHdoZW4gJ3BhZ2UtaG90c3BvdHMnLCAnc2VycC1ob3RzcG90cydcbiAgICAgICAgQG92ZXJsYXkuJGVsLmhpZGUoKVxuICAgICAgICBAJGVsLmNzcyB0b3A6ICgkIHdpbmRvdykuaGVpZ2h0KCkgLSAxMDAsIHJpZ2h0OiAtODBcbiAgICAgIHdoZW4gJ2xlZ2FjeS11c2VyJywgJ2Nsb3NlZCcsICdjb21wbGV0ZSdcbiAgICAgICAgQHJlbW92ZSgpXG5cbiAgICAgIGVsc2VcbiAgICAgICAgQHNob3coKVxuXG4gIGhpZGU6IC0+XG4gICAgQCRlbC5oaWRlKClcbiAgICBAb3ZlcmxheS4kZWwuaGlkZSgpXG5cbiAgc2hvdzogLT5cbiAgICBpZiBub3QgQGlzSW5ET00oKSB0aGVuIHJldHVybiBAcmVuZGVyKClcbiAgICBAJGVsLmNzcyB0b3A6ICcnLCBsZWZ0OiAnJ1xuICAgIEAkZWwuc2hvdygpXG4gICAgQG92ZXJsYXkuJGVsLnNob3coKVxuXG4gIG92ZXJsYXlDbGlja2VkOiAtPlxuICAgIEBtb2RlbC5uZXh0U3RlcCgpXG5cbiAgZnJhbWVMb2FkZWQ6IC0+XG4gICAgIyBpZiB3ZSB0cnkgdG8gaGlkZSBiZWZvcmUgdGhlIGZyYW1lIGlzIHJlbmRlcmVkLCB0aGUgaWZyYW1lIGdvZXNcbiAgICAjIGJhY2sgdG8gdW4taGlkZGVuLiAgIFNvIGZvcmNlIGl0IGFnYWluLlxuICAgIGlzSGlkZGVuID0gQCRlbC5pcyAnOmhpZGRlbidcbiAgICBzdXBlclxuICAgIEBoaWRlKCkgaWYgaXNIaWRkZW5cbiIsIkJhc2VWaWV3ID0gcmVxdWlyZSAndmlld3MvYmFzZV92aWV3J1xudGVtcGxhdGUgPSByZXF1aXJlICd0ZW1wbGF0ZXMvb25ib2FyZGluZ190aXAnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgT25ib2FyZGluZ1RpcCBleHRlbmRzIEJhc2VWaWV3XG4gIGluaXRpYWxpemU6IChvcHRzKSAtPlxuICAgIHN1cGVyXG4gICAgQGxpc3RlblRvIEBtb2RlbCwgJ2NoYW5nZScsIEByZW5kZXJcblxuICByZW5kZXI6IC0+XG4gICAgQCRlbC5odG1sIHRlbXBsYXRlIEBtb2RlbC50b0pTT04oKVxuIiwiJCA9IHJlcXVpcmUgJ2pxdWVyeSdcbkJhc2VFbGVtZW50ID0gcmVxdWlyZSAndmlld3MvYmFzZV9lbGVtZW50J1xuRGlzcGF0Y2hlciA9IHJlcXVpcmUgJ3ZpZXdzL2V2ZW50X2Rpc3BhdGNoZXInXG5PbmJvYXJkaW5nVGlwID0gcmVxdWlyZSAndmlld3Mvb25ib2FyZGluZ190aXAnXG5PbmJvYXJkaW5nVGlwTW9kZWwgPSByZXF1aXJlICdtb2RlbHMvb25ib2FyZGluZ190aXAnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgT25ib2FyZGluZ1RpcEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudFxuICBPTkJPQVJESU5HX1RJUF9XSURUSDogNjEwXG4gIE9OQk9BUkRJTkdfVElQX0hFSUdIVDogMjEwXG5cbiAgZGlzcGF0Y2hlcjogRGlzcGF0Y2hlci5nZXRJbnN0YW5jZSgpXG4gIGVsZW1lbnRDc3NDbGFzczogJ29uYm9hcmRpbmctdGlwJ1xuICBlbGVtZW50Vmlld0NsYXNzOiBPbmJvYXJkaW5nVGlwXG4gIGVsZW1lbnRWaWV3TW9kZWw6IG5ldyBPbmJvYXJkaW5nVGlwTW9kZWxcbiAgdG9wOiAwXG4gIGxlZnQ6IDBcblxuICBpZDogJ21vemJhci1vbmJvYXJkaW5nLXRpcC0jcmFuZG9tLWtleSdcblxuICBpbml0aWFsaXplOiAtPlxuICAgIHN1cGVyXG4gICAgQGxpc3RlblRvIEBkaXNwYXRjaGVyLCAnb25ib2FyZGluZzpzaG93LWhpZ2hsaWdodCcsIEBzaG93XG4gICAgQGxpc3RlblRvIEBkaXNwYXRjaGVyLCAndG9vbHRpcDpoaWRlJywgQHRvb2x0aXBIaWRlXG5cbiAgc2hvdzogKG9wdHMpIC0+XG4gICAgQGVsZW1lbnRWaWV3TW9kZWwuc2V0IG9wdHNcblxuICAgIEB0b3AgPSBvcHRzLnRvcFxuICAgIEB0b3AgLT0gQE9OQk9BUkRJTkdfVElQX0hFSUdIVCBpZiBvcHRzLnBsYWNlbWVudCBpcyAnYWJvdmUnXG4gICAgQGxlZnQgPSBvcHRzLmxlZnRcblxuICAgIEByZW5kZXIoKVxuICAgIEAkZWwuc2hvdygpXG4gICAgQHVwZGF0ZVBvc2l0aW9uKClcblxuICAgIEBoaWRlUmVjZWl2ZWQgPSBmYWxzZVxuICAgIGNsZWFyVGltZW91dCBAdGltZW91dFxuICAgIEB0aW1lb3V0ID0gc2V0VGltZW91dCAoPT4gQHRpbWVvdXRFeHBpcmVkKCkpLCAyMDAwXG5cbiAgcmVuZGVyU2hhZG93OiAoc2hhZG93LCBjc3MpIC0+XG4gICAgc3VwZXJcbiAgICBAdXBkYXRlUG9zaXRpb24oKVxuXG4gIHVwZGF0ZVBvc2l0aW9uOiAtPlxuICAgIEAkZWwuY3NzXG4gICAgICB0b3A6IEB0b3BcbiAgICAgIGxlZnQ6IEBsZWZ0IC0gQCRlbC53aWR0aCgpIC8gMlxuXG4gIHRvb2x0aXBIaWRlOiAtPlxuICAgIEBoaWRlUmVjZWl2ZWQgPSB0cnVlXG4gICAgQGhpZGUoKSB1bmxlc3MgQHRpbWVvdXRcblxuICB0aW1lb3V0RXhwaXJlZDogLT5cbiAgICBAdGltZW91dCA9IG51bGxcbiAgICBAaGlkZSgpIGlmIEBoaWRlUmVjZWl2ZWRcblxuICBoaWRlOiAtPlxuICAgIGNsZWFyVGltZW91dCBAdGltZW91dFxuICAgIEAkZWwuZmFkZU91dCAnZmFzdCcsID0+XG4gICAgICBAZGlzcGF0Y2hlci50cmlnZ2VyICdvbmJvYXJkaW5nOmhpZGUtaGlnaGxpZ2h0J1xuIiwiJCA9IHJlcXVpcmUgJ2pxdWVyeSdcbkFuYWx5dGljcyA9IHJlcXVpcmUgJ21vZGVscy9hbmFseXRpY3MnXG5CYXNlVmlldyA9IHJlcXVpcmUgJ3ZpZXdzL2Jhc2VfdmlldydcblBhZ2UgPSByZXF1aXJlICdtb2RlbHMvcGFnZSdcblNldHRpbmdzID0gcmVxdWlyZSAnbW9kZWxzL3NldHRpbmdzJ1xudGVtcGxhdGUgPSByZXF1aXJlICd0ZW1wbGF0ZXMvb25ib2FyZGluZ19kaWFsb2cnXG5EaXNwYXRjaGVyID0gcmVxdWlyZSAndmlld3MvZXZlbnRfZGlzcGF0Y2hlcidcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBPbmJvYXJkaW5nVmlldyBleHRlbmRzIEJhc2VWaWV3XG4gIGV2ZW50czpcbiAgICAnY2xpY2sgLmNsb3NlJzogJ2Nsb3NlJ1xuICAgICdjbGljayAubmV4dC1zdGVwJzogJ25leHRTdGVwJ1xuICAgICdjbGljayAuY29udGVudCc6ICdjb250ZW50Q2xpY2tlZCdcbiAgICAnY2xpY2snOiAnbmV4dFN0ZXAnXG5cbiAgcmVuZGVyOiAtPlxuICAgIEBhbmFseXRpY3MgPSBBbmFseXRpY3MuZ2V0SW5zdGFuY2UoKVxuICAgIEBkaXNwYXRjaGVyID0gRGlzcGF0Y2hlci5nZXRJbnN0YW5jZSgpXG4gICAgQHNldHRpbmdzID0gU2V0dGluZ3MuZ2V0SW5zdGFuY2UoKVxuXG4gICAgQGxpc3RlblRvIEBtb2RlbCwgJ2NoYW5nZTpwYWdlU3RlcCBjaGFuZ2U6c2VycFN0ZXAnLCBAdXBkYXRlU3RlcFxuXG4gICAgQCRlbC5odG1sIHRlbXBsYXRlXG4gICAgQHVwZGF0ZVN0ZXAoKVxuXG4gICAgKCQgJyNtb3piYXItb25ib2FyZGluZy1kaWFsb2ctI3JhbmRvbS1rZXknKVxuICAgICAgLmhpZGUoKVxuICAgICAgLmZhZGVJbiAnZmFzdCdcblxuICB1cGRhdGVTdGVwOiAtPlxuICAgIHNldHRpbmcgPSBpZiBQYWdlLmlzU2VycCgpIHRoZW4gJ3NlcnBTdGVwJyBlbHNlICdwYWdlU3RlcCdcbiAgICBzdGVwID0gQG1vZGVsLmdldCBzZXR0aW5nXG5cbiAgICBpZiBAaG9zdC5pc0luRE9NKClcbiAgICAgIEAkZWwuZmluZCgnLmNvbnRlbnQnKS5oaWRlKClcbiAgICAgIEAkZWwuZmluZChcIi4je3N0ZXB9XCIpLnNob3coKVxuXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgbmV4dFN0ZXA6IC0+XG4gICAgQG1vZGVsLm5leHRTdGVwKClcbiAgICByZXR1cm4gZmFsc2VcblxuICBjb250ZW50Q2xpY2tlZDogKGUpIC0+XG4gICAgaWYgZS50YXJnZXQuaHJlZiBhbmQgZS50YXJnZXQuaHJlZiBpc250ICcjJ1xuICAgICAgdG9wLndpbmRvdy5sb2NhdGlvbi5ocmVmID0gZS50YXJnZXQuaHJlZlxuXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgcmVtb3ZlOiAoY2FsbGJhY2spIC0+XG4gICAgQHN0b3BMaXN0ZW5pbmcgQHNldHRpbmdzXG4gICAgQHN0b3BMaXN0ZW5pbmcgQGRpc3BhdGNoZXJcblxuICAgICgkICcjbW96YmFyLW9uYm9hcmRpbmctZGlhbG9nLSNyYW5kb20ta2V5JykuZmFkZU91dCAnZmFzdCcsID0+XG4gICAgICBzdXBlclxuICAgICAgY2FsbGJhY2s/LmFwcGx5IHRoaXNcblxuICBjbG9zZTogLT5cbiAgICBAbW9kZWwuY2xvc2UoKVxuICAgIEBhbmFseXRpY3MudHJhY2tDbG9zZU9uYm9hcmRpbmcoKVxuICAgIHJldHVybiBmYWxzZVxuIiwiJCA9IHJlcXVpcmUgJ2pxdWVyeSdcbkJhc2VWaWV3ID0gcmVxdWlyZSAndmlld3MvYmFzZV92aWV3J1xuXG4jIFRoaXMgcHJvdmlkZXMgYSB3aW5kb3cgb3ZlcmxheSB0byBnaXZlIHNvbWV0aGluZyBmb3IgdXNlcnMgdG8gY2xpY2tcbiMgb24gYW5kIGRpc21pc3MgdGhlIGRpYWxvZy5cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBPdmVybGF5IGV4dGVuZHMgQmFzZVZpZXdcbiAgaWQ6ICdtb3piYXItZGlhbG9nLW92ZXJsYXktI3JhbmRvbS1rZXknXG4gIG9wYWNpdHk6IDAuNlxuXG4gIHJlbmRlcjogLT5cbiAgICByZXR1cm4gaWYgQGlzSW5ET00oKVxuXG4gICAgQCRlbC5hcHBlbmRUbygnYm9keScpLmNzc1xuICAgICAgd2lkdGg6ICgkIHdpbmRvdykud2lkdGgoKVxuICAgICAgaGVpZ2h0OiAoJCB3aW5kb3cpLmhlaWdodCgpXG4gICAgICBvcGFjaXR5OiBAb3BhY2l0eVxuXG4gICAgIyByZWdpc3RlciB0aGUgZXZlbnQgaGVyZSBpbnN0ZWFkIG9mIHVzaW5nIGV2ZW50czogYXMgdGhlIGxhdHRlclxuICAgICMgZG9lc250IGFsd2F5cyByZWdpc3RlciB3aGVuIHN3YXBwaW5nIG92ZXJsYXlzXG4gICAgQCRlbC5vbiAnY2xpY2snLCA9PiBAY2xpY2tlZCgpXG5cbiAgc2V0T3BhY2l0eTogKG9wYWNpdHkpIC0+XG4gICAgQCRlbC5jc3Mgb3BhY2l0eTogb3BhY2l0eVxuXG4gIGNsaWNrZWQ6IC0+XG4gICAgQHRyaWdnZXIgJ2NsaWNrZWQnXG4iLCJCYXNlUGFuZWxUYWIgPSByZXF1aXJlICd2aWV3cy9iYXNlX3BhbmVsX3RhYidcbnRlbXBsYXRlID0gcmVxdWlyZSAndGVtcGxhdGVzL3BhZ2VfZWxlbWVudHMnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUGFnZUF0dHJpYnV0ZXMgZXh0ZW5kcyBCYXNlUGFuZWxUYWJcbiAgY2xhc3NOYW1lOiAncGFnZS1hdHRyaWJ1dGVzJ1xuICB0ZW1wbGF0ZTogdGVtcGxhdGVcbiIsIkJhc2VQYW5lbFRhYiA9IHJlcXVpcmUgJ3ZpZXdzL2Jhc2VfcGFuZWxfdGFiJ1xudGVtcGxhdGUgPSByZXF1aXJlICd0ZW1wbGF0ZXMvcGFnZV9lbGVtZW50cydcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBQYWdlRWxlbWVudHMgZXh0ZW5kcyBCYXNlUGFuZWxUYWJcbiAgY2xhc3NOYW1lOiAncGFnZS1lbGVtZW50cydcbiAgdGVtcGxhdGU6IHRlbXBsYXRlXG4iLCJfID0gcmVxdWlyZSAndW5kZXJzY29yZSdcbiQgPSByZXF1aXJlICdqcXVlcnknXG5BbmFseXRpY3MgPSByZXF1aXJlICdtb2RlbHMvYW5hbHl0aWNzJ1xuU2V0dGluZ3MgPSByZXF1aXJlICdtb2RlbHMvc2V0dGluZ3MnXG5UYWJTZXR0aW5ncyA9IHJlcXVpcmUgJ21vZGVscy90YWJfc2V0dGluZ3MnXG5CYXNlVmlldyA9IHJlcXVpcmUgJ3ZpZXdzL2Jhc2Vfdmlldydcbkh0dHBTdGF0dXNMaXN0ID0gcmVxdWlyZSAnbW9kZWxzL2h0dHBfc3RhdHVzX2xpc3QnXG5JbmZvUGFuZWwgPSByZXF1aXJlICd2aWV3cy9pbmZvX3BhbmVsJ1xuTGlua3NQYW5lbCA9IHJlcXVpcmUgJ3ZpZXdzL2xpbmtzX3BhbmVsJ1xuU29jaWFsU3RhdHMgPSByZXF1aXJlICd2aWV3cy9zb2NpYWxfc3RhdHMnXG5GYWNlYm9va1N0YXRzID0gcmVxdWlyZSAnbW9kZWxzL2ZhY2Vib29rX3N0YXRzJ1xuR29vZ2xlUGx1c1N0YXRzID0gcmVxdWlyZSAnbW9kZWxzL2dvb2dsZV9wbHVzX3N0YXRzJ1xudGVtcGxhdGUgPSByZXF1aXJlICd0ZW1wbGF0ZXMvcGFnZV90b29sYmFyJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFBhZ2VUb29sYmFyIGV4dGVuZHMgQmFzZVZpZXdcbiAgIyBob3cgZmFyIHRvICdqdW1wJyB3aGVuIGZpcnN0IHNjcm9sbGluZ1xuICBTVEFSVF9TQ1JPTExfTEVOR1RIOiA0MFxuICAjIGluaXRpYWwgYW5pbWF0aW9uIGxlbmd0aFxuICBTVEFSVF9TQ1JPTExfVElNRTogMTAwXG4gICMgaG93IGZhciB0byBtb3ZlIGVhY2ggaW50ZXJ2YWwgd2hpbGUgbW91c2UgaXMgZG93blxuICBLRUVQX1NST0xMSU5HX0xFTkdUSDogNTBcbiAgIyBpbnRlcnZhbCB0byBtb3ZlIHdoaWxlIG1vdXNlIGlzIGRvd25cbiAgS0VFUF9TQ1JPTExJTkdfVElNRTogMTBcbiAgIyBob3cgbG9uZyB0byB3YWl0IGJlZm9yZSBjb250aW51YWwgc2Nyb2xsaW5nXG4gIEtFRVBfU0NST0xMSU5HX0RFTEFZOiAzMDBcblxuICBhbmFseXRpY3M6IEFuYWx5dGljcy5nZXRJbnN0YW5jZSgpXG4gIHNldHRpbmdzOiBTZXR0aW5ncy5nZXRJbnN0YW5jZSgpXG4gIHRhYlNldHRpbmdzOiBuZXcgVGFiU2V0dGluZ3MoKVxuICBzdGF0dXNMaXN0OiBudWxsXG5cbiAgc2Nyb2xsUG9zOiAwXG4gIG92ZXJmbG93OiAwXG4gIHRpbWVyOiBudWxsXG4gIGludGVydmFsVGltZXI6IG51bGxcblxuICAjIHBhbmVsIHRoYXQgaXMgY3VycmVudGx5IG9wZW5cbiAgY3VycmVudFBhbmVsOiBudWxsXG5cbiAgIyBwYW5lbCB0aGF0IGlzIHNlbGVjdGVkIGJ5IHRoZSB1c2VyLiAgTm90ZSB0aGlzIG1heSBiZSBkaWZmZXJlbnRcbiAgIyB0aGFuIEBjdXJyZW50UGFuZWwgd2hpbGUgb25lIGlzIG9wZW5pbmcgYW5kIHRoZSBvdGhlciBpcyBjbG9zaW5nLlxuICBzZWxlY3RlZFBhbmVsOiBudWxsXG5cbiAgcGFuZWxzOiBudWxsXG4gIHNvY2lhbFN0YXRzOiBudWxsXG5cbiAgZXZlbnRzOlxuICAgICdjbGljayAuc2hvdy1pbmZvLXBhbmVsJzogJ3RvZ2dsZUluZm9QYW5lbCdcbiAgICAnY2xpY2sgLnNob3ctbGlua3MtcGFuZWwnOiAndG9nZ2xlTGlua3NQYW5lbCdcbiAgICAnbW91c2Vkb3duIC5sZWZ0LWFycm93LmVuYWJsZWQnOiAnc2Nyb2xsUmlnaHQnXG4gICAgJ21vdXNlZG93biAucmlnaHQtYXJyb3cuZW5hYmxlZCc6ICdzY3JvbGxMZWZ0J1xuICAgICdtb3VzZXVwIC5zY3JvbGwtYXJyb3dzJzogJ3N0b3BTY3JvbGxpbmcnXG5cbiAgaW5pdGlhbGl6ZTogKG9wdHMpIC0+XG4gICAgc3VwZXJcblxuICAgIEBzdGF0dXNMaXN0ID0gbmV3IEh0dHBTdGF0dXNMaXN0XG5cbiAgICBAcGFuZWxzID1cbiAgICAgICdpbmZvLXBhbmVsJzogbmV3IEluZm9QYW5lbCBob3N0OiBAaG9zdCwgbW9kZWw6IEBzdGF0dXNMaXN0XG4gICAgICAnbGlua3MtcGFuZWwnOiBuZXcgTGlua3NQYW5lbCBob3N0OiBAaG9zdCwgbW9kZWw6IEB0YWJTZXR0aW5nc1xuXG4gICAgcGFuZWxFbCA9IEAkZWwuY2xvc2VzdCgnLnRvb2xiYXInKS5zaWJsaW5ncyAnLnBhbmVsJ1xuICAgIHBhbmVsRWwuYXBwZW5kIHBhbmVsLmVsIGZvciBuYW1lLCBwYW5lbCBvZiBAcGFuZWxzXG5cbiAgICBAc29jaWFsU3RhdHMgPSBbXG4gICAgICBuZXcgU29jaWFsU3RhdHMgbW9kZWw6IG5ldyBGYWNlYm9va1N0YXRzXG4gICAgICBuZXcgU29jaWFsU3RhdHMgbW9kZWw6IG5ldyBHb29nbGVQbHVzU3RhdHNcbiAgICBdXG5cbiAgICBAbGlzdGVuVG8gQG1vZGVsLCAnY2hhbmdlJywgQHJlbmRlclxuICAgIEBsaXN0ZW5UbyBAc3RhdHVzTGlzdCwgJ3N5bmMnLCBAcmVuZGVyXG4gICAgQGxpc3RlblRvIEB0YWJTZXR0aW5ncywgJ2NoYW5nZScsIEB1cGRhdGVMaW5rc0J1dHRvblxuICAgIEBsaXN0ZW5UbyBAc2V0dGluZ3MsICdjaGFuZ2U6bWV0cmljc0NvbHMnLCBAcmVuZGVyXG5cbiAgICAoJCB3aW5kb3cpLm9uICdyZXNpemUnLCA9PiBAcmVzaXplKClcbiAgICBAbGlzdGVuVG8oc3RhdHMsICdyZW5kZXInLCBAcmVzaXplKSBmb3Igc3RhdHMgaW4gQHNvY2lhbFN0YXRzXG5cbiAgcmVuZGVyOiAtPlxuICAgIEBtb2RlbC5mZXRjaCgpIHVubGVzcyBAbW9kZWwuaXNWYWxpZCgpXG4gICAgQHN0YXR1c0xpc3QuZmV0Y2goKSB1bmxlc3MgQHN0YXR1c0xpc3QuaXNWYWxpZCgpXG4gICAgQHRhYlNldHRpbmdzLmZldGNoKCkgdW5sZXNzIEB0YWJTZXR0aW5ncy5pc1ZhbGlkKClcblxuICAgIEAkZWwuaHRtbCB0ZW1wbGF0ZSBfLmV4dGVuZFxuICAgICAgaXNPazogdHJ1ZVxuICAgICAgc2hvd0xpbmtzOiAnbGlua3MnIGluIEBzZXR0aW5ncy5nZXQoJ21ldHJpY3NDb2xzJylcbiAgICAgIEBtb2RlbC50b0pTT04oKSxcbiAgICAgIEBzdGF0dXNMaXN0LmF0KDApPy50b0pTT04oKVxuXG4gICAgQCRlbC5maW5kKCcubGVhcm4tbW9yZScpLmNsaWNrID0+XG4gICAgICBAYW5hbHl0aWNzLnRyYWNrRXZlbnQgJ1BhZ2UgVG9vbGJhci9UcmlhbCBDVEEgQ2xpY2tlZCdcblxuICAgICRzb2NpYWwgPSBAJGVsLmZpbmQgJy5zb2NpYWwtc3RhdHMnXG4gICAgZm9yIHN0YXRzIGluIEBzb2NpYWxTdGF0c1xuICAgICAgc3RhdHMuJGVsLmFwcGVuZFRvICRzb2NpYWxcbiAgICAgIHN0YXRzLnJlbmRlcigpXG5cbiAgICBAdXBkYXRlTGlua3NCdXR0b24oKVxuICAgIEByZXNpemUoKVxuICAgIHN1cGVyXG5cbiAgcmVzaXplOiAtPlxuICAgICR2aWV3cG9ydCA9IEAkZWwuZmluZCAnLnZpZXdwb3J0J1xuICAgICRjb250ZW50cyA9ICR2aWV3cG9ydC5maW5kICcudmlld3BvcnQtY29udGVudHMnXG4gICAgJGFycm93cyA9IEAkZWwuZmluZCAnLnNjcm9sbC1hcnJvd3MnXG4gICAgJHJpZ2h0UGFuZWxXaWR0aCA9IEAkZWwuZmluZCgnLnJpZ2h0LXBhbmVsJykud2lkdGgoKVxuXG4gICAgIyB0ZW1wb3JhcmlseSBzZXQgdG8gMCBzbyBpdCBkb2Vzbid0IGltcGFjdCB0aGUgcmVzdWx0c1xuICAgICR2aWV3cG9ydC53aWR0aD8gMFxuXG4gICAgbWFyZ2luID0gJHZpZXdwb3J0Lm9mZnNldCgpLmxlZnQgLSBAJGVsLm9mZnNldCgpLmxlZnRcblxuICAgIHNob3dBcnJvd3MgPSAkY29udGVudHMud2lkdGgoKSArICRyaWdodFBhbmVsV2lkdGggPiBAJGVsLndpZHRoKCkgLSBtYXJnaW5cbiAgICAkYXJyb3dzLmNzcyBkaXNwbGF5OiBpZiBzaG93QXJyb3dzIHRoZW4gJ2ZsZXgnIGVsc2UgJ25vbmUnXG5cbiAgICBtYXJnaW4gKz0gJGFycm93cy5vdXRlcldpZHRoKHRydWUpIGlmIHNob3dBcnJvd3NcblxuICAgICR2aWV3cG9ydC53aWR0aD8gQCRlbC53aWR0aCgpIC0gbWFyZ2luIC0gJHJpZ2h0UGFuZWxXaWR0aFxuICAgIEBvdmVyZmxvdyA9IE1hdGgubWF4IDAsICRjb250ZW50cy53aWR0aCgpIC0gJHZpZXdwb3J0LndpZHRoKClcblxuICBzY3JvbGxMZWZ0OiAtPlxuICAgIEBzdGFydFNjcm9sbGluZyAtMVxuXG4gIHNjcm9sbFJpZ2h0OiAtPlxuICAgIEBzdGFydFNjcm9sbGluZyAxXG5cbiAgc3RhcnRTY3JvbGxpbmc6IChkaXJlY3Rpb24pIC0+XG4gICAgQHNjcm9sbFBvcyArPSBAU1RBUlRfU0NST0xMX0xFTkdUSCAqIGRpcmVjdGlvblxuXG4gICAgQHRpbWVyID0gc2V0VGltZW91dCA9PlxuICAgICAgQGtlZXBTY3JvbGxpbmcgZGlyZWN0aW9uXG4gICAgLCBAS0VFUF9TQ1JPTExJTkdfREVMQVlcblxuICAgIEAkZWwuZmluZCgnLnZpZXdwb3J0LWNvbnRlbnRzJykuYW5pbWF0ZVxuICAgICAgJ21hcmdpbi1sZWZ0JzogQHNjcm9sbFBvc1xuICAgICxcbiAgICAgIGR1cmF0aW9uOiBAU1RBUlRfU0NST0xMX1RJTUVcblxuICBrZWVwU2Nyb2xsaW5nOiAoZGlyZWN0aW9uKSAtPlxuICAgICRjb250ZW50cyA9IEAkZWwuZmluZCAnLnZpZXdwb3J0LWNvbnRlbnRzJ1xuXG4gICAgQGludGVydmFsVGltZXIgPSBzZXRJbnRlcnZhbCA9PlxuICAgICAgaWYgKGRpcmVjdGlvbiBpcyAxIGFuZCBAc2Nyb2xsUG9zID49IDApIG9yXG4gICAgICAgICAoZGlyZWN0aW9uIGlzIC0xIGFuZCBAc2Nyb2xsUG9zIDw9IEBvdmVyZmxvdyAqIC0xKVxuICAgICAgICBAc3RvcFNjcm9sbGluZygpXG4gICAgICAgIHJldHVyblxuXG4gICAgICBAc2Nyb2xsUG9zICs9IGRpcmVjdGlvbiAqIDJcbiAgICAgICRjb250ZW50cy5jc3MgJ21hcmdpbi1sZWZ0JzogQHNjcm9sbFBvc1xuICAgICxcbiAgICAgIEBLRUVQX1NDUk9MTElOR19USU1FXG5cbiAgc3RvcFNjcm9sbGluZzogLT5cbiAgICBjbGVhckludGVydmFsIEBpbnRlcnZhbFRpbWVyXG4gICAgQGludGVydmFsVGltZXIgPSBudWxsXG5cbiAgICBjbGVhclRpbWVvdXQgQHRpbWVyXG4gICAgQHRpbWVyID0gbnVsbFxuXG4gICAgQHVwZGF0ZVNjcm9sbEFycm93cygpXG5cbiAgdXBkYXRlU2Nyb2xsQXJyb3dzOiAtPlxuICAgICRjb250ZW50cyA9IEAkZWwuZmluZCAnLnZpZXdwb3J0LWNvbnRlbnRzJ1xuICAgIG1hcmdpbiA9IHBhcnNlSW50ICRjb250ZW50cy5jc3MoJ21hcmdpbi1sZWZ0JylcblxuICAgIEAkZWwuZmluZCgnLmxlZnQtYXJyb3cnKS50b2dnbGVDbGFzcyAnZW5hYmxlZCcsIEBzY3JvbGxQb3MgPCAwXG4gICAgQCRlbC5maW5kKCcucmlnaHQtYXJyb3cnKS50b2dnbGVDbGFzcyAnZW5hYmxlZCcsIEBzY3JvbGxQb3MgPiBAb3ZlcmZsb3cgKiAtMVxuXG4gICAgQCRlbC5maW5kKCcuZmFkZS1vdXQnKS50b2dnbGUgbWFyZ2luIDwgMFxuICAgIEAkZWwuZmluZCgnLmZhZGUtaW4nKS50b2dnbGUgbWFyZ2luID4gQG92ZXJmbG93ICogLTFcblxuICB0b2dnbGVJbmZvUGFuZWw6IC0+XG4gICAgQHRvZ2dsZVBhbmVsICdpbmZvLXBhbmVsJ1xuXG4gIHRvZ2dsZUxpbmtzUGFuZWw6IC0+XG4gICAgQHRvZ2dsZVBhbmVsICdsaW5rcy1wYW5lbCdcblxuICB0b2dnbGVQYW5lbDogKG5hbWUpIC0+XG4gICAgQGhpZGVUb29sdGlwKClcblxuICAgIGlmIEBzZWxlY3RlZFBhbmVsIGlzIG5hbWVcbiAgICAgIEBjbG9zZVBhbmVsKG5hbWUpXG4gICAgICByZXR1cm5cblxuICAgIEBvcGVuUGFuZWwobmFtZSlcbiAgICBAcGFuZWxzW25hbWVdLnRyYWNrUGFuZWxWaWV3KClcblxuICBvcGVuUGFuZWw6IChuYW1lKSAtPlxuICAgIEBjbGVhclBhbmVsU2VsZWN0aW9ucygpXG4gICAgQCRlbC5maW5kKFwiLnNob3ctI3tuYW1lfVwiKS5hZGRDbGFzcyAnYWN0aXZlJ1xuXG4gICAgQHNlbGVjdGVkUGFuZWwgPSBuYW1lXG5cbiAgICBpZiBAY3VycmVudFBhbmVsIGFuZCBAY3VycmVudFBhbmVsICE9IEBzZWxlY3RlZFBhbmVsXG4gICAgICBAdHJhbnNpdGlvblN0YXJ0ZWQoKVxuICAgICAgQHBhbmVsc1tAY3VycmVudFBhbmVsXS5jbG9zZSA9PiBAb3BlblNlbGVjdGVkUGFuZWwoKVxuICAgICAgcmV0dXJuXG5cbiAgICBAb3BlblNlbGVjdGVkUGFuZWwoKVxuXG4gIG9wZW5TZWxlY3RlZFBhbmVsOiAtPlxuICAgIEB0cmFuc2l0aW9uU3RhcnRlZCgpXG4gICAgQHBhbmVsc1tAc2VsZWN0ZWRQYW5lbF0/Lm9wZW4gPT4gQHRyYW5zaXRpb25Db21wbGV0ZSgpXG4gICAgQGN1cnJlbnRQYW5lbCA9IEBzZWxlY3RlZFBhbmVsXG5cbiAgY2xvc2VQYW5lbDogKG5hbWUpIC0+XG4gICAgQGNsZWFyUGFuZWxTZWxlY3Rpb25zKClcbiAgICBAc2VsZWN0ZWRQYW5lbCA9IG51bGxcbiAgICBAcGFuZWxzW25hbWVdPy5jbG9zZSA9PlxuICAgICAgQGN1cnJlbnRQYW5lbCA9IG51bGxcbiAgICAgIEB0cmFuc2l0aW9uQ29tcGxldGUoKVxuXG4gIGNsb3NlQWxsUGFuZWxzOiAoZG9uZSkgLT5cbiAgICBAY2xlYXJQYW5lbFNlbGVjdGlvbnMoKVxuICAgIEB0cmFuc2l0aW9uQ29tcGxldGUgPT5cbiAgICAgIGRvbmUoKSB1bmxlc3MgQGN1cnJlbnRQYW5lbFxuICAgICAgQHBhbmVsc1tAY3VycmVudFBhbmVsXT8uY2xvc2UgPT5cbiAgICAgICAgQGN1cnJlbnRQYW5lbCA9IEBzZWxlY3RlZFBhbmVsID0gbnVsbFxuICAgICAgICBkb25lKClcblxuICB0cmFuc2l0aW9uU3RhcnRlZDogLT5cbiAgICBAaW5UcmFuc2l0aW9uID0gdHJ1ZVxuXG4gIHRyYW5zaXRpb25Db21wbGV0ZTogKGRvbmUpIC0+XG4gICAgaWYgZG9uZVxuICAgICAgaWYgQGluVHJhbnNpdGlvbiB0aGVuIEB0cmFuc2l0aW9uQ29tcGxldGVDYWxsYmFjayA9IGRvbmUgZWxzZSBkb25lKClcbiAgICAgIHJldHVyblxuXG4gICAgIyBjYWxsZWQgd2l0aCBubyBwYXJhbWV0ZXJzLCBleGVjdXRlIHRoZSBjYWxsYmFjayBpZiBpdCBleGlzdHNcbiAgICBAdHJhbnNpdGlvbkNvbXBsZXRlQ2FsbGJhY2s/KClcbiAgICBAdHJhbnNpdGlvbkNvbXBsZXRlQ2FsbGJhY2sgPSBudWxsXG4gICAgQGluVHJhbnNpdGlvbiA9IGZhbHNlXG5cbiAgdXBkYXRlTGlua3NCdXR0b246IC0+XG4gICAgdHlwZXMgPSBAcGFuZWxzWydsaW5rcy1wYW5lbCddLmdldExpbmtUeXBlcygpXG5cbiAgICBsaW5rcyA9IEB0YWJTZXR0aW5ncy5nZXQoJ2hpZ2hsaWdodExpbmtzJykgb3IgW11cbiAgICAkYnV0dG9uID0gQCRlbC5maW5kKCcuc2hvdy1saW5rcy1wYW5lbCcpXG5cbiAgICAkYnV0dG9uLnRvZ2dsZUNsYXNzKHR5cGUsIGxpbmtzLmluZGV4T2YodHlwZSkgPiAtMSkgZm9yIHR5cGUgaW4gdHlwZXNcblxuICBjbGVhclBhbmVsU2VsZWN0aW9uczogLT5cbiAgICBAJGVsLmZpbmQoJy5idG4nKS5yZW1vdmVDbGFzcyAnYWN0aXZlJ1xuIiwiQmFzZVZpZXcgPSByZXF1aXJlICd2aWV3cy9iYXNlX3ZpZXcnXG5cbiNcbiMgYmFzZSB2aWV3IGZvciBtb3piYXIgcGFuZWxzXG4jXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUGFuZWxWaWV3IGV4dGVuZHMgQmFzZVZpZXdcbiAgUEFORUxfSEVJR0hUOiA1MFxuICBpc09wZW46IGZhbHNlXG5cbiAgb3BlbjogKGNvbXBsZXRlKSAtPlxuICAgIEBpc09wZW4gPSB0cnVlXG4gICAgQHVwZGF0ZVBhbmVsSGVpZ2h0IEBQQU5FTF9IRUlHSFQsIGNvbXBsZXRlXG5cbiAgY2xvc2U6IChjb21wbGV0ZSkgLT5cbiAgICBAaXNPcGVuID0gZmFsc2VcbiAgICBAdXBkYXRlUGFuZWxIZWlnaHQgMCwgY29tcGxldGVcblxuICB0b2dnbGVPcGVuOiAoY29tcGxldGUpIC0+XG4gICAgaWYgQGlzT3BlbiB0aGVuIChAY2xvc2UgY29tcGxldGUpIGVsc2UgKEBvcGVuIGNvbXBsZXRlKVxuXG4gIHVwZGF0ZVBhbmVsSGVpZ2h0OiAoaGVpZ2h0LCBjb21wbGV0ZSkgLT5cbiAgICBAJGVsLmFuaW1hdGUgaGVpZ2h0OiBoZWlnaHQsIEBob3N0LlBBTkVMX1NXSU5HX0RVUkFUSU9OXG4gICAgQGhvc3QudXBkYXRlUGFuZWxIZWlnaHQgaGVpZ2h0LCBjb21wbGV0ZVxuIiwiJCA9IHJlcXVpcmUgJ2pxdWVyeSdcbkJhc2VFbGVtZW50ID0gcmVxdWlyZSAndmlld3MvYmFzZV9lbGVtZW50J1xuUHJvZmlsZUVkaXQgPSByZXF1aXJlICd2aWV3cy9wcm9maWxlX2VkaXQnXG5PdmVybGF5ID0gcmVxdWlyZSAndmlld3Mvb3ZlcmxheSdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBQcm9maWxlRGlhbG9nIGV4dGVuZHMgQmFzZUVsZW1lbnRcbiAgZWxlbWVudENzc0NsYXNzOiAncHJvZmlsZS1kaWFsb2cnXG4gIGVsZW1lbnRWaWV3Q2xhc3M6IFByb2ZpbGVFZGl0XG4gIG92ZXJsYXk6IG51bGxcblxuICBpZDogJ21vemJhci1wcm9maWxlLWRpYWxvZy0jcmFuZG9tLWtleSdcblxuICBpbml0aWFsaXplOiAob3B0cykgLT5cbiAgICBAZWxlbWVudFZpZXdNb2RlbCA9IG9wdHMubW9kZWxcbiAgICBAb3ZlcmxheSA9IG5ldyBPdmVybGF5IG9uUmVtb3ZlOiA9PiBAcmVtb3ZlKClcbiAgICBzdXBlclxuXG4gIHJlbmRlcjogLT5cbiAgICBzdXBlclxuICAgIEBvdmVybGF5LnJlbmRlcigpXG5cbiAgcmVtb3ZlOiAtPlxuICAgIHN1cGVyXG4gICAgQG92ZXJsYXkucmVtb3ZlKClcbiIsIl8gPSByZXF1aXJlICd1bmRlcnNjb3JlJ1xuQmFzZVZpZXcgPSByZXF1aXJlICd2aWV3cy9iYXNlX3ZpZXcnXG5SZWdpb25zID0gcmVxdWlyZSAnbW9kZWxzL3JlZ2lvbnMnXG5DaXRpZXMgPSByZXF1aXJlICdtb2RlbHMvY2l0aWVzJ1xudGVtcGxhdGUgPSByZXF1aXJlICd0ZW1wbGF0ZXMvcHJvZmlsZV9lZGl0J1xucmVnaW9uVGVtcGxhdGUgPSByZXF1aXJlICd0ZW1wbGF0ZXMvcHJvZmlsZV9lZGl0X3JlZ2lvbnMnXG5jaXR5VGVtcGxhdGUgPSByZXF1aXJlICd0ZW1wbGF0ZXMvcHJvZmlsZV9lZGl0X2NpdGllcydcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBQcm9maWxlRWRpdCBleHRlbmRzIEJhc2VWaWV3XG4gIHJlZ2lvbnM6IG5ldyBSZWdpb25zXG4gIGNpdGllczogbmV3IENpdGllc1xuXG4gIGV2ZW50czpcbiAgICAnY2xpY2sgLmNhbmNlbCc6ICdjbG9zZSdcbiAgICAnY2xpY2sgLnNhdmUnOiAnc2F2ZSdcbiAgICAnY2xpY2sgLmRlbGV0ZSc6ICdkZWxldGUnXG4gICAgJ2NoYW5nZSAuY291bnRyeSc6ICd1cGRhdGVSZWdpb25zJ1xuICAgICdjaGFuZ2UgLnJlZ2lvbic6ICd1cGRhdGVDaXRpZXMnXG4gICAgJ2tleWRvd24gLnByb2ZpbGUtZWRpdCc6ICdkaWFsb2dLZXlEb3duJ1xuXG4gIGluaXRpYWxpemU6IChvcHRpb25zKSAtPlxuICAgIHN1cGVyXG5cbiAgICBAbGlzdGVuVG8gQHJlZ2lvbnMsICdyZXNldCcsIEByZW5kZXJSZWdpb25zXG4gICAgQGxpc3RlblRvIEBjaXRpZXMsICdyZXNldCcsIEByZW5kZXJDaXRpZXNcblxuICByZW5kZXI6IC0+XG4gICAgQCRlbC5odG1sIHRlbXBsYXRlIEBtb2RlbC50b0pTT04oKVxuICAgIEB1cGRhdGVSZWdpb25zKClcblxuICByZW5kZXJSZWdpb25zOiAtPlxuICAgIEAkZWwuZmluZCgnLnJlZ2lvbicpXG4gICAgICAuaHRtbChyZWdpb25UZW1wbGF0ZSBfLmV4dGVuZCBAbW9kZWwudG9KU09OKCksXG4gICAgICAgIHJlZ2lvbnM6IEByZWdpb25zLnRvSlNPTigpKVxuICAgICAgLnZhbChAbW9kZWwuZ2V0ICdyZWdpb24nKVxuXG4gICAgQHVwZGF0ZUNpdGllcygpXG5cbiAgcmVuZGVyQ2l0aWVzOiAtPlxuICAgIEAkZWwuZmluZCgnLmNpdHknKVxuICAgICAgLmh0bWwoY2l0eVRlbXBsYXRlIF8uZXh0ZW5kIEBtb2RlbC50b0pTT04oKSxcbiAgICAgICAgY2l0aWVzOiBAY2l0aWVzLnRvSlNPTigpKVxuICAgICAgLnZhbChAbW9kZWwuZ2V0ICdjaXR5JylcblxuICAgIEB1cGRhdGVGaWVsZFN0YXRlKClcblxuICB1cGRhdGVSZWdpb25zOiAtPlxuICAgIGNvdW50cnkgPSBAJGVsLmZpbmQoJy5jb3VudHJ5JykudmFsKClcbiAgICBAcmVnaW9ucy5jb3VudHJ5ID0gY291bnRyeVxuXG4gICAgQHJlZ2lvbnMuZmV0Y2ggcmVzZXQ6IHRydWVcblxuICB1cGRhdGVDaXRpZXM6IC0+XG4gICAgcmVnaW9uID0gQCRlbC5maW5kKCcucmVnaW9uJykudmFsKClcbiAgICBAY2l0aWVzLnJlZ2lvbiA9IHJlZ2lvblxuICAgIEBjaXRpZXMuZmV0Y2ggcmVzZXQ6IHRydWVcbiAgICBAdXBkYXRlRmllbGRTdGF0ZSgpXG5cbiAgdXBkYXRlRmllbGRTdGF0ZTogLT5cbiAgICByZWdpb24gPSBAJGVsLmZpbmQoJy5jaXR5JykuZ2V0KDApLmRpc2FibGVkID0gIUAkZWwuZmluZCgnLnJlZ2lvbicpLnZhbCgpXG5cbiAgZGlhbG9nS2V5RG93bjogKGUpIC0+XG4gICAgIyBnb29nbGUgdHJpZXMgdG8gc3RlYWwga2V5c3Ryb2tlcyBldmVuIGlmIHRoZWlyIHNlYXJjaCBib3ggZG9lc24ndCBoYXZlXG4gICAgIyBmb2N1cy4gIFNjcmV3IGVtIVxuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcblxuICBzYXZlOiAtPlxuICAgIEBtb2RlbC5zZXRcbiAgICAgIGVuZ2luZTogQCRlbC5maW5kKCcuZW5naW5lJykudmFsKClcbiAgICAgIGNvdW50cnk6IEAkZWwuZmluZCgnLmNvdW50cnknKS52YWwoKVxuICAgICAgcmVnaW9uOiBAJGVsLmZpbmQoJy5yZWdpb24nKS52YWwoKVxuICAgICAgY2l0eTogQCRlbC5maW5kKCcuY2l0eScpLnZhbCgpXG4gICAgICBuYW1lOiBAJGVsLmZpbmQoJy5uYW1lJykudmFsKClcbiAgICAgIGRpc2FibGVQZXJzb25hbGl6YXRpb246XG4gICAgICAgIEAkZWwuZmluZCgnLmRpc2FibGUtcGVyc29uYWxpemF0aW9uJykuaXMoJzpjaGVja2VkJylcblxuICAgIEBtb2RlbC5zYXZlKClcbiAgICBAY2xvc2UoKVxuXG4gIGRlbGV0ZTogLT5cbiAgICBpZiBub3QgY29uZmlybSAnQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZSB0aGlzIHByb2ZpbGU/J1xuICAgICAgcmV0dXJuXG5cbiAgICBAbW9kZWwuZGVzdHJveSgpXG4gICAgQGNsb3NlKClcblxuICBjbG9zZTogLT5cbiAgICBAaG9zdC5yZW1vdmUoKVxuXG4iLCIkID0gcmVxdWlyZSAnanF1ZXJ5J1xuQmFzZUVsZW1lbnQgPSByZXF1aXJlICd2aWV3cy9iYXNlX2VsZW1lbnQnXG5Qcm9maWxlc0xpc3QgPSByZXF1aXJlICd2aWV3cy9wcm9maWxlc19saXN0J1xuUHJvZmlsZURpYWxvZyA9IHJlcXVpcmUgJ3ZpZXdzL3Byb2ZpbGVfZGlhbG9nJ1xuUHJvZmlsZXMgPSByZXF1aXJlICdtb2RlbHMvcHJvZmlsZXMnXG5Qcm9maWxlID0gcmVxdWlyZSAnbW9kZWxzL3Byb2ZpbGUnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUHJvZmlsZXNEcm9wRG93biBleHRlbmRzIEJhc2VFbGVtZW50XG4gIGVsZW1lbnRDc3NDbGFzczogJ3Byb2ZpbGVzLWRyb3AtZG93bidcbiAgZWxlbWVudFZpZXdDbGFzczogUHJvZmlsZXNMaXN0XG4gIGVsZW1lbnRWaWV3TW9kZWw6IG5ldyBQcm9maWxlc1xuXG4gIGlkOiAnbW96YmFyLXByb2ZpbGVzLWRyb3AtZG93bi0jcmFuZG9tLWtleSdcblxuICBpbml0aWFsaXplOiAoQG9wdGlvbnMpIC0+XG5cbiAgcmVuZGVyOiAtPlxuICAgIHN1cGVyXG4gICAgaGVpZ2h0ID0gKCQgd2luZG93KS5oZWlnaHQoKSAtIChAb3B0aW9ucy50b3Agb3IgQG9wdGlvbnMuYm90dG9tKVxuICAgIEAkZWwuY3NzXG4gICAgICB0b3A6IEBvcHRpb25zLnRvcFxuICAgICAgYm90dG9tOiBAb3B0aW9ucy5ib3R0b21cbiAgICAgIGxlZnQ6IEBvcHRpb25zLmxlZnRcbiAgICAgIGhlaWdodDogaGVpZ2h0XG5cbiAgICBAb3B0aW9ucy5vcGVuZWQ/LmFwcGx5IHRoaXNcblxuICAgICgkIHdpbmRvdykub24gJ2NsaWNrLnByb2ZpbGVzLWRyb3AtZG93bicsIChlKSA9PlxuICAgICAgaWYgbm90IEAkZWwuaXMoZS50YXJnZXQpIGFuZCBAJGVsLmhhcyhlLnRhcmdldCkubGVuZ3RoIGlzIDBcbiAgICAgICAgQHJlbW92ZSgpXG5cbiAgcmVtb3ZlOiAtPlxuICAgIHN1cGVyXG4gICAgKCQgd2luZG93KS5vZmYgJ2NsaWNrLnByb2ZpbGVzLWRyb3AtZG93bidcbiAgICBAb3B0aW9ucy5jbG9zZWQ/LmFwcGx5IHRoaXNcblxuICBlZGl0UHJvZmlsZTogKHByb2ZpbGUpIC0+XG4gICAgZGlhbG9nID0gbmV3IFByb2ZpbGVEaWFsb2cgbW9kZWw6IHByb2ZpbGUgb3IgbmV3IFByb2ZpbGVcbiAgICBkaWFsb2cucmVuZGVyKClcblxuIiwiJCA9IHJlcXVpcmUgJ2pxdWVyeSdcbkJhc2VWaWV3ID0gcmVxdWlyZSAndmlld3MvYmFzZV92aWV3J1xuU2V0dGluZ3MgPSByZXF1aXJlICdtb2RlbHMvc2V0dGluZ3MnXG50ZW1wbGF0ZSA9IHJlcXVpcmUgJ3RlbXBsYXRlcy9wcm9maWxlc19saXN0J1xuUGFnZSA9IHJlcXVpcmUgJ21vZGVscy9wYWdlJ1xuZ29vZ2xlRG9tYWlucyA9IHJlcXVpcmUgJ21vZGVscy9nb29nbGVfZG9tYWlucydcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBQcm9maWxlc0xpc3QgZXh0ZW5kcyBCYXNlVmlld1xuICBzZXR0aW5nczogU2V0dGluZ3MuZ2V0SW5zdGFuY2UoKVxuXG4gIGV2ZW50czpcbiAgICAnY2xpY2sgbGlbZGF0YS1pZF0nOiAnc2VsZWN0UHJvZmlsZSdcbiAgICAnY2xpY2sgLmVkaXQtcHJvZmlsZSwgLmFkZC1uZXcnOiAnZWRpdFByb2ZpbGUnXG5cbiAgaW5pdGlhbGl6ZTogKG9wdHMpIC0+XG4gICAgc3VwZXJcbiAgICBAbGlzdGVuVG8gQG1vZGVsLCAnY2hhbmdlJywgQHJlbmRlclxuXG4gIHJlbmRlcjogLT5cbiAgICBAJGVsLmh0bWwgdGVtcGxhdGUgQG1vZGVsLnRvSlNPTigpXG4gICAgQCRlbC50b2dnbGVDbGFzcyAnYm90dG9tJywgQHNldHRpbmdzLmdldCAnaXNEb2NrZWRPbkJvdHRvbSdcblxuICBzZWxlY3RQcm9maWxlOiAoZSkgLT5cbiAgICAkdGFyZ2V0ID0gKCQgZS5jdXJyZW50VGFyZ2V0KVxuICAgIGlkID0gJHRhcmdldC5kYXRhICdpZCdcbiAgICBAc2V0dGluZ3Muc2V0IHNlbGVjdGVkUHJvZmlsZUlkOiBpZFxuXG4gICAgQHJ1blByb2ZpbGUgQG1vZGVsLmdldCBpZFxuXG4gICAgQHNldHRpbmdzLnNhdmUoKVxuICAgIEBob3N0LnJlbW92ZSgpXG5cbiAgcnVuUHJvZmlsZTogKHByb2ZpbGUpIC0+XG4gICAgZW5naW5lID0gcHJvZmlsZS5nZXQgJ2VuZ2luZSdcbiAgICBjb3VudHJ5ID0gcHJvZmlsZS5nZXQgJ2NvdW50cnknXG4gICAgc2VhcmNoVGVybSA9IFBhZ2UuZ2V0U2VhcmNoVGVybSgpXG4gICAgcGFyYW1zID0ge31cbiAgICB1cmwgPSAnJ1xuICAgIHFzID0gJydcblxuICAgIHN3aXRjaCBlbmdpbmVcblxuICAgICAgd2hlbiAnZ29vZ2xlJ1xuICAgICAgICB1cmwgPSBnb29nbGVEb21haW5zLmdldERvbWFpbiBjb3VudHJ5XG5cbiAgICAgICAgcGxhY2UgPSAnJ1xuICAgICAgICBjaXR5ID0gcHJvZmlsZS5nZXQgJ2NpdHknXG4gICAgICAgIHBsYWNlID0gXCIje2NpdHl9LFwiIGlmIGNpdHlcbiAgICAgICAgcGxhY2UgKz0gcHJvZmlsZS5nZXQgJ3JlZ2lvbidcblxuICAgICAgICBwYXJhbXMgPVxuICAgICAgICAgIHE6IHNlYXJjaFRlcm1cbiAgICAgICAgICBpZTogJ1VURi04J1xuICAgICAgICAgIG9lOiAnVVRGLTgnXG4gICAgICAgICAgaXA6ICcwLjAuMC4wJ1xuICAgICAgICAgIHB3czogMCBpZiBwcm9maWxlLmdldCAnZGlzYWJsZVBlcnNvbmFsaXphdGlvbidcblxuICAgICAgICAjIHNlZSBodHRwOi8vYml0Lmx5LzFkZjNRdExcbiAgICAgICAga2V5ID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXS1laJ1xuICAgICAgICBrZXkgKz0ga2V5LnRvTG93ZXJDYXNlKClcbiAgICAgICAga2V5ICs9ICcwMTIzNDU2Nzg5LSAnXG5cbiAgICAgICAgc2VjcmV0ID0ga2V5LnN1YnN0ciBwbGFjZS5sZW5ndGgsIDFcbiAgICAgICAgdXVsZSA9IFwidytDQUlRSUNJI3tzZWNyZXR9I3tidG9hIHBsYWNlfVwiXG5cbiAgICAgICAgIyBkb24ndCBlbmNvZGUgdXVsZSBwYXJhbVxuICAgICAgICBxcyA9IFwiI3skLnBhcmFtKHBhcmFtcyl9JnV1bGU9I3t1dWxlfVwiXG5cbiAgICAgIHdoZW4gJ2JpbmcnXG4gICAgICAgIHVybCA9IFwiaHR0cDovL3d3dy5iaW5nLmNvbS9zZWFyY2g/XCJcbiAgICAgICAgcGFyYW1zLnEgPSBzZWFyY2hUZXJtXG4gICAgICAgIHBhcmFtc1snIGxvYzonXSA9IGNvdW50cnkgaWYgY291bnRyeVxuXG4gICAgICB3aGVuICd5YWhvbydcbiAgICAgICAgdXJsID0gJ2h0dHA6Ly9zZWFyY2gueWFob28uY29tL3NlYXJjaD8nXG4gICAgICAgIHBhcmFtcy5wID0gc2VhcmNoVGVybVxuICAgICAgICBwYXJhbXMudmMgPSBjb3VudHJ5IGlmIGNvdW50cnlcblxuICAgIHFzID0gJC5wYXJhbSBwYXJhbXMgdW5sZXNzIHFzXG4gICAgdXJsICs9IGlmIHVybC5pbmRleE9mICc/JyA+IDAgdGhlbiAnJicgZWxzZSAnPydcbiAgICB1cmwgKz0gcXNcblxuICAgIGlmIFBhZ2UuZ2V0U2VycEVuZ2luZSgpIGlzIGVuZ2luZVxuICAgICAgd2luZG93LnRvcC5sb2NhdGlvbi5ocmVmID0gdXJsXG4gICAgZWxzZVxuICAgICAgd2luZG93Lm9wZW4gdXJsXG5cbiAgZWRpdFByb2ZpbGU6IChlKSAtPlxuICAgIGlkID0gKCQgZS5jdXJyZW50VGFyZ2V0KS5wYXJlbnQoKS5kYXRhICdpZCdcbiAgICBAaG9zdC5lZGl0UHJvZmlsZSBAbW9kZWwuZ2V0KGlkKVxuICAgIEBob3N0LnJlbW92ZSgpXG5cbiAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG4iLCIkID0gcmVxdWlyZSAnanF1ZXJ5J1xuQmFzZVBhbmVsVGFiID0gcmVxdWlyZSAndmlld3MvYmFzZV9wYW5lbF90YWInXG5Ud2l0dGVyQ2FyZHMgPSByZXF1aXJlICd2aWV3cy90d2l0dGVyX2NhcmRzJ1xuVHdpdHRlciA9IHJlcXVpcmUgJ21vZGVscy90d2l0dGVyJ1xudGVtcGxhdGUgPSByZXF1aXJlICd0ZW1wbGF0ZXMvc2VtYW50aWNzJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFNlbWFudGljcyBleHRlbmRzIEJhc2VQYW5lbFRhYlxuICBjbGFzc05hbWU6ICdzZW1hbnRpY3MnXG4gIHRlbXBsYXRlOiB0ZW1wbGF0ZVxuICB0d2l0dGVyQ2FyZHM6IG51bGxcbiAgYWN0aXZlU25pcHBldDogJ3NjaGVtYSdcblxuICBldmVudHM6XG4gICAgJ2NsaWNrIC5zbmlwcGV0IC5jb250ZW50JzogJ3NuaXBwZXRDbGlja2VkJ1xuXG4gIHNuaXBwZXRDbGlja2VkOiAoZSkgLT5cbiAgICAkdGFyZ2V0ID0gKCQgZS5jdXJyZW50VGFyZ2V0KVxuICAgIEBhY3RpdmVTbmlwcGV0ID0gJHRhcmdldC5kYXRhICdzaG93J1xuICAgIEBzZWxlY3RBY3RpdmVTbmlwcGV0KClcblxuICBzZWxlY3RBY3RpdmVTbmlwcGV0OiAtPlxuICAgIEAkZWwuZmluZCgnLmNvbnRlbnQnKS5yZW1vdmVDbGFzcyAnYWN0aXZlJ1xuICAgIEAkZWwuZmluZChcIi5jb250ZW50LiN7QGFjdGl2ZVNuaXBwZXR9XCIpLmFkZENsYXNzICdhY3RpdmUnXG4gICAgQCRlbC5maW5kKFwiLmNvbnRlbnRbZGF0YS1zaG93PScje0BhY3RpdmVTbmlwcGV0fSddXCIpLmFkZENsYXNzICdhY3RpdmUnXG5cbiAgICBpZiBAYWN0aXZlU25pcHBldCBpcyAndHdpdHRlcidcbiAgICAgIEB0d2l0dGVyQ2FyZHMgPz0gbmV3IFR3aXR0ZXJDYXJkc1xuICAgICAgICBtb2RlbDogbmV3IFR3aXR0ZXJcbiAgICAgICAgZWw6IEAkZWwuZmluZCAnLnByZXZpZXcgLnR3aXR0ZXInXG5cbiAgICAgIEB0d2l0dGVyQ2FyZHMucmVuZGVyKClcblxuICByZW5kZXI6IC0+XG4gICAgc3VwZXJcbiAgICBAc2VsZWN0QWN0aXZlU25pcHBldCgpXG4iLCIkID0gcmVxdWlyZSAnanF1ZXJ5J1xuQmFzZUVsZW1lbnQgPSByZXF1aXJlICd2aWV3cy9iYXNlX2VsZW1lbnQnXG5TZXJwSXRlbSA9IHJlcXVpcmUgJ3ZpZXdzL3NlcnBfaXRlbSdcblBhZ2UgPSByZXF1aXJlICdtb2RlbHMvcGFnZSdcblNlcnBSZXN1bHRzTWV0cmljcyA9IHJlcXVpcmUgJ21vZGVscy9zZXJwX3Jlc3VsdHNfbWV0cmljcydcbnNlcnBJdGVtVGVtcGxhdGUgPSByZXF1aXJlICd0ZW1wbGF0ZXMvc2VycF9pdGVtJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFNlcnBFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnRcbiAgY2xhc3NOYW1lOiAnbW96YmFyLXNlcnAtaXRlbS0jcmFuZG9tLWtleSdcblxuICBlbGVtZW50VGVtcGxhdGU6IHNlcnBJdGVtVGVtcGxhdGVcbiAgZWxlbWVudENzc0NsYXNzOiAnc2VycC1pdGVtJ1xuICBlbGVtZW50Vmlld0NsYXNzOiBTZXJwSXRlbVxuXG4gIGluaXRpYWxpemU6IChvcHRzKSAtPlxuICAgIHN1cGVyXG4gICAgQGVsZW1lbnRWaWV3TW9kZWwgPSBAbW9kZWwuZ2V0ICdtZXRyaWNzJ1xuXG4gIHBhcmVudEVsZW1lbnQ6IC0+XG4gICAgQG1vZGVsLmdldCAnZWwnXG4iLCIkID0gcmVxdWlyZSAnanF1ZXJ5J1xuQmFzZVZpZXcgPSByZXF1aXJlICd2aWV3cy9iYXNlX3ZpZXcnXG5zZXJwSXRlbSA9IHJlcXVpcmUgJ3RlbXBsYXRlcy9zZXJwX2l0ZW0nXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgU2VycEl0ZW0gZXh0ZW5kcyBCYXNlVmlld1xuICB0b29sdGlwUGxhY2VtZW50OiAnYWJvdmUnXG5cbiAgaW5pdGlhbGl6ZTogKG9wdHMpIC0+XG4gICAgc3VwZXJcbiAgICBAbGlzdGVuVG8gQG1vZGVsLCAnY2hhbmdlJywgQHJlbmRlclxuXG4gIHJlbmRlcjogLT5cbiAgICBAbW9kZWwuZmV0Y2goKSB1bmxlc3MgQG1vZGVsLmlzVmFsaWQoKVxuICAgIEAkZWwuaHRtbCBzZXJwSXRlbSBAbW9kZWwudG9KU09OKClcbiAgICBAc2hvd09uYm9hcmRpbmdIaWdobGlnaHRzKClcbiIsIiQgPSByZXF1aXJlICdqcXVlcnknXG5fID0gcmVxdWlyZSAndW5kZXJzY29yZSdcbkFuYWx5dGljcyA9IHJlcXVpcmUgJ21vZGVscy9hbmFseXRpY3MnXG5QYWdlID0gcmVxdWlyZSAnbW9kZWxzL3BhZ2UnXG5CYXNlVmlldyA9IHJlcXVpcmUgJ3ZpZXdzL2Jhc2VfdmlldydcbnNlcnBUb29sYmFyID0gcmVxdWlyZSAndGVtcGxhdGVzL3NlcnBfdG9vbGJhcidcbmdvb2dsZURvbWFpbnMgPSByZXF1aXJlICdtb2RlbHMvZ29vZ2xlX2RvbWFpbnMnXG5TZXJwQXR0cmlidXRlcyA9IHJlcXVpcmUgJ21vZGVscy9zZXJwX2F0dHJpYnV0ZXMnXG5TZXR0aW5ncyA9IHJlcXVpcmUgJ21vZGVscy9zZXR0aW5ncydcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTZXJwVG9vbGJhciBleHRlbmRzIEJhc2VWaWV3XG4gIGFuYWx5dGljczogQW5hbHl0aWNzLmdldEluc3RhbmNlKClcbiAgc2V0dGluZ3M6IFNldHRpbmdzLmdldEluc3RhbmNlKClcblxuICBldmVudHM6XG4gICAgJ2NsaWNrIC5zZWFyY2gtcHJvZmlsZSc6ICdzaG93UHJvZmlsZURyb3BEb3duJ1xuICAgICdjbGljayAuZXhwb3J0JzogJ2V4cG9ydFNlcnBSZXN1bHRzJ1xuXG4gIGluaXRpYWxpemU6IC0+XG4gICAgc3VwZXJcbiAgICBAbGlzdGVuVG8gQG1vZGVsLCAnY2hhbmdlJywgQHJlbmRlclxuXG4gIHJlbmRlcjogLT5cbiAgICBAJGVsLmh0bWwgc2VycFRvb2xiYXIgQG1vZGVsLnRvSlNPTigpXG4gICAgQCRlbC5maW5kKCcubGVhcm4tbW9yZScpLmNsaWNrID0+XG4gICAgICBAYW5hbHl0aWNzLnRyYWNrRXZlbnQgJ1NFUlAgVG9vbGJhci9UcmlhbCBDVEEgQ2xpY2tlZCdcblxuICBzaG93UHJvZmlsZURyb3BEb3duOiAoZSkgLT5cbiAgICBpc0RvY2tlZE9uQm90dG9tID0gQHNldHRpbmdzLmdldCAnaXNEb2NrZWRPbkJvdHRvbSdcbiAgICAkc2VsZWN0Qm94ID0gQCRlbC5maW5kICcuc2VhcmNoLXByb2ZpbGUnXG4gICAgb2Zmc2V0ID0gJHNlbGVjdEJveC5vZmZzZXQoKVxuXG4gICAgQGhvc3QudG9nZ2xlUHJvZmlsZXNEcm9wRG93blxuICAgICAgdG9wOiBvZmZzZXQudG9wICsgJHNlbGVjdEJveC5oZWlnaHQoKSB1bmxlc3MgaXNEb2NrZWRPbkJvdHRvbVxuICAgICAgYm90dG9tOiBvZmZzZXQudG9wICsgJHNlbGVjdEJveC5oZWlnaHQoKSBpZiBpc0RvY2tlZE9uQm90dG9tXG4gICAgICBsZWZ0OiBvZmZzZXQubGVmdFxuICAgICAgb3BlbmVkOiAtPlxuICAgICAgICAkc2VsZWN0Qm94LmZpbmQoJy5hcnJvdycpLnJlbW92ZUNsYXNzKCdhcnJvdy1kb3duJykuYWRkQ2xhc3MgJ2Fycm93LXVwJ1xuICAgICAgY2xvc2VkOiAtPlxuICAgICAgICAkc2VsZWN0Qm94LmZpbmQoJy5hcnJvdycpLnJlbW92ZUNsYXNzKCdhcnJvdy11cCcpLmFkZENsYXNzICdhcnJvdy1kb3duJ1xuXG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKVxuXG4gIGV4cG9ydFNlcnBSZXN1bHRzOiAtPlxuICAgIG5vdyA9IG5ldyBEYXRlKClcblxuICAgIGRhdGEgPSBbXG4gICAgICAnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJ1xuICAgICAgJ01veiBUb29sYmFyIFNFUlAgUmVwb3J0J1xuICAgICAgXCJLZXl3b3JkOiAje1BhZ2UuZ2V0U2VhcmNoVGVybSgpfVwiXG4gICAgICBcIlNlYXJjaCBFbmdpbmU6ICN7UGFnZS5nZXRTZXJwRW5naW5lKCl9XCJcbiAgICAgIFwiUmVwb3J0IENyZWF0ZWQ6ICN7bm93LnRvTG9jYWxlU3RyaW5nKCl9XCJcbiAgICAgICctLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nXG4gICAgICAnJ1xuICAgICAgW1xuICAgICAgICAnUG9zaXRpb24nLFxuICAgICAgICAnVVJMJyxcbiAgICAgICAgJ1RpdGxlJyxcbiAgICAgICAgJ0Rlc2NyaXB0aW9uJyxcbiAgICAgICAgJ1BhZ2UgQXV0aG9yaXR5JyxcbiAgICAgICAgJ1RvdGFsIExpbmtzIHRvIFBhZ2UnLFxuICAgICAgICAnVG90YWwgTGlua2luZyBSb290IERvbWFpbnMgdG8gUGFnZScsXG4gICAgICAgICdEb21haW4gQXV0aG9yaXR5JyxcbiAgICAgICAgJ1RvdGFsIExpbmtzIHRvIFJvb3QgRG9tYWluJyxcbiAgICAgICAgJ1RvdGFsIExpbmtpbmcgUm9vdCBEb21haW5zIHRvIFJvb3QgRG9tYWlucydcbiAgICAgIF1cbiAgICBdXG5cbiAgICAoJCBQYWdlLmdldFNlcnBDb25maWcoKS5zZWxlY3RvcikuZWFjaCAoaSwgZWwpID0+XG4gICAgICBtb2RlbCA9IG5ldyBTZXJwQXR0cmlidXRlcyBlbDogZWxcbiAgICAgIG1ldHJpY3MgPSBtb2RlbC5nZXQgJ21ldHJpY3MnXG4gICAgICBkYXRhLnB1c2ggW1xuICAgICAgICBpXG4gICAgICAgIG1vZGVsLmdldCAndXJsJ1xuICAgICAgICBAY3N2RW5jb2RlIG1vZGVsLmdldCAndGl0bGUnXG4gICAgICAgIEBjc3ZFbmNvZGUgbW9kZWwuZ2V0ICdkZXNjcmlwdGlvbidcbiAgICAgICAgbWV0cmljcy5nZXQgJ3VwYSdcbiAgICAgICAgbWV0cmljcy5nZXQgJ3VpZCdcbiAgICAgICAgbWV0cmljcy5nZXQgJ3VpcGwnXG4gICAgICAgIG1ldHJpY3MuZ2V0ICdwZGEnXG4gICAgICAgIG1ldHJpY3MuZ2V0ICdwdWlkJ1xuICAgICAgICBtZXRyaWNzLmdldCAncGlkJ1xuICAgICAgXVxuXG4gICAgZG9jID0gJydcbiAgICBmb3IgbGluZSBpbiBkYXRhXG4gICAgICBkb2MgKz0gXCIje2lmIF8uaXNBcnJheShsaW5lKSB0aGVuIGxpbmUuam9pbignLCcpIGVsc2UgbGluZX1cXG5cIlxuXG4gICAgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgJ2EnXG4gICAgYmxvYiA9IG5ldyBCbG9iIFtkb2NdLCB0eXBlOiAndGV4dC9jc3YnXG4gICAgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTCBibG9iXG5cbiAgICBhLnNldEF0dHJpYnV0ZSAnaHJlZicsIHVybFxuICAgIGEuc2V0QXR0cmlidXRlICdkb3dubG9hZCcsIEBnZXRDc3ZGaWxlbmFtZSgpXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCBhXG4gICAgYS5jbGljaygpXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCBhXG5cbiAgICBAYW5hbHl0aWNzLnRyYWNrRXhwb3J0KClcblxuICBjc3ZFbmNvZGU6IChzdHIpIC0+XG4gICAgIyByZXBsYWNlIGRvdWJsZSBxdW90ZXMgd2l0aCBkb3VibGUgZG91YmxlIHF1b3Rlc1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlIC9cXFwiL2csICdcIlwiJ1xuICAgICMgcXVvdGUgdGhlIHN0cmluZyBpZiBpdCBjb250YWlucyBxdW90ZXMgb3IgY29tbWFzXG4gICAgKHN0ciA9ICdcIicgKyBzdHIgKyAnXCInKSBpZiBzdHIuaW5kZXhPZignLCcpID4gLTEgb3Igc3RyLmluZGV4T2YoJ1wiJykgPiAtMVxuICAgIHJldHVybiBzdHJcblxuICBnZXRDc3ZGaWxlbmFtZTogLT5cbiAgICBub3cgPSBuZXcgRGF0ZSgpXG4gICAgZmlsZW5hbWUgPSBcIiN7UGFnZS5nZXRTZWFyY2hUZXJtKCl9LSN7UGFnZS5nZXRTZXJwRW5naW5lKCl9LVwiXG4gICAgZmlsZW5hbWUgKz0gbm93LmdldEZ1bGxZZWFyKCkgKyAnLSdcbiAgICBmaWxlbmFtZSArPSBAdHdvRGlnaXRzKG5vdy5nZXRNb250aCgpICsgMSkgKyAnLSdcbiAgICBmaWxlbmFtZSArPSBAdHdvRGlnaXRzKG5vdy5nZXREYXkoKSArIDEpICsgJy5jc3YnXG5cbiAgdHdvRGlnaXRzOiAobnVtKSAtPlxuICAgIChpZiBudW0gPCAxMCB0aGVuICcwJyBlbHNlICcnKSArIG51bVxuIiwiQmFzZURpYWxvZyA9IHJlcXVpcmUgJ3ZpZXdzL2Jhc2VfZGlhbG9nJ1xuU2V0dGluZ3NFZGl0ID0gcmVxdWlyZSAndmlld3Mvc2V0dGluZ3NfZWRpdCdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTZXR0aW5nc0RpYWxvZyBleHRlbmRzIEJhc2VEaWFsb2dcbiAgZWxlbWVudENzc0NsYXNzOiAnZGlhbG9nIHNldHRpbmdzLWRpYWxvZydcbiAgZWxlbWVudFZpZXdDbGFzczogU2V0dGluZ3NFZGl0XG5cbiAgaWQ6ICdtb3piYXItc2V0dGluZ3MtZGlhbG9nLSNyYW5kb20ta2V5J1xuXG4gIHJlbmRlcjogLT5cbiAgICBzdXBlclxuICAgIEAkZWwuY3NzXG4gICAgICB0b3A6IEBvcHRpb25zLnRvcFxuICAgICAgYm90dG9tOiBAb3B0aW9ucy5ib3R0b21cbiAgICAgIGxlZnQ6IEBvcHRpb25zLmxlZnQgLSBAJGVsLndpZHRoKCkgKyAyMFxuIiwiXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG4kID0gcmVxdWlyZSAnanF1ZXJ5J1xuQmFzZVZpZXcgPSByZXF1aXJlICd2aWV3cy9iYXNlX3ZpZXcnXG5QYWdlID0gcmVxdWlyZSAnbW9kZWxzL3BhZ2UnXG5Vc2VyID0gcmVxdWlyZSAnbW9kZWxzL3VzZXInXG5TZXR0aW5ncyA9IHJlcXVpcmUgJ21vZGVscy9zZXR0aW5ncydcbnRlbXBsYXRlID0gcmVxdWlyZSAndGVtcGxhdGVzL3NldHRpbmdzX2RpYWxvZydcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTZXR0aW5nc0VkaXQgZXh0ZW5kcyBCYXNlVmlld1xuICBzZXR0aW5nczogU2V0dGluZ3MuZ2V0SW5zdGFuY2UoKVxuICB1c2VyOiBVc2VyLmdldEluc3RhbmNlKClcblxuICBldmVudHM6XG4gICAgJ2NsaWNrIC5tZXRyaWNzIDpjaGVja2JveCc6ICd0b2dnbGVDb2wnXG4gICAgJ2NsaWNrICNsaWdodGRhcmtzd2l0Y2gnOiAndG9nZ2xlTGlnaHREYXJrJ1xuXG4gIHJlbmRlcjogLT5cbiAgICBwYWdlVXJsID0gZW5jb2RlVVJJQ29tcG9uZW50IFBhZ2UuaHJlZigpLnJlcGxhY2UgL15odHRwW3NdKjpcXC9cXC8vLCAnJ1xuXG4gICAgQCRlbC5odG1sIHRlbXBsYXRlIF8uZXh0ZW5kIHBhZ2VVcmw6IHBhZ2VVcmwsIEB1c2VyLnRvSlNPTigpXG5cbiAgICBjb2xzID0gQHNldHRpbmdzLmdldCAnbWV0cmljc0NvbHMnXG4gICAgQCRlbC5maW5kKCcubWV0cmljcyA6Y2hlY2tib3gnKS5lYWNoIC0+XG4gICAgICAkZWwgPSAoJCB0aGlzKVxuICAgICAgJGVsLnByb3AgJ2NoZWNrZWQnLCBjb2xzLmluZGV4T2YoJGVsLmRhdGEoJ2NvbCcpKSBpc250IC0xXG5cbiAgICBAJGVsLmZpbmQoJyNsaWdodGRhcmtzd2l0Y2gnKS5wcm9wICdjaGVja2VkJywgQHNldHRpbmdzLmdldCAnaXNMaWdodFRoZW1lJ1xuXG4gICAgKCQgJyNtb3piYXItc2V0dGluZ3MtZGlhbG9nLSNyYW5kb20ta2V5JylcbiAgICAgIC5oaWRlKClcbiAgICAgIC5zbGlkZURvd24gJ2Zhc3QnXG5cbiAgdG9nZ2xlQ29sOiAtPlxuICAgIGNvbHMgPSAkLm1hcCBAJGVsLmZpbmQoJzpjaGVja2VkJyksIChlbCkgLT4gKCQgZWwpLmRhdGEgJ2NvbCdcbiAgICBAc2V0dGluZ3Muc2V0ICdtZXRyaWNzQ29scycsIGNvbHNcbiAgICBAc2V0dGluZ3Muc2F2ZSgpXG5cbiAgdG9nZ2xlTGlnaHREYXJrOiAtPlxuICAgIEBzZXR0aW5ncy5zZXQgJ2lzTGlnaHRUaGVtZScsIEAkZWwuZmluZCgnI2xpZ2h0ZGFya3N3aXRjaCcpLmlzICc6Y2hlY2tlZCdcbiAgICBAc2V0dGluZ3Muc2F2ZSgpXG5cbiAgcmVtb3ZlOiAoY29tcGxldGUpIC0+XG4gICAgKCQgJyNtb3piYXItc2V0dGluZ3MtZGlhbG9nLSNyYW5kb20ta2V5Jykuc2xpZGVVcCAnZmFzdCcsID0+XG4gICAgICB0aGlzXG4gICAgICBzdXBlciBjb21wbGV0ZVxuIiwiXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG5CYXNlVmlldyA9IHJlcXVpcmUgJ3ZpZXdzL2Jhc2VfdmlldydcbnRlbXBsYXRlID0gcmVxdWlyZSAndGVtcGxhdGVzL3NvY2lhbCdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTb2NpYWxTdGF0cyBleHRlbmRzIEJhc2VWaWV3XG4gIGluaXRpYWxpemU6IChvcHRzKSAtPlxuICAgIHN1cGVyXG4gICAgQGxpc3RlblRvIEBtb2RlbCwgJ2NoYW5nZScsIEByZW5kZXJcblxuICByZW5kZXI6IC0+XG4gICAgQG1vZGVsLmZldGNoKCkgdW5sZXNzIEBtb2RlbC5pc1ZhbGlkKClcbiAgICBAJGVsLmh0bWwgdGVtcGxhdGUgQG1vZGVsLnRvSlNPTigpXG4gICAgQHRyaWdnZXIgJ3JlbmRlcidcbiIsIl8gPSByZXF1aXJlICd1bmRlcnNjb3JlJ1xuJCA9IHJlcXVpcmUgJ2pxdWVyeSdcbkFuYWx5dGljcyA9IHJlcXVpcmUgJ21vZGVscy9hbmFseXRpY3MnXG5CYXNlVmlldyA9IHJlcXVpcmUgJ3ZpZXdzL2Jhc2VfdmlldydcbkJ1dHRvbk5vdGlmaWNhdGlvbkVsZW1lbnQgPSByZXF1aXJlICd2aWV3cy9idXR0b25fbm90aWZpY2F0aW9uX2VsZW1lbnQnXG5QYWdlID0gcmVxdWlyZSAnbW9kZWxzL3BhZ2UnXG5QYWdlVG9vbGJhciA9IHJlcXVpcmUgJ3ZpZXdzL3BhZ2VfdG9vbGJhcidcblNlcnBUb29sYmFyID0gcmVxdWlyZSAndmlld3Mvc2VycF90b29sYmFyJ1xuU2VycFRvb2xiYXJNb2RlbCA9IHJlcXVpcmUgJ21vZGVscy9zZXJwX3Rvb2xiYXInXG5TZXR0aW5ncyA9IHJlcXVpcmUgJ21vZGVscy9zZXR0aW5ncydcblVybE1ldHJpY3MgPSByZXF1aXJlICdtb2RlbHMvdXJsX21ldHJpY3MnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgVG9vbGJhciBleHRlbmRzIEJhc2VWaWV3XG4gIGFuYWx5dGljczogQW5hbHl0aWNzLmdldEluc3RhbmNlKClcbiAgc2V0dGluZ3M6IFNldHRpbmdzLmdldEluc3RhbmNlKClcbiAgY29udGVudFBhZ2U6IG51bGxcbiAgdG9vbHRpcFBsYWNlbWVudDogJ2JlbG93J1xuXG4gIGV2ZW50czpcbiAgICAnY2xpY2sgLnNldHRpbmdzJzogJ3RvZ2dsZVNldHRpbmdzRGlhbG9nJ1xuICAgICdjbGljayAuaGVscCc6ICd0b2dnbGVIZWxwRGlhbG9nJ1xuICAgICdjbGljayAuZG9jayc6ICd0b2dnbGVEb2NrUG9zaXRpb24nXG4gICAgJ2NsaWNrIC5jbG9zZSc6ICdjbG9zZSdcblxuICBpbml0aWFsaXplOiAob3B0aW9ucykgLT5cbiAgICBzdXBlclxuXG4gICAgJHRvb2xiYXJQYW5lbCA9IEAkZWwuZmluZCAnLnRvb2xiYXItcGFuZWwnXG4gICAgcG9zaXRpb24gPSAkdG9vbGJhclBhbmVsLm9mZnNldCgpXG5cbiAgICBvcHRzID1cbiAgICAgIGhvc3Q6IG9wdGlvbnMuaG9zdFxuICAgICAgZWw6ICR0b29sYmFyUGFuZWxcbiAgICAgIG1hcmdpbjogcG9zaXRpb24ubGVmdCArXG4gICAgICAgIEAkZWwuZmluZCgncmlnaHQtcGFuZWwnKS5vdXRlcldpZHRoKClcblxuICAgIEBjaGlsZFZpZXcgPSBpZiBQYWdlLmlzU2VycCgpXG4gICAgICBuZXcgU2VycFRvb2xiYXIgXy5leHRlbmQgb3B0cywgbW9kZWw6IG5ldyBTZXJwVG9vbGJhck1vZGVsXG4gICAgZWxzZVxuICAgICAgbmV3IFBhZ2VUb29sYmFyIF8uZXh0ZW5kIG9wdHMsIG1vZGVsOiBVcmxNZXRyaWNzLmdldEluc3RhbmNlKClcblxuICByZW5kZXI6IC0+XG4gICAgQGNoaWxkVmlldy5yZW5kZXIoKVxuICAgIEB1cGRhdGVUb29sdGlwUGxhY2VtZW50KClcbiAgICBzdXBlclxuXG4gIHRvb2xiYXJIZWlnaHQ6IC0+XG4gICAgQCRlbC5maW5kKCcudG9vbGJhcicpLmhlaWdodCgpXG5cbiAgdG9nZ2xlU2V0dGluZ3NEaWFsb2c6IChlKSAtPlxuICAgIEBoaWRlVG9vbHRpcCgpXG4gICAgQGhvc3QudG9nZ2xlU2V0dGluZ3NEaWFsb2cgQGdldERpYWxvZ09wdGlvbnMgZVxuXG4gIHRvZ2dsZUhlbHBEaWFsb2c6IChlKSAtPlxuICAgIEBoaWRlVG9vbHRpcCgpXG4gICAgQGhvc3QudG9nZ2xlSGVscERpYWxvZyBAZ2V0RGlhbG9nT3B0aW9ucyBlXG5cbiAgZ2V0RGlhbG9nT3B0aW9uczogKGUpIC0+XG4gICAgJHRhcmdldCA9ICgkIGUuY3VycmVudFRhcmdldClcbiAgICBwb3NpdGlvbiA9ICR0YXJnZXQub2Zmc2V0KClcbiAgICBpc0RvY2tlZE9uQm90dG9tID0gQHNldHRpbmdzLmdldCAnaXNEb2NrZWRPbkJvdHRvbSdcbiAgICBoZWlnaHQgPSBAJGVsLmZpbmQoJy50b29sYmFyLXBhbmVsJykuaGVpZ2h0KClcblxuICAgIGxlZnQ6IHBvc2l0aW9uLmxlZnQgKyAoJHRhcmdldC53aWR0aCgpIC8gMilcbiAgICB0b3A6IGhlaWdodCB1bmxlc3MgaXNEb2NrZWRPbkJvdHRvbVxuICAgIGJvdHRvbTogaGVpZ2h0IGlmIGlzRG9ja2VkT25Cb3R0b21cbiAgICBhcnJvdzogaWYgaXNEb2NrZWRPbkJvdHRvbSB0aGVuICdib3R0b20nIGVsc2UgJ3RvcCdcblxuICB0b2dnbGVEb2NrUG9zaXRpb246IChlKSAtPlxuICAgIEBoaWRlVG9vbHRpcCgpXG4gICAgQHNldHRpbmdzLnRvZ2dsZURvY2tQb3NpdGlvbigpXG4gICAgQHVwZGF0ZVRvb2x0aXBQbGFjZW1lbnQoKVxuICAgIEBhbmFseXRpY3MudHJhY2tUb2dnbGVEb2NrUG9zaXRpb24oKVxuXG4gIHVwZGF0ZVRvb2x0aXBQbGFjZW1lbnQ6IC0+XG4gICAgaXNEb2NrZWRPbkJvdHRvbSA9IEBzZXR0aW5ncy5nZXQgJ2lzRG9ja2VkT25Cb3R0b20nXG4gICAgQHRvb2x0aXBQbGFjZW1lbnQgPSBpZiBpc0RvY2tlZE9uQm90dG9tIHRoZW4gJ2Fib3ZlJyBlbHNlICdiZWxvdydcbiAgICBAY2hpbGRWaWV3LnRvb2x0aXBQbGFjZW1lbnQgPSBAdG9vbHRpcFBsYWNlbWVudFxuXG4gIGNsb3NlQWxsUGFuZWxzOiAoZG9uZSkgLT5cbiAgICBpZiBAY2hpbGRWaWV3LmNsb3NlQWxsUGFuZWxzXG4gICAgICBAY2hpbGRWaWV3LmNsb3NlQWxsUGFuZWxzIGRvbmVcbiAgICBlbHNlXG4gICAgICBkb25lKClcblxuICBjbG9zZTogLT5cbiAgICBAc2V0dGluZ3MudG9nZ2xlTW96YmFyKClcbiAgICBAaGlkZVRvb2x0aXAoKVxuIiwiQmFzZVZpZXcgPSByZXF1aXJlICd2aWV3cy9iYXNlX3ZpZXcnXG50ZW1wbGF0ZSA9IHJlcXVpcmUgJ3RlbXBsYXRlcy90b29sdGlwJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBCYXNlVmlld1xuICBpbml0aWFsaXplOiAob3B0cykgLT5cbiAgICBzdXBlclxuICAgIEBsaXN0ZW5UbyBAbW9kZWwsICdjaGFuZ2UnLCBAcmVuZGVyXG5cbiAgcmVuZGVyOiAtPlxuICAgIEAkZWwuaHRtbCB0ZW1wbGF0ZSBAbW9kZWwudG9KU09OKClcbiIsIiQgPSByZXF1aXJlICdqcXVlcnknXG5CYXNlRWxlbWVudCA9IHJlcXVpcmUgJ3ZpZXdzL2Jhc2VfZWxlbWVudCdcbkRpc3BhdGNoZXIgPSByZXF1aXJlICd2aWV3cy9ldmVudF9kaXNwYXRjaGVyJ1xuVG9vbHRpcCA9IHJlcXVpcmUgJ3ZpZXdzL3Rvb2x0aXAnXG5Ub29sdGlwTW9kZWwgPSByZXF1aXJlICdtb2RlbHMvdG9vbHRpcCdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBUb29sdGlwRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50XG4gIFRPT0xUSVBfREVMQVk6IDI1MFxuICBUT09MVElQX1dJRFRIOiAyMDBcbiAgVE9PTFRJUF9IRUlHSFQ6IDIwMFxuXG4gIGRpc3BhdGNoZXI6IERpc3BhdGNoZXIuZ2V0SW5zdGFuY2UoKVxuICBlbGVtZW50Q3NzQ2xhc3M6ICd0b29sdGlwJ1xuICBlbGVtZW50Vmlld0NsYXNzOiBUb29sdGlwXG4gIGVsZW1lbnRWaWV3TW9kZWw6IG5ldyBUb29sdGlwTW9kZWxcbiAgdG9wOiAwXG4gIGxlZnQ6IDBcblxuICBpZDogJ21vemJhci10b29sdGlwLSNyYW5kb20ta2V5J1xuICB0aW1lb3V0OiBudWxsXG5cbiAgaW5pdGlhbGl6ZTogKG9wdHMpIC0+XG4gICAgc3VwZXJcbiAgICBAbGlzdGVuVG8gQGRpc3BhdGNoZXIsICd0b29sdGlwOnN0YXJ0LXRpbWVvdXQnLCBAc3RhcnRUaW1lb3V0XG4gICAgQGxpc3RlblRvIEBkaXNwYXRjaGVyLCAndG9vbHRpcDpoaWRlJywgQGhpZGVcblxuICBzdGFydFRpbWVvdXQ6IChvcHRzKSAtPlxuICAgIEBlbGVtZW50Vmlld01vZGVsLnNldCBvcHRzXG5cbiAgICBAdG9wID0gb3B0cy50b3BcbiAgICBAdG9wIC09IEBUT09MVElQX0hFSUdIVCBpZiBvcHRzLnBsYWNlbWVudCBpcyAnYWJvdmUnXG4gICAgQGxlZnQgPSBvcHRzLmxlZnRcblxuICAgIGNsZWFyVGltZW91dCBAdGltZW91dFxuICAgIEB0aW1lb3V0ID0gc2V0VGltZW91dCAoPT4gQHNob3coKSksIEBUT09MVElQX0RFTEFZXG5cbiAgc2hvdzogLT5cbiAgICBAcmVuZGVyKClcbiAgICBAJGVsLnNob3coKVxuICAgIEB1cGRhdGVQb3NpdGlvbigpXG5cbiAgcmVuZGVyU2hhZG93OiAoc2hhZG93LCBjc3MpIC0+XG4gICAgc3VwZXJcbiAgICBAdXBkYXRlUG9zaXRpb24oKVxuXG4gIHVwZGF0ZVBvc2l0aW9uOiAtPlxuICAgIEAkZWwuY3NzXG4gICAgICB0b3A6IEB0b3BcbiAgICAgIGxlZnQ6IEBsZWZ0IC0gQCRlbC53aWR0aCgpIC8gMlxuXG4gIGhpZGU6IC0+XG4gICAgY2xlYXJUaW1lb3V0IEB0aW1lb3V0XG4gICAgQCRlbC5oaWRlKClcbiIsIiQgPSByZXF1aXJlICdqcXVlcnknXG5CYXNlUGFuZWxUYWIgPSByZXF1aXJlICd2aWV3cy9iYXNlX3BhbmVsX3RhYidcbnRlbXBsYXRlID0gcmVxdWlyZSAndGVtcGxhdGVzL3R3aXR0ZXJfY2FyZHMnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgVHdpdHRlckNhcmRzIGV4dGVuZHMgQmFzZVBhbmVsVGFiXG4gIGNsYXNzTmFtZTogJ3R3aXR0ZXInXG4gIHRlbXBsYXRlOiB0ZW1wbGF0ZVxuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKGZ1bmN0aW9uIChIYW5kbGViYXJzLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgdGhpcy5jb21waWxlckluZm8gPSBbNCwnPj0gMS4wLjAnXTtcbmhlbHBlcnMgPSB0aGlzLm1lcmdlKGhlbHBlcnMsIEhhbmRsZWJhcnMuaGVscGVycyk7IGRhdGEgPSBkYXRhIHx8IHt9O1xuICBcblxuXG4gIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcImJhciBiYXIxXFxcIj48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJiYXIgYmFyMlxcXCI+PC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwiYmFyIGJhcjNcXFwiPjwvZGl2PlxcblwiO1xuICB9KTtcbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZShmdW5jdGlvbiAoSGFuZGxlYmFycyxkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHRoaXMuY29tcGlsZXJJbmZvID0gWzQsJz49IDEuMC4wJ107XG5oZWxwZXJzID0gdGhpcy5tZXJnZShoZWxwZXJzLCBIYW5kbGViYXJzLmhlbHBlcnMpOyBkYXRhID0gZGF0YSB8fCB7fTtcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMSwgaGVscGVyLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbjtcblxuXG4gIGJ1ZmZlciArPSBcIjxodG1sIGNsYXNzPVxcXCJcIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMuZWxlbWVudENzc0NsYXNzKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLmVsZW1lbnRDc3NDbGFzcyk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCJcXFwiPlxcbiAgPGJhc2UgdGFyZ2V0PSdfcGFyZW50Jz5cXG4gIDxoZWFkPlxcbiAgICA8c3R5bGU+XFxuICAgICAgYm9keSB7IGRpc3BsYXk6IG5vbmU7IH1cXG4gICAgPC9zdHlsZT5cXG4gIDwvaGVhZD5cXG4gIDxib2R5IGNsYXNzPVxcXCJcIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMuZWxlbWVudENzc0NsYXNzKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLmVsZW1lbnRDc3NDbGFzcyk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCJcXFwiPlxcbiAgICBcIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMuaHRtbCkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5odG1sKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIlxcbiAgPC9ib2R5PlxcbjwvaHRtbD5cXG5cIjtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfSk7XG4iLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoZnVuY3Rpb24gKEhhbmRsZWJhcnMsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICB0aGlzLmNvbXBpbGVySW5mbyA9IFs0LCc+PSAxLjAuMCddO1xuaGVscGVycyA9IHRoaXMubWVyZ2UoaGVscGVycywgSGFuZGxlYmFycy5oZWxwZXJzKTsgZGF0YSA9IGRhdGEgfHwge307XG4gIFxuXG5cbiAgcmV0dXJuIFwiPGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcImNsb3NlXFxcIj54PC9hPlxcbjxwPlxcbiAgPGVtPk1vekJhciBpcyBub3cgaW4gREEgbW9kZS48L2VtPlxcbiAgVG8gdHVybiBpdCBvZmYgY29tcGxldGVseSwgY2xpY2sgdGhlIDxpbWcgY2xhc3M9XFxcImljb25cXFwiPjwvaW1nPiB0byB0aGVcXG4gIHJpZ2h0IG9mIHRoZSBhZGRyZXNzIGJhclxcbjwvcD5cXG5cIjtcbiAgfSk7XG4iLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoZnVuY3Rpb24gKEhhbmRsZWJhcnMsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICB0aGlzLmNvbXBpbGVySW5mbyA9IFs0LCc+PSAxLjAuMCddO1xuaGVscGVycyA9IHRoaXMubWVyZ2UoaGVscGVycywgSGFuZGxlYmFycy5oZWxwZXJzKTsgZGF0YSA9IGRhdGEgfHwge307XG4gIFxuXG5cbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwiYXJyb3ctdXBcXFwiPjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcImNvbnRlbnRcXFwiPlxcblxcbiAgPGgyPkhlbHA8L2gyPlxcbiAgPGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcInRvdXJcXFwiPlR1cm4gb24gVHV0b3JpYWw8L2E+XFxuICA8YSBocmVmPVxcXCJodHRwOi8vbW96LmNvbS9oZWxwL2d1aWRlcy9yZXNlYXJjaC10b29scy9tb3piYXJcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5Nb3pCYXIgSGVscDwvYT5cXG4gIDxhIGhyZWY9XFxcImh0dHBzOi8vc2VvbW96LnplbmRlc2suY29tL2ZvcnVtcy8yOTMxOTQtTW96LUZlYXR1cmUtUmVxdWVzdHNcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5SZXF1ZXN0IGEgRmVhdHVyZTwvYT5cXG4gIDxhIGhyZWY9XFxcImh0dHA6Ly9tb3ouY29tL2FjYWRlbXlcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5Nb3ogQWNhZGVteTwvYT5cXG5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJhcnJvdy1kb3duXFxcIj48L2Rpdj5cXG5cIjtcbiAgfSk7XG4iLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoZnVuY3Rpb24gKEhhbmRsZWJhcnMsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICB0aGlzLmNvbXBpbGVySW5mbyA9IFs0LCc+PSAxLjAuMCddO1xuaGVscGVycyA9IHRoaXMubWVyZ2UoaGVscGVycywgSGFuZGxlYmFycy5oZWxwZXJzKTsgZGF0YSA9IGRhdGEgfHwge307XG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazEsIHNlbGY9dGhpcywgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb247XG5cbmZ1bmN0aW9uIHByb2dyYW0xKGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gXCJcIiwgc3RhY2sxLCBoZWxwZXI7XG4gIGJ1ZmZlciArPSBcIlxcbiAgICA8dHI+XFxuICAgICAgPHRkIGNsYXNzPVxcXCJ0YWcgXCI7XG4gIHN0YWNrMSA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgJiYgZGVwdGgwLmlzT2spLCB7aGFzaDp7fSxpbnZlcnNlOnNlbGYubm9vcCxmbjpzZWxmLnByb2dyYW0oMiwgcHJvZ3JhbTIsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxcIj48cD5cIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMuc3RhdHVzKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLnN0YXR1cyk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCI8L3A+PC90ZD5cXG4gICAgICA8dGQgY2xhc3M9XFxcInVybFxcXCI+PGEgaHJlZj1cXFwiXCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLnVybCkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC51cmwpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiXFxcIj5cIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMudXJsKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLnVybCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCI8L2E+PC90ZD5cXG4gICAgPC90cj5cXG4gICAgXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW0yKGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwib2tcIjtcbiAgfVxuXG4gIGJ1ZmZlciArPSBcIjx0YWJsZSBjbGFzcz1cXFwiaHR0cC1zdGF0dXNcXFwiPlxcbiAgPHRoZWFkPlxcbiAgICA8dHI+XFxuICAgICAgPHRkIGNsYXNzPVxcXCJ0YWdcXFwiPlN0YXR1cyBDb2RlPC90ZD5cXG4gICAgICA8dGQgY2xhc3M9XFxcInVybFxcXCI+VVJMPC90ZD5cXG4gICAgPC90cj5cXG4gIDwvdGhlYWQ+XFxuICA8dGJvZHkgY2xhc3M9XFxcInNjcm9sbGFibGVcXFwiPlxcbiAgICBcIjtcbiAgc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwLCBkZXB0aDAsIHtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbSgxLCBwcm9ncmFtMSwgZGF0YSksZGF0YTpkYXRhfSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCJcXG48L3RhYmxlPlxcblxcblwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9KTtcbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZShmdW5jdGlvbiAoSGFuZGxlYmFycyxkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHRoaXMuY29tcGlsZXJJbmZvID0gWzQsJz49IDEuMC4wJ107XG5oZWxwZXJzID0gdGhpcy5tZXJnZShoZWxwZXJzLCBIYW5kbGViYXJzLmhlbHBlcnMpOyBkYXRhID0gZGF0YSB8fCB7fTtcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMSwgaGVscGVyLCBzZWxmPXRoaXMsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uO1xuXG5mdW5jdGlvbiBwcm9ncmFtMShkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcIlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsb2dpblxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwicHJlbWl1bSBwdWxsLWxlZnRcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgIDxwPk1ldHJpY3MgYXJlIGF2YWlsYWJsZSB3aXRoIGEgcGFpZFxcbiAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uIHRvIE1vei4gIDxhIGhyZWY9XFxcImh0dHA6Ly9tb3ouY29tL3Byb2R1Y3RzXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+TGVhcm4gbW9yZTwvYT5cXG4gICAgICAgICAgICAgIG9yIDxhIGhyZWY9XFxcImh0dHA6Ly9tb3ouY29tL2xvZ2luXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+TG9naW48L2E+XFxuICAgICAgICAgICAgPC9wPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgXCI7XG4gIH1cblxuICBidWZmZXIgKz0gXCI8dGFibGUgY2xhc3M9XFxcImluYm91bmQtbGlua3NcXFwiPlxcbiAgPHRoZWFkPlxcbiAgICA8dHI+XFxuICAgICAgPHRkIGNsYXNzPVxcXCJ0YWdcXFwiPlBhZ2UgQXR0cmlidXRlczwvdGQ+XFxuICAgICAgPHRkIGNsYXNzPVxcXCJ1cmxcXFwiPlVSTDwvdGQ+XFxuICAgICAgPHRkIGNsYXNzPVxcXCJzdWJkb21haW5cXFwiPlN1YmRvbWFpbjwvdGQ+XFxuICAgICAgPHRkIGNsYXNzPVxcXCJyb290ZG9tYWluXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInJvb3Rkb21haW5cXFwiPlxcbiAgICAgICAgICBSb290IERvbWFpblxcblxcbiAgICAgICAgICBcIjtcbiAgc3RhY2sxID0gaGVscGVycy51bmxlc3MuY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAudXNlcikpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuaXNQcm8pLCB7aGFzaDp7fSxpbnZlcnNlOnNlbGYubm9vcCxmbjpzZWxmLnByb2dyYW0oMSwgcHJvZ3JhbTEsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L3RkPlxcbiAgICA8L3RyPlxcbiAgPC90aGVhZD5cXG4gIDx0Ym9keSBjbGFzcz1cXFwic2Nyb2xsYWJsZSBcIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAudXNlcikpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEubGV2ZWwpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpXG4gICAgKyBcIlxcXCI+XFxuICAgIDx0cj5cXG4gICAgICA8dGQgY2xhc3M9XFxcInRhZ1xcXCI+PHA+UGFnZSBBdXRob3JpdHkgKFBBKTwvcD48L3RkPlxcbiAgICAgIDx0ZCBjbGFzcz1cXFwidXJsXFxcIj48cD5cIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMubmljZVVwYSkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5uaWNlVXBhKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIjwvcD48L3RkPlxcbiAgICAgIDx0ZCBjbGFzcz1cXFwic3ViZG9tYWluXFxcIj48cD4tLTwvcD48L3RkPlxcbiAgICAgIDx0ZCBjbGFzcz1cXFwicm9vdGRvbWFpblxcXCI+PHA+LS08L3A+PC90ZD5cXG4gICAgPC90cj5cXG4gICAgPHRyPlxcbiAgICAgIDx0ZCBjbGFzcz1cXFwidGFnXFxcIj48cD5Eb21haW4gQXV0aG9yaXR5PC9wPjwvdGQ+XFxuICAgICAgPHRkIGNsYXNzPVxcXCJ1cmxcXFwiPjxwPi0tPC9wPjwvdGQ+XFxuICAgICAgPHRkIGNsYXNzPVxcXCJzdWJkb21haW5cXFwiPjxwPi0tPC9wPjwvdGQ+XFxuICAgICAgPHRkIGNsYXNzPVxcXCJyb290ZG9tYWluXFxcIj48cD5cIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMud2hvbGVQZGEpIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAud2hvbGVQZGEpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiPC9wPjwvdGQ+XFxuICAgIDwvdHI+XFxuICAgIDx0cj5cXG4gICAgICA8dGQgY2xhc3M9XFxcInRhZ1xcXCI+PHA+RXh0ZXJuYWwgRm9sbG93ZWQgTGlua3M8L3A+PC90ZD5cXG4gICAgICA8dGQgY2xhc3M9XFxcInVybFxcXCI+PHA+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLm5pY2VVZWlkKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLm5pY2VVZWlkKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIjwvcD48L3RkPlxcbiAgICAgIDx0ZCBjbGFzcz1cXFwic3ViZG9tYWluIHByZW1pdW1cXFwiPjxwPlwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5uaWNlRmVpZCkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5uaWNlRmVpZCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCI8L3A+PC90ZD5cXG4gICAgICA8dGQgY2xhc3M9XFxcInJvb3Rkb21haW4gcHJlbWl1bVxcXCI+PHA+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLm5pY2VQZWlkKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLm5pY2VQZWlkKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIjwvcD48L3RkPlxcbiAgICA8L3RyPlxcbiAgICA8dHI+XFxuICAgICAgPHRkIGNsYXNzPVxcXCJ0YWdcXFwiPjxwPkxpbmtpbmcgUm9vdCBEb21haW5zPC9wPjwvdGQ+XFxuICAgICAgPHRkIGNsYXNzPVxcXCJ1cmwgcHJlbWl1bVxcXCI+PHA+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLm5pY2VVaXBsKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLm5pY2VVaXBsKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIjwvcD48L3RkPlxcbiAgICAgIDx0ZCBjbGFzcz1cXFwic3ViZG9tYWluIHByZW1pdW1cXFwiPjxwPlwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5uaWNlRmlwbCkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5uaWNlRmlwbCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCI8L3A+PC90ZD5cXG4gICAgICA8dGQgY2xhc3M9XFxcInJvb3Rkb21haW4gcHJlbWl1bVxcXCI+PHA+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLm5pY2VQaWQpIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAubmljZVBpZCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCI8L3A+PC90ZD5cXG4gICAgPC90cj5cXG4gICAgPHRyPlxcbiAgICAgIDx0ZCBjbGFzcz1cXFwidGFnXFxcIj48cD5Nb3pSYW5rIChtUik8L3A+PC90ZD5cXG4gICAgICA8dGQgY2xhc3M9XFxcInVybFxcXCI+PHA+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLnVtcnApIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAudW1ycCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCI8L3A+PC90ZD5cXG4gICAgICA8dGQgY2xhc3M9XFxcInN1YmRvbWFpblxcXCI+PHA+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLmZtcnApIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAuZm1ycCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCIgKERtUik8L3A+PC90ZD5cXG4gICAgICA8dGQgY2xhc3M9XFxcInJvb3Rkb21haW4gcHJlbWl1bVxcXCI+PHA+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLnBtcnApIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAucG1ycCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCI8L3A+PC90ZD5cXG4gICAgPC90cj5cXG4gICAgPHRyPlxcbiAgICAgIDx0ZCBjbGFzcz1cXFwidGFnXFxcIj48cD5Nb3pUcnVzdCAobVQpPC9wPjwvdGQ+XFxuICAgICAgPHRkIGNsYXNzPVxcXCJ1cmxcXFwiPjxwPlwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy51dHJwKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLnV0cnApOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiPC9wPjwvdGQ+XFxuICAgICAgPHRkIGNsYXNzPVxcXCJzdWJkb21haW4gcHJlbWl1bVxcXCI+PHA+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLmZ0cnApIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAuZnRycCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCI8L3A+PC90ZD5cXG4gICAgICA8dGQgY2xhc3M9XFxcInJvb3Rkb21haW4gcHJlbWl1bVxcXCI+PHA+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLnB0cnApIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAucHRycCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCI8L3A+PC90ZD5cXG4gICAgPC90cj5cXG4gICAgPHRyPlxcbiAgICAgIDx0ZCBjbGFzcz1cXFwidGFnXFxcIj48cD5Ub3RhbCBMaW5rczwvcD48L3RkPlxcbiAgICAgIDx0ZCBjbGFzcz1cXFwidXJsXFxcIj48cD5cIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMubmljZVVpZCkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5uaWNlVWlkKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIjwvcD48L3RkPlxcbiAgICAgIDx0ZCBjbGFzcz1cXFwic3ViZG9tYWluIHByZW1pdW1cXFwiPjxwPlwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5uaWNlRnVpZCkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5uaWNlRnVpZCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCI8L3A+PC90ZD5cXG4gICAgICA8dGQgY2xhc3M9XFxcInJvb3Rkb21haW4gcHJlbWl1bVxcXCI+PHA+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLm5pY2VQdWlkKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLm5pY2VQdWlkKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIjwvcD48L3RkPlxcbiAgICA8L3RyPlxcbiAgPC90Ym9keT5cXG48L3RhYmxlPlxcblxcblwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9KTtcbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZShmdW5jdGlvbiAoSGFuZGxlYmFycyxkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHRoaXMuY29tcGlsZXJJbmZvID0gWzQsJz49IDEuMC4wJ107XG5oZWxwZXJzID0gdGhpcy5tZXJnZShoZWxwZXJzLCBIYW5kbGViYXJzLmhlbHBlcnMpOyBkYXRhID0gZGF0YSB8fCB7fTtcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMSwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb24sIHNlbGY9dGhpcztcblxuZnVuY3Rpb24gcHJvZ3JhbTEoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazEsIGhlbHBlcjtcbiAgYnVmZmVyICs9IFwiKDxzcGFuIGNsYXNzPSdzdGF0dXMtY29kZSc+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLnN0YXR1c0NvZGUpIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAuc3RhdHVzQ29kZSk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCI8L3NwYW4+KVwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbiAgYnVmZmVyICs9IFwiPHVsIGNsYXNzPVxcXCJ0YWJzXFxcIj5cXG4gIDxsaSBkYXRhLXRhYj1cXFwicGFnZS1lbGVtZW50c1xcXCI+T24tUGFnZSBFbGVtZW50czwvbGk+XFxuICA8bGkgZGF0YS10YWI9XFxcImdlbmVyYWwtYXR0cmlidXRlc1xcXCI+R2VuZXJhbCBBdHRyaWJ1dGVzPC9saT5cXG4gIDxsaSBkYXRhLXRhYj1cXFwiaW5ib3VuZC1saW5rc1xcXCI+TGluayBNZXRyaWNzPC9saT5cXG4gIDxsaSBkYXRhLXRhYj1cXFwic2VtYW50aWNzXFxcIj5NYXJrdXA8L2xpPlxcbiAgPGxpIGRhdGEtdGFiPVxcXCJodHRwLXN0YXR1c1xcXCI+XFxuICAgIEh0dHAgU3RhdHVzXFxuICAgIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzLnVubGVzcy5jYWxsKGRlcHRoMCwgKGRlcHRoMCAmJiBkZXB0aDAuaXNPayksIHtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbSgxLCBwcm9ncmFtMSwgZGF0YSksZGF0YTpkYXRhfSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCJcXG4gIDwvbGk+XFxuPC91bD5cXG5cXG48ZGl2IGNsYXNzPVxcXCJ0YWJcXFwiPjwvZGl2PlxcblxcbjxkaXYgY2xhc3M9XFxcImJ0biBleHBhbmRcXFwiPjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcImd1dHRlclxcXCI+PC9kaXY+XFxuXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH0pO1xuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKGZ1bmN0aW9uIChIYW5kbGViYXJzLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgdGhpcy5jb21waWxlckluZm8gPSBbNCwnPj0gMS4wLjAnXTtcbmhlbHBlcnMgPSB0aGlzLm1lcmdlKGhlbHBlcnMsIEhhbmRsZWJhcnMuaGVscGVycyk7IGRhdGEgPSBkYXRhIHx8IHt9O1xuICB2YXIgYnVmZmVyID0gXCJcIiwgc3RhY2sxLCBoZWxwZXIsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBzZWxmPXRoaXM7XG5cbmZ1bmN0aW9uIHByb2dyYW0xKGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gXCJcIiwgc3RhY2sxO1xuICBidWZmZXIgKz0gXCJcXG4gICAgICBcIjtcbiAgc3RhY2sxID0gaGVscGVycy51bmxlc3MuY2FsbChkZXB0aDAsIChkZXB0aDAgJiYgZGVwdGgwLmlzTG9hZGVkKSwge2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDIsIHByb2dyYW0yLCBkYXRhKSxkYXRhOmRhdGF9KTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcblxcbiAgICAgIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoZGVwdGgwICYmIGRlcHRoMC5pc0xvYWRlZCksIHtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbSg0LCBwcm9ncmFtNCwgZGF0YSksZGF0YTpkYXRhfSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCJcXG5cXG4gICAgICA8YSBocmVmPVxcXCJodHRwczovL21vei5jb20vcmVzZWFyY2h0b29scy9rZXl3b3JkLWRpZmZpY3VsdHlcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJ0biBrZXlcXFwiIGRhdGEtdG9vbHRpcD1cXFwiUnVuIEtleXdvcmQgQW5hbHlzaXNcXFwiLz5cXG4gICAgICA8L2E+XFxuICAgIFwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtMihkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcIlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImJ0biBhY3RpdmF0ZS1rZXl3b3JkLWRpZmZpY3VsdHlcXFwiXFxuICAgICAgICBkYXRhLXRvb2x0aXA9XFxcIk9idGFpbiAlIGFuZCBFc3RpbWF0ZWQgVm9sdW1lPGJyPm9mIGtleXdvcmQgZW50ZXJlZFxcXCI+XFxuICAgICAgICA8cD5HZXQgS2V5d29yZCBEaWZmaWN1bHR5PC9wPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwib25ib2FyZGluZy10ZXh0XFxcIj5cXG4gICAgICAgICAgR2V0IHRoZSBNb3ogPGVtPktleXdvcmQgRGlmZmljdWx0eSBTY29yZTwvZW0+IGZvciB0aGlzIGtleXdvcmQuXFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICBcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtNChkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMSwgaGVscGVyO1xuICBidWZmZXIgKz0gXCJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImxvYWRlZFxcXCI+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImRpZmZpY3VsdHlcXFwiXFxuICAgICAgICAgICAgZGF0YS10b29sdGlwPVxcXCJLZXl3b3JkIERpZmZpY3VsdHkgU2NvcmUgSGlnaGx5IENvbXBldGl0aXZlIVxcXCI+XFxuICAgICAgICAgICAgPHA+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLmRpZmZpY3VsdHkpIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAuZGlmZmljdWx0eSk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCIlPC9wPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIFwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW02KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiXFxuICAgICAgPGEgY2xhc3M9XFxcImxvZ2dlZC1vdXRcXFwiIGhyZWY9XFxcImh0dHBzOi8vbW96LmNvbS9wcm8vbW96YmFyP3V0bV9zb3VyY2U9bW96YmFyX3Rvb2xiYXImdXRtX21lZGl1bT1tb3piYXImdXRtX2NhbXBhaWduPW1vemJhcl9nZXRfcHJlbWl1bVxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPlxcbiAgICAgICAgR2V0IEtleXdvcmQgRGlmZmljdWx0eVxcbiAgICAgICAgd2l0aCBNb3pCYXIgUHJlbWl1bVxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiY3RhXFxcIj5cXG4gICAgICAgICAgVHJ5IEZyZWVcXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvYT5cXG4gICAgXCI7XG4gIH1cblxuICBidWZmZXIgKz0gXCI8c3R5bGU+XFxuXCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLmNzcykgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5jc3MpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiXFxuPC9zdHlsZT5cXG48ZGl2IGNsYXNzPVxcXCJtb3piYXItY3NzLSNyYW5kb20ta2V5XFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImtleXdvcmQtZGlmZmljdWx0eVxcXCI+XFxuICAgIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoZGVwdGgwICYmIGRlcHRoMC5pc1BybyksIHtoYXNoOnt9LGludmVyc2U6c2VsZi5wcm9ncmFtKDYsIHByb2dyYW02LCBkYXRhKSxmbjpzZWxmLnByb2dyYW0oMSwgcHJvZ3JhbTEsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxuICA8L2Rpdj5cXG48L2Rpdj5cXG5cIjtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfSk7XG4iLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoZnVuY3Rpb24gKEhhbmRsZWJhcnMsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICB0aGlzLmNvbXBpbGVySW5mbyA9IFs0LCc+PSAxLjAuMCddO1xuaGVscGVycyA9IHRoaXMubWVyZ2UoaGVscGVycywgSGFuZGxlYmFycy5oZWxwZXJzKTsgZGF0YSA9IGRhdGEgfHwge307XG4gIFxuXG5cbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwibGlua3MtcGFuZWxcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwibGluay10eXBlIGZvbGxvd2VkXFxcIiBkYXRhLXR5cGU9XFxcImZvbGxvd2VkXFxcIj5cXG4gICAgRm9sbG93ZWRcXG4gICAgPGRpdiBjbGFzcz1cXFwiYmFyXFxcIj48L2Rpdj5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwibGluay10eXBlIG5vLWZvbGxvd2VkXFxcIiBkYXRhLXR5cGU9XFxcIm5vLWZvbGxvd2VkXFxcIj5cXG4gICAgTm8tRm9sbG93ZWRcXG4gICAgPGRpdiBjbGFzcz1cXFwiYmFyXFxcIj48L2Rpdj5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwibGluay10eXBlIGV4dGVybmFsXFxcIiBkYXRhLXR5cGU9XFxcImV4dGVybmFsXFxcIj5cXG4gICAgRXh0ZXJuYWxcXG4gICAgPGRpdiBjbGFzcz1cXFwiYmFyXFxcIj48L2Rpdj5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwibGluay10eXBlIGludGVybmFsXFxcIiBkYXRhLXR5cGU9XFxcImludGVybmFsXFxcIj5cXG4gICAgSW50ZXJuYWxcXG4gICAgPGRpdiBjbGFzcz1cXFwiYmFyXFxcIj48L2Rpdj5cXG4gIDwvZGl2PlxcblxcbiAgPGRpdiBjbGFzcz1cXFwic2VhcmNoXFxcIj5cXG4gICAgPGlucHV0IG5hbWU9XFxcInNlYXJjaFxcXCIgLz5cXG4gIDwvZGl2PlxcblxcbiAgPGRpdiBjbGFzcz1cXFwibGluay10eXBlIGtleXdvcmRcXFwiIGRhdGEtdHlwZT1cXFwia2V5d29yZFxcXCI+XFxuICAgIEhpZ2hsaWdodFxcbiAgICA8ZGl2IGNsYXNzPVxcXCJiYXJcXFwiPjwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG4gIH0pO1xuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKGZ1bmN0aW9uIChIYW5kbGViYXJzLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgdGhpcy5jb21waWxlckluZm8gPSBbNCwnPj0gMS4wLjAnXTtcbmhlbHBlcnMgPSB0aGlzLm1lcmdlKGhlbHBlcnMsIEhhbmRsZWJhcnMuaGVscGVycyk7IGRhdGEgPSBkYXRhIHx8IHt9O1xuICBcblxuXG4gIHJldHVybiBcIlxcbjxkaXYgY2xhc3M9XFxcImNvbnRlbnQgcGFnZS1zZXJwLWludHJvLWFkZHJlc3MtYmFyXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImNsb3NlXFxcIj54PC9kaXY+XFxuICA8cD5UaGUgTW96QmFyIGFsc28gaGVscHMgeW91IGFuYWx5emUgU0VSUHMuIFNlYXJjaCBmb3IgYSBLZXl3b3JkIHRvIGxlYXJuIGhvdy48L3A+XFxuICA8cD5cXG4gICAgRm9yIGV4YW1wbGUgLSBzZWFyY2ggZm9yXFxuICAgIDxhIGhyZWY9XFxcImh0dHBzOi8vZ29vZ2xlLmNvbS9zZWFyY2g/cT1zZW8lMjB0b29sc1xcXCIgdGFyZ2V0PVxcXCJfdG9wXFxcIj5TRU8gVG9vbHM8L2E+XFxuICA8L3A+XFxuICA8ZGl2IGNsYXNzPVxcXCJmb290ZXJcXFwiPlxcbiAgICA8YSBocmVmPScjJyBjbGFzcz0nY2xvc2UnPk5vIHRoYW5rcyAtIGNsb3NlIHRoaXMgdHV0b3JpYWwuPC9hPlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXFxuPGRpdiBjbGFzcz1cXFwiY29udGVudCBzZXJwLXBhZ2UtaW50cm8tYWRkcmVzcy1iYXJcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiY2xvc2VcXFwiPng8L2Rpdj5cXG4gIDxwPlRoZSBNb3pCYXIgYWxzbyBoZWxwcyB5b3UgYW5hbHl6ZSBwYWdlcy4gRW50ZXIgYSBVUkwgdG8gbGVhcm4gaG93LjwvcD5cXG5cXG4gIDxwPlxcbiAgICBGb3IgZXhhbXBsZSAtIGFuYWx5emVcXG4gICAgPGEgaHJlZj1cXFwiaHR0cDovL21vei5jb21cXFwiIHRhcmdldD1cXFwiX3RvcFxcXCI+bW96LmNvbTwvYT5cXG4gIDwvcD5cXG4gIDxkaXYgY2xhc3M9XFxcImZvb3RlclxcXCI+XFxuICAgIDxhIGhyZWY9JyMnIGNsYXNzPSdjbG9zZSc+XFxuICAgICAgTm8gdGhhbmtzIC0gY2xvc2UgdGhpcyB0dXRvcmlhbC5cXG4gICAgPC9hPlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXFxuPGRpdiBjbGFzcz1cXFwiY29udGVudCBzZXJwLWhvdHNwb3RzIHBhZ2UtaG90c3BvdHNcXFwiPlxcbiAgPHA+VHVybiBvZmYgaG90c3BvdHMuPC9wPlxcbiAgPGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcImNsb3NlXFxcIj5cXG4gICAgPHNwYW4gY2xhc3M9XFxcImNsb3NlIHhcXFwiPng8L3NwYW4+XFxuICAgIENsb3NlIHRoaXMgdHV0b3JpYWwuXFxuICA8L2E+XFxuPC9kaXY+XFxuXCI7XG4gIH0pO1xuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKGZ1bmN0aW9uIChIYW5kbGViYXJzLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgdGhpcy5jb21waWxlckluZm8gPSBbNCwnPj0gMS4wLjAnXTtcbmhlbHBlcnMgPSB0aGlzLm1lcmdlKGhlbHBlcnMsIEhhbmRsZWJhcnMuaGVscGVycyk7IGRhdGEgPSBkYXRhIHx8IHt9O1xuICB2YXIgYnVmZmVyID0gXCJcIiwgc3RhY2sxLCBoZWxwZXIsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uO1xuXG5cbiAgYnVmZmVyICs9IFwiPGRpdiBjbGFzcz1cXFwiXCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLnBsYWNlbWVudCkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5wbGFjZW1lbnQpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImFycm93LXVwIFwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5sZWFuKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLmxlYW4pOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiXFxcIj48L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbnRlbnRcXFwiPjxwPlwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy50ZXh0KSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLnRleHQpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCI8L3A+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJhcnJvdy1kb3duIFwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5sZWFuKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLmxlYW4pOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiXFxcIj48L2Rpdj5cXG48L2Rpdj5cXG5cIjtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfSk7XG4iLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoZnVuY3Rpb24gKEhhbmRsZWJhcnMsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICB0aGlzLmNvbXBpbGVySW5mbyA9IFs0LCc+PSAxLjAuMCddO1xuaGVscGVycyA9IHRoaXMubWVyZ2UoaGVscGVycywgSGFuZGxlYmFycy5oZWxwZXJzKTsgZGF0YSA9IGRhdGEgfHwge307XG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazEsIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb24sIHNlbGY9dGhpcztcblxuZnVuY3Rpb24gcHJvZ3JhbTEoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazEsIGhlbHBlcjtcbiAgYnVmZmVyICs9IFwiXFxuICAgIDx0cj5cXG4gICAgICA8dGQgY2xhc3M9XFxcInRhZ1xcXCI+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLnRhZykgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC50YWcpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiPC90ZD5cXG4gICAgICA8dGQgY2xhc3M9XFxcImNvbnRlbnQgXCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLmNvbnRlbnRDbGFzcykgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5jb250ZW50Q2xhc3MpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiXFxcIj5cXG4gICAgICAgIDxwPlxcbiAgICAgICAgXCI7XG4gIHN0YWNrMSA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgJiYgZGVwdGgwLnVybCksIHtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbSgyLCBwcm9ncmFtMiwgZGF0YSksZGF0YTpkYXRhfSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCJcXG4gICAgICAgIFwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5jb250ZW50KSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLmNvbnRlbnQpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiXFxuICAgICAgICBcIjtcbiAgc3RhY2sxID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKGRlcHRoMCAmJiBkZXB0aDAudXJsKSwge2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDQsIHByb2dyYW00LCBkYXRhKSxkYXRhOmRhdGF9KTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcbiAgICAgICAgXCI7XG4gIHN0YWNrMSA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgJiYgZGVwdGgwLm11bHRpcGxlRXJyb3IpLCB7aGFzaDp7fSxpbnZlcnNlOnNlbGYubm9vcCxmbjpzZWxmLnByb2dyYW0oNiwgcHJvZ3JhbTYsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxuICAgICAgICA8L3A+XFxuICAgICAgPC90ZD5cXG4gICAgICBcIjtcbiAgc3RhY2sxID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKGRlcHRoMCAmJiBkZXB0aDAuc2hvd0xlbmd0aCksIHtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbSg4LCBwcm9ncmFtOCwgZGF0YSksZGF0YTpkYXRhfSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCJcXG4gICAgPC90cj5cXG4gICAgXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW0yKGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gXCJcIiwgc3RhY2sxLCBoZWxwZXI7XG4gIGJ1ZmZlciArPSBcIlxcbiAgICAgICAgICA8YSBocmVmPVxcXCJcIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMudXJsKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLnVybCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCJcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5cXG4gICAgICAgIFwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW00KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiXFxuICAgICAgICAgIDwvYT5cXG4gICAgICAgIFwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW02KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gXCJcIiwgc3RhY2sxLCBoZWxwZXI7XG4gIGJ1ZmZlciArPSBcIlxcbiAgICAgICAgICA8cCBjbGFzcz1cXFwiZXJyb3JcXFwiPk11bHRpcGxlIFwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy50YWcpIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAudGFnKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIiB0YWdzIGZvdW5kITwvcD5cXG4gICAgICAgIFwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW04KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gXCJcIiwgc3RhY2sxLCBoZWxwZXI7XG4gIGJ1ZmZlciArPSBcIlxcbiAgICAgICAgPHRkIGNsYXNzPVxcXCJjaGFyYWN0ZXJzXFxcIj5cIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMubGVuZ3RoKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLmxlbmd0aCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCI8L3RkPlxcbiAgICAgIFwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbiAgYnVmZmVyICs9IFwiPHRhYmxlIGNsYXNzPVxcXCJcIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMuY2xhc3NOYW1lKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLmNsYXNzTmFtZSk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCJcXFwiPlxcbiAgPHRoZWFkPlxcbiAgICA8dHI+XFxuICAgICAgPHRkIGNsYXNzPVxcXCJ0YWdcXFwiPlRhZy9Mb2NhdGlvbjwvdGQ+XFxuICAgICAgPHRkIGNsYXNzPVxcXCJjb250ZW50IFwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5jb250ZW50Q2xhc3MpIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAuY29udGVudENsYXNzKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIlxcXCI+Q29udGVudDwvdGQ+XFxuICAgICAgPHRkIGNsYXNzPVxcXCJjaGFyYWN0ZXJzXFxcIj4jIG9mIENoYXJhY3RlcnM8L3RkPlxcbiAgICA8L3RyPlxcbiAgPC90aGVhZD5cXG4gIDx0Ym9keSBjbGFzcz1cXFwic2Nyb2xsYWJsZVxcXCI+XFxuICAgIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChkZXB0aDAsIGRlcHRoMCwge2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDEsIHByb2dyYW0xLCBkYXRhKSxkYXRhOmRhdGF9KTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcbiAgPC90Ym9keT5cXG48L2Rpdj5cXG5cIjtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfSk7XG4iLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoZnVuY3Rpb24gKEhhbmRsZWJhcnMsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICB0aGlzLmNvbXBpbGVySW5mbyA9IFs0LCc+PSAxLjAuMCddO1xuaGVscGVycyA9IHRoaXMubWVyZ2UoaGVscGVycywgSGFuZGxlYmFycy5oZWxwZXJzKTsgcGFydGlhbHMgPSB0aGlzLm1lcmdlKHBhcnRpYWxzLCBIYW5kbGViYXJzLnBhcnRpYWxzKTsgZGF0YSA9IGRhdGEgfHwge307XG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazEsIGhlbHBlciwgb3B0aW9ucywgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb24sIHNlbGY9dGhpcywgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3Npbmc7XG5cbmZ1bmN0aW9uIHByb2dyYW0xKGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gXCJcIiwgc3RhY2sxLCBoZWxwZXI7XG4gIGJ1ZmZlciArPSBcIlxcbiAgPGRpdiBjbGFzcz1cXFwiYmFkZ2VcXFwiPlwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5zdGF0dXNDb2RlKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLnN0YXR1c0NvZGUpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiPC9kaXY+XFxuICBcIjtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMyhkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMSwgaGVscGVyO1xuICBidWZmZXIgKz0gXCJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInN0YXRcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0aXRsZVxcXCI+bVI6IFwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy51bXJwKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLnVtcnApOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiPC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNjYWxlLW91dGVyXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzY2FsZS1pbm5lclxcXCIgc3R5bGU9XFxcIndpZHRoOiBcIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMudW1ycFBjdCkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC51bXJwUGN0KTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIiVcXFwiPjwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTUoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazEsIGhlbHBlcjtcbiAgYnVmZmVyICs9IFwiXFxuICAgICAgPGRpdiBjbGFzcz1cXFwic3RhdFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0aXRsZVxcXCI+bVQ6IFwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy51dHJwKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLnV0cnApOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzY2FsZS1vdXRlclxcXCI+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNjYWxlLWlubmVyXFxcIiBzdHlsZT1cXFwid2lkdGg6IFwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy51dHJwUGN0KSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLnV0cnBQY3QpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiJVxcXCI+PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICBcIjtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtNyhkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMSwgaGVscGVyO1xuICBidWZmZXIgKz0gXCJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJsaW5rc1xcXCI+XFxuICAgICAgICA8YSBocmVmPVxcXCJodHRwOi8vbW96LmNvbS9yZXNlYXJjaHRvb2xzL29zZS9saW5rcz9zaXRlPVwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5wYWdlVXJsKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLnBhZ2VVcmwpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiJnNyYz1tYlxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPlxcbiAgICAgICAgICA8cCBjbGFzcz1cXFwibGluZVxcXCI+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLm5pY2VVaWQpIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAubmljZVVpZCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCIgbGlua3NcIjtcbiAgc3RhY2sxID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC51c2VyKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5pc1BybyksIHtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbSg4LCBwcm9ncmFtOCwgZGF0YSksZGF0YTpkYXRhfSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCI8L3A+XFxuICAgICAgICAgIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLnVzZXIpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmlzUHJvKSwge2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDEwLCBwcm9ncmFtMTAsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxuICAgICAgICA8L2E+XFxuICAgICAgPC9kaXY+XFxuICAgICAgXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW04KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiIGZyb21cIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMTAoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazEsIGhlbHBlcjtcbiAgYnVmZmVyICs9IFwiXFxuICAgICAgICAgIDxwIGNsYXNzPVxcXCJsaW5lXFxcIj5cIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMubmljZVVpcGwpIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAubmljZVVpcGwpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiIFJvb3QgRG9tYWluczwvcD5cXG4gICAgICAgICAgXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTEyKGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gXCJcIiwgc3RhY2sxLCBoZWxwZXI7XG4gIGJ1ZmZlciArPSBcIlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInN0YXRcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidGl0bGVcXFwiPkRtUjogXCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLnBtcnApIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAucG1ycCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCI8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInNjYWxlLW91dGVyIGFsdFxcXCI+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNjYWxlLWlubmVyIGFsdFxcXCIgc3R5bGU9XFxcIndpZHRoOiBcIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMucG1ycFBjdCkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5wbXJwUGN0KTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIiVcXFwiPjwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgICAgXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTE0KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gXCJcIiwgc3RhY2sxLCBoZWxwZXI7XG4gIGJ1ZmZlciArPSBcIlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInN0YXRcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidGl0bGVcXFwiPkRtVDogXCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLnB0cnApIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAucHRycCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCI8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInNjYWxlLW91dGVyIGFsdFxcXCI+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNjYWxlLWlubmVyIGFsdFxcXCIgc3R5bGU9XFxcIndpZHRoOiBcIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMucHRycFBjdCkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5wdHJwUGN0KTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIiVcXFwiPjwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgICAgXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTE2KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gXCJcIiwgc3RhY2sxO1xuICBidWZmZXIgKz0gXCJcXG4gICAgICBcIjtcbiAgc3RhY2sxID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC51c2VyKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5pc1BybyksIHtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbSgxNywgcHJvZ3JhbTE3LCBkYXRhKSxkYXRhOmRhdGF9KTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcbiAgICAgIFwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5mdW5jdGlvbiBwcm9ncmFtMTcoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazEsIGhlbHBlcjtcbiAgYnVmZmVyICs9IFwiXFxuICAgICAgPGRpdiBjbGFzcz1cXFwibGlua3NcXFwiPlxcbiAgICAgICAgPGEgaHJlZj1cXFwiaHR0cDovL21vei5jb20vcmVzZWFyY2h0b29scy9vc2UvbGlua3M/c2l0ZT1cIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMucm9vdERvbWFpbikgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5yb290RG9tYWluKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIiZzcmM9bWJcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5cXG4gICAgICAgICAgPHAgY2xhc3M9XFxcImxpbmVcXFwiPlwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5uaWNlUHVpZCkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5uaWNlUHVpZCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCIgbGlua3MgZnJvbTwvcD5cXG4gICAgICAgICAgPHAgY2xhc3M9XFxcImxpbmVcXFwiPlwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5uaWNlUGlkKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLm5pY2VQaWQpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiIFJvb3QgRG9tYWluczwvcD5cXG4gICAgICAgIDwvYT5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8aDM+U3ViZG9tYWluOjwvaDM+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwibGlua3NcXFwiPlxcbiAgICAgICAgPGEgaHJlZj1cXFwiaHR0cDovL21vei5jb20vcmVzZWFyY2h0b29scy9vc2UvbGlua3M/c2l0ZT1cIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMucGFnZVVybCkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5wYWdlVXJsKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIiZzcmM9bWJcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5cXG4gICAgICAgICAgPHAgY2xhc3M9XFxcImxpbmVcXFwiPlwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5uaWNlRnVpZCkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5uaWNlRnVpZCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCIgbGlua3MgZnJvbTwvcD5cXG4gICAgICAgICAgPHAgY2xhc3M9XFxcImxpbmVcXFwiPlwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5uaWNlRmlwbCkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5uaWNlRmlwbCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCIgUm9vdCBEb21haW5zPC9wPlxcbiAgICAgICAgPC9hPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIFwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xOShkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMTtcbiAgYnVmZmVyICs9IFwiXFxuICAgICAgPGRpdiBjbGFzcz1cXFwic3RhdFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0aXRsZVxcXCI+U3BhbTxiciAvPlNjb3JlOjwvZGl2PlxcbiAgICAgICAgXCI7XG4gIHN0YWNrMSA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgJiYgZGVwdGgwLm5vRnNwc2MpLCB7aGFzaDp7fSxpbnZlcnNlOnNlbGYucHJvZ3JhbSgyMiwgcHJvZ3JhbTIyLCBkYXRhKSxmbjpzZWxmLnByb2dyYW0oMjAsIHByb2dyYW0yMCwgZGF0YSksZGF0YTpkYXRhfSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCJcXG4gICAgICA8L2Rpdj5cXG4gICAgICBcIjtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuZnVuY3Rpb24gcHJvZ3JhbTIwKGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiXFxuICAgICAgICAgIDxkaXYgY2xhc3M9J2xpbmUnIGRhdGEtdG9vbHRpcD1cXFwiU3BhbSBzY29yZSBub3QgeWV0IGRldGVybWluZWQgZm9yIHRoaXMgZG9tYWluXFxcIj4tLTwvZGl2PlxcbiAgICAgICAgXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTIyKGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gXCJcIiwgc3RhY2sxLCBoZWxwZXI7XG4gIGJ1ZmZlciArPSBcIlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzY29yZVxcXCI+XFxuICAgICAgICAgICAgPGEgaHJlZj1cXFwiaHR0cHM6Ly9tb3ouY29tL3Jlc2VhcmNodG9vbHMvb3NlL3NwYW0tYW5hbHlzaXM/c2l0ZT1cIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMucm9vdERvbWFpbikgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5yb290RG9tYWluKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIiZ0YXJnZXQ9c3ViZG9tYWluJnNvdXJjZT1zdWJkb21haW4mcGFnZT0xJnNvcnQ9c3BhbV9zY29yZVxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPlxcbiAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcImxpbmVcXFwiPlwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5uaWNlRnNwc2MpIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAubmljZUZzcHNjKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIjwvcD5cXG4gICAgICAgICAgICA8L2E+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtZXRlclxcXCI+XFxuICAgICAgICAgICAgPGEgaHJlZj1cXFwiaHR0cHM6Ly9tb3ouY29tL3Jlc2VhcmNodG9vbHMvb3NlL3NwYW0tYW5hbHlzaXM/c2l0ZT1cIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMucm9vdERvbWFpbikgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5yb290RG9tYWluKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIiZ0YXJnZXQ9c3ViZG9tYWluJnNvdXJjZT1zdWJkb21haW4mcGFnZT0xJnNvcnQ9c3BhbV9zY29yZVxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPlxcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYmFyIGJhcjEgXCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLmJhcjFvbikgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5iYXIxb24pOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJhciBiYXIyIFwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5iYXIyb24pIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAuYmFyMm9uKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIlxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJiYXIgYmFyMyBcIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMuYmFyM29uKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLmJhcjNvbik7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCJcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICBcIjtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMjQoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJcXG4gIDxkaXYgY2xhc3M9XFxcInJpZ2h0LXBhbmVsXFxcIj5cXG4gICAgR2V0IGZ1bGwgYWNjZXNzIHRvIE1vekJhciBQcmVtaXVtIHdpdGggTW96IFByb1xcbiAgICA8YSBjbGFzcz1cXFwiY3RhIGxlYXJuLW1vcmVcXFwiIGhyZWY9XFxcImh0dHBzOi8vbW96LmNvbS9wcm8vbW96YmFyP3V0bV9zb3VyY2U9bW96YmFyX3Rvb2xiYXImdXRtX21lZGl1bT1tb3piYXImdXRtX2NhbXBhaWduPW1vemJhcl9nZXRfcHJlbWl1bVxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPlxcbiAgICAgIFRyeSBGcmVlXFxuICAgIDwvYT5cXG4gICAgb3JcXG4gICAgPGEgaHJlZj1cXFwiaHR0cDovL21vei5jb20vbG9naW5cXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5cXG4gICAgICBMb2cgaW5cXG4gICAgPC9hPlxcbiAgPC9kaXY+XFxuXCI7XG4gIH1cblxuICBidWZmZXIgKz0gXCI8ZGl2IGNsYXNzPVxcXCJidG4gc2hvdy1pbmZvLXBhbmVsXFxcIiBkYXRhLXRvb2x0aXA9XFxcIlBhZ2UgQW5hbHlzaXNcXFwiPlxcbiAgXCI7XG4gIHN0YWNrMSA9IHNlbGYuaW52b2tlUGFydGlhbChwYXJ0aWFsc1sncGFnZS1pbmZvLWljb24nXSwgJ3BhZ2UtaW5mby1pY29uJywgZGVwdGgwLCBoZWxwZXJzLCBwYXJ0aWFscywgZGF0YSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCJcXG5cXG4gIDxkaXYgY2xhc3M9XFxcIm9uYm9hcmRpbmctdGV4dFxcXCI+XFxuICAgIDxwPk9wZW4gdGhlIDxlbT5QYWdlIEFuYWx5c2lzIERyYXdlcjwvZW0+LjwvcD5cXG4gICAgPHA+XFxuICAgICAgR2V0IGluZm9ybWF0aW9uIGFuZCBhbmFseXNpcyBhYm91dCB0aGUgcGFnZSBzdHJ1Y3R1cmUgYW5kIG1hcmt1cCBhcyB3ZWxsIGFzIGJhY2tsaW5rIGRhdGEuXFxuICAgIDwvcD5cXG4gIDwvZGl2PlxcbiAgXCI7XG4gIHN0YWNrMSA9IGhlbHBlcnMudW5sZXNzLmNhbGwoZGVwdGgwLCAoZGVwdGgwICYmIGRlcHRoMC5pc09rKSwge2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDEsIHByb2dyYW0xLCBkYXRhKSxkYXRhOmRhdGF9KTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcbjwvZGl2PlxcblxcbjxkaXYgY2xhc3M9XFxcImJ0biBzaG93LWxpbmtzLXBhbmVsXFxcIiBkYXRhLXRvb2x0aXA9XFxcIkhpZ2hsaWdodCBMaW5rc1xcXCI+XFxuICBcIjtcbiAgc3RhY2sxID0gc2VsZi5pbnZva2VQYXJ0aWFsKHBhcnRpYWxzWydoaWdobGlnaHQtaWNvbiddLCAnaGlnaGxpZ2h0LWljb24nLCBkZXB0aDAsIGhlbHBlcnMsIHBhcnRpYWxzLCBkYXRhKTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcbiAgPGRpdiBjbGFzcz1cXFwib25ib2FyZGluZy10ZXh0XFxcIj5cXG4gICAgPHA+T3BlbiB0aGUgPGVtPkhpZ2hsaWdodGVyIFRvb2w8L2VtPi48L3A+XFxuICAgIDxwPlxcbiAgICAgIFNob3cgZm9sbG93ZWQgb3IgZXh0ZXJuYWwgbGlua3MsIGV2ZW4gY3VzdG9tIHRleHQuICBDbGljayBhZ2FpbiB0byBwdXQgaXQgYXdheS5cXG4gICAgPC9wPlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwiZGl2aWRlclxcXCI+PC9kaXY+XFxuPGRpdiBjbGFzcz1cXFwidmlld3BvcnRcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiZmFkZS1vdXRcXFwiPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwidmlld3BvcnQtY29udGVudHNcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwYWdlLXN0YXRzXFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJzdGF0LXN0YWNrXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInN0YXRcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0aXRsZVxcXCI+UEE6IFwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5uaWNlVXBhKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLm5pY2VVcGEpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiPC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNjYWxlLW91dGVyXFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzY2FsZS1pbm5lclxcXCIgc3R5bGU9XFxcIndpZHRoOiBcIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMubmljZVVwYSkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5uaWNlVXBhKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIiVcXFwiPjwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgXCI7XG4gIHN0YWNrMSA9IChoZWxwZXIgPSBoZWxwZXJzLmlmRGVmaW5lZCB8fCAoZGVwdGgwICYmIGRlcHRoMC5pZkRlZmluZWQpLG9wdGlvbnM9e2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDMsIHByb2dyYW0zLCBkYXRhKSxkYXRhOmRhdGF9LGhlbHBlciA/IGhlbHBlci5jYWxsKGRlcHRoMCwgKGRlcHRoMCAmJiBkZXB0aDAudW1ycCksIG9wdGlvbnMpIDogaGVscGVyTWlzc2luZy5jYWxsKGRlcHRoMCwgXCJpZkRlZmluZWRcIiwgKGRlcHRoMCAmJiBkZXB0aDAudW1ycCksIG9wdGlvbnMpKTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIFwiO1xuICBzdGFjazEgPSAoaGVscGVyID0gaGVscGVycy5pZkRlZmluZWQgfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWZEZWZpbmVkKSxvcHRpb25zPXtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbSg1LCBwcm9ncmFtNSwgZGF0YSksZGF0YTpkYXRhfSxoZWxwZXIgPyBoZWxwZXIuY2FsbChkZXB0aDAsIChkZXB0aDAgJiYgZGVwdGgwLnV0cnApLCBvcHRpb25zKSA6IGhlbHBlck1pc3NpbmcuY2FsbChkZXB0aDAsIFwiaWZEZWZpbmVkXCIsIChkZXB0aDAgJiYgZGVwdGgwLnV0cnApLCBvcHRpb25zKSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCJcXG4gICAgICBcIjtcbiAgc3RhY2sxID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKGRlcHRoMCAmJiBkZXB0aDAuc2hvd0xpbmtzKSwge2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDcsIHByb2dyYW03LCBkYXRhKSxkYXRhOmRhdGF9KTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInN0YXRcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidGl0bGVcXFwiPkRBOiBcIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMubmljZVBkYSkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5uaWNlUGRhKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIjwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwic2NhbGUtb3V0ZXIgYWx0XFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwic2NhbGUtaW5uZXIgYWx0XFxcIiBzdHlsZT1cXFwid2lkdGg6IFwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5uaWNlUGRhKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLm5pY2VQZGEpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiJVxcXCI+PC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICBcIjtcbiAgc3RhY2sxID0gKGhlbHBlciA9IGhlbHBlcnMuaWZEZWZpbmVkIHx8IChkZXB0aDAgJiYgZGVwdGgwLmlmRGVmaW5lZCksb3B0aW9ucz17aGFzaDp7fSxpbnZlcnNlOnNlbGYubm9vcCxmbjpzZWxmLnByb2dyYW0oMTIsIHByb2dyYW0xMiwgZGF0YSksZGF0YTpkYXRhfSxoZWxwZXIgPyBoZWxwZXIuY2FsbChkZXB0aDAsIChkZXB0aDAgJiYgZGVwdGgwLnBtcnApLCBvcHRpb25zKSA6IGhlbHBlck1pc3NpbmcuY2FsbChkZXB0aDAsIFwiaWZEZWZpbmVkXCIsIChkZXB0aDAgJiYgZGVwdGgwLnBtcnApLCBvcHRpb25zKSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCJcXG4gICAgICBcIjtcbiAgc3RhY2sxID0gKGhlbHBlciA9IGhlbHBlcnMuaWZEZWZpbmVkIHx8IChkZXB0aDAgJiYgZGVwdGgwLmlmRGVmaW5lZCksb3B0aW9ucz17aGFzaDp7fSxpbnZlcnNlOnNlbGYubm9vcCxmbjpzZWxmLnByb2dyYW0oMTQsIHByb2dyYW0xNCwgZGF0YSksZGF0YTpkYXRhfSxoZWxwZXIgPyBoZWxwZXIuY2FsbChkZXB0aDAsIChkZXB0aDAgJiYgZGVwdGgwLnB0cnApLCBvcHRpb25zKSA6IGhlbHBlck1pc3NpbmcuY2FsbChkZXB0aDAsIFwiaWZEZWZpbmVkXCIsIChkZXB0aDAgJiYgZGVwdGgwLnB0cnApLCBvcHRpb25zKSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCJcXG4gICAgICBcIjtcbiAgc3RhY2sxID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKGRlcHRoMCAmJiBkZXB0aDAuc2hvd0xpbmtzKSwge2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDE2LCBwcm9ncmFtMTYsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxuXFxuICAgICAgXCI7XG4gIHN0YWNrMSA9IChoZWxwZXIgPSBoZWxwZXJzLmlmRGVmaW5lZCB8fCAoZGVwdGgwICYmIGRlcHRoMC5pZkRlZmluZWQpLG9wdGlvbnM9e2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDE5LCBwcm9ncmFtMTksIGRhdGEpLGRhdGE6ZGF0YX0saGVscGVyID8gaGVscGVyLmNhbGwoZGVwdGgwLCAoZGVwdGgwICYmIGRlcHRoMC5mc3BzYyksIG9wdGlvbnMpIDogaGVscGVyTWlzc2luZy5jYWxsKGRlcHRoMCwgXCJpZkRlZmluZWRcIiwgKGRlcHRoMCAmJiBkZXB0aDAuZnNwc2MpLCBvcHRpb25zKSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCJcXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInNvY2lhbC1zdGF0c1xcXCI+PC9kaXY+XFxuXFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcImZhZGUtaW5cXFwiPjwvZGl2PlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInNjcm9sbC1hcnJvd3NcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwibGVmdC1hcnJvd1xcXCI+Jmx0OzwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwicmlnaHQtYXJyb3cgZW5hYmxlZFxcXCI+Jmd0OzwvZGl2PlxcbjwvZGl2PlxcblxcblwiO1xuICBzdGFjazEgPSBoZWxwZXJzLnVubGVzcy5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC51c2VyKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5pc1BybyksIHtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbSgyNCwgcHJvZ3JhbTI0LCBkYXRhKSxkYXRhOmRhdGF9KTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcblwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9KTtcbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZShmdW5jdGlvbiAoSGFuZGxlYmFycyxkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHRoaXMuY29tcGlsZXJJbmZvID0gWzQsJz49IDEuMC4wJ107XG5oZWxwZXJzID0gdGhpcy5tZXJnZShoZWxwZXJzLCBIYW5kbGViYXJzLmhlbHBlcnMpOyBkYXRhID0gZGF0YSB8fCB7fTtcbiAgXG5cblxuICByZXR1cm4gXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG4gIDxjaXJjbGUgY3g9XFxcIjEyXFxcIiBjeT1cXFwiMTJcXFwiIHI9XFxcIjEyXFxcIi8+XFxuICA8dGV4dCB4PVxcXCI5LjVcXFwiIHk9XFxcIjguNzVcXFwiIHRyYW5zZm9ybT1cXFwicm90YXRlKDQ1KVxcXCIgZm9udC1zaXplPVxcXCIyNlxcXCIgZm9udC13ZWlnaHQ9XFxcImJvbGRcXFwiIGZvbnQtZmFtaWx5PVxcXCJPcGVuIFNhbnMsIHNhbnMtc2VyaWZcXFwiPlxcbiAgICA8dHNwYW4+KzwvdHNwYW4+XFxuICA8L3RleHQ+XFxuPC9zdmc+XFxuXCI7XG4gIH0pO1xuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKGZ1bmN0aW9uIChIYW5kbGViYXJzLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgdGhpcy5jb21waWxlckluZm8gPSBbNCwnPj0gMS4wLjAnXTtcbmhlbHBlcnMgPSB0aGlzLm1lcmdlKGhlbHBlcnMsIEhhbmRsZWJhcnMuaGVscGVycyk7IGRhdGEgPSBkYXRhIHx8IHt9O1xuICBcblxuXG4gIHJldHVybiBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjEgNDhcXFwiPlxcbiAgPHBhdGggZD1cXFwiTTI0LjExMiAyMS4xMTJoLTI0di0xMmg0OHYxMmgtMjR6bTAtMThoLTI0di0zaDQ4djNoLTI0elxcXCIvPlxcbjwvc3ZnPlxcblwiO1xuICB9KTtcbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZShmdW5jdGlvbiAoSGFuZGxlYmFycyxkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHRoaXMuY29tcGlsZXJJbmZvID0gWzQsJz49IDEuMC4wJ107XG5oZWxwZXJzID0gdGhpcy5tZXJnZShoZWxwZXJzLCBIYW5kbGViYXJzLmhlbHBlcnMpOyBkYXRhID0gZGF0YSB8fCB7fTtcbiAgXG5cblxuICByZXR1cm4gXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgdmlld0JveD1cXFwiMCAwIDQ4IDYwXFxcIj5cXG4gIDxwYXRoIGQ9XFxcIk00MCA0OC40MDdIMjB2LTE0aDR2MTBoMzJ2LTMwSDQ0di0xMEgyNHYxNWgtNHYtMTloMzIuNTQ0bDMuNzI4IDMuMDczTDYwIDYuNTUydjQxLjg1NUg0MHptMTItMzhjMi4yIDAgNC0uMjQ3IDQtLjU0OCAwLS4zMDQtMS4yMzctMS42NC0yLjc1LTIuOTctMS41MTMtMS4zMy0zLjMxMy0yLjQzNS00LTIuNDUzTDQ4IDQuNDA3djZoNHptLTQwLjc4OCAyN0g5LjQyNWwtNC43MTMtNC43ODVMMCAyNy44Mzh2LTIuNjA2bDQuNzUtNC4zNzMgNC43NS00LjM3NSAxLjc1LS4wNCAxLjc1LS4wNHYzLjQyNWwtMi43NSAyLjI1LTIuNzUgMi4yNTMgMTQuNjkuMDM2IDE0LjY5Mi4wMzYuNjQ1IDEuMDQ0LjY0NSAxLjA0NC0xLjIwOCAxLjQ1Ny0xLjIxIDEuNDU4SDcuNzNsMi42MzUgMi4wNzJMMTMgMzMuNTV2My44NTRoLTEuNzg4elxcXCIvPlxcbjwvc3ZnPlxcblwiO1xuICB9KTtcbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZShmdW5jdGlvbiAoSGFuZGxlYmFycyxkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHRoaXMuY29tcGlsZXJJbmZvID0gWzQsJz49IDEuMC4wJ107XG5oZWxwZXJzID0gdGhpcy5tZXJnZShoZWxwZXJzLCBIYW5kbGViYXJzLmhlbHBlcnMpOyBkYXRhID0gZGF0YSB8fCB7fTtcbiAgXG5cblxuICByZXR1cm4gXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgdmlld0JveD1cXFwiMCAwIDY5LjI4NyA3Mi40NFxcXCI+XFxuICA8cGF0aCBkPVxcXCJNMi45MzMgNjkuMjJsLTEuNzgyLjA2Ny0uNTc0LTEuNS0uNTc2LTEuNSAzLjM1Ny05Ljg2MyAzLjM1Ny05Ljg2NCAyMy4zMjgtMjIuMzg2TDUzLjM3IDEuNzg3bDIuMjgtLjg5M0w1Ny45MzQgMGwyLjYyMi42NTggMi42MjIuNjU4IDMuMzk1IDIuOTggMy4zOTUgMi45ODIgMS4yMzcgMi45ODUgMS4yMzYgMi45ODUtLjU5NiAyLjI3LS41OTcgMi4yNy0yNC4xMDggMjMtMjQuMTEgMjMtOS4xNTggMi42ODNjLTUuMDM3IDEuNDc2LTkuOTYgMi43MTQtMTAuOTQgMi43NXptOC4zLTcuOTM4YzEuNzg4LS41MTMgMy40MTUtMS4wOTUgMy42MTMtMS4yOTMuMTk4LS4yLS43Ni0xLjQxNS0yLjEzMi0yLjcwM0MxMS4zNDQgNTYgMTAgNTUuMTY3IDkuNzI4IDU1LjQ0Yy0uMjcuMjctLjc3NiAxLjkwNy0xLjEyIDMuNjM0bC0uNjMgMy4xNCAzLjI1NC0uOTMyem05LjkzNC00LjA0NmMuMy0uMDI4IDguODcyLTguMTE1IDE5LjA0Ny0xNy45N2wxOC41LTE3LjkyMi00LjE3My00LjE4Ni00LjE3LTQuMTg2LTE4LjU4IDE3LjgzNWMtMTAuMjE2IDkuODEtMTguNTc2IDE4LjA3NC0xOC41NzYgMTguMzY2IDAgLjI5IDEuNjY2IDIuMjM2IDMuNzAzIDQuMzIyIDIuMDM2IDIuMDg2IDMuOTUgMy43NyA0LjI1IDMuNzR6bTQyLjEyNy00MC45NWMuMzcgMCAxLjIzMy0uNjcgMS45MTYtMS40OTRsMS4yNC0xLjQ5NS0xLjY3LTIuNTUtMS42NzItMi41NS0yLjQxNy0xLjEwMi0yLjQxNy0xLjEwMkw1Ni42OTcgNy4zbC0xLjU3NSAxLjMxIDMuNzUgMy44MzhjMi4wNiAyLjExMiA0LjA1IDMuODQgNC40MjIgMy44NHpcXFwiLz5cXG48L3N2Zz5cXG5cIjtcbiAgfSk7XG4iLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoZnVuY3Rpb24gKEhhbmRsZWJhcnMsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICB0aGlzLmNvbXBpbGVySW5mbyA9IFs0LCc+PSAxLjAuMCddO1xuaGVscGVycyA9IHRoaXMubWVyZ2UoaGVscGVycywgSGFuZGxlYmFycy5oZWxwZXJzKTsgZGF0YSA9IGRhdGEgfHwge307XG4gIFxuXG5cbiAgcmV0dXJuIFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHZpZXdCb3g9XFxcIjAgMCAyOC4wNzEgMjEuMlxcXCI+XFxuICA8cGF0aCBkPVxcXCJNMi40MzUgMjcuNDJsLTEuMTkyLS41NzgtLjYyLTEuMzY0TDAgMjQuMTE0VjEyLjUzbDEuMjU1LS4xNzggMS4yNTYtLjE4LjMyNS0zLjc3NS4zMjQtMy43NzcgMS42MDQtMS42NzVMNi4zNyAxLjI2OCA4LjQ4NC42MzQgMTAuNiAwbDIuMTE1LjYzNCAyLjExNi42MzQgMS42MDYgMS42NzUgMS42MDUgMS42NzUuMzI1IDMuNzc3LjMyNCAzLjc3NiAxLjI1NS4xOCAxLjI1NS4xNzh2MTEuNTg3bC0uNjIgMS4zNi0uNjIgMS4zNi0xLjM1OC42MTgtMS4zNi42Mi02LjgwOC0uMDM4LTYuODA4LS4wMzgtMS4xOS0uNTc3ek0xOC4zIDI1LjE3bC42NjgtLjY3VjE0LjEyNUgyLjIzMnYxMC4zNzhsLjY3LjY2OC42Ny42N0gxNy42M2wuNjctLjY3ek04LjEzNiAyMi41NDVsLS45NjMtMS4wNjQuMTgtMS44NDcuMTc4LTEuODQ4IDEuNTM0LS44NTQgMS41MzQtLjg1MyAxLjUzNC44NTQgMS41MzQuODU1LjE4IDEuODQ4LjE3OCAxLjg0OC0uOTYzIDEuMDY1LS45NjIgMS4wNjNoLTNsLS45NjMtMS4wNjN6bTMuODI3LTEuNjc2bC4zMTMtLjUwOC0uMzQtLjg4OC0uMzQtLjg4N0g5LjYwM2wtLjM0Ljg4Ny0uMzQuODg4LjMxMi41MDcuMzE0LjUwN2gyLjFsLjMxNC0uNTA4em00LjY4My0xMC4zNjJsLjE5LTEuNjY0LS42MjItMi4wNzItLjYyLTIuMDcyLTEuNDU3LTEuMTQ2LTEuNDU3LTEuMTQ2SDguNjE4bC0xLjMuOTEtMS4yOTguOTEtLjc4IDEuODYyLS43NzcgMS44NnYxLjg4YzAgMS4wMzIuMTc2IDIuMDUyLjM5IDIuMjY3bC4zOS4zOSA1LjYwOC0uMTU4IDUuNjA4LS4xNi4xOS0xLjY2MnpcXFwiLz5cXG48L3N2Zz5cXG5cIjtcbiAgfSk7XG4iLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoZnVuY3Rpb24gKEhhbmRsZWJhcnMsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICB0aGlzLmNvbXBpbGVySW5mbyA9IFs0LCc+PSAxLjAuMCddO1xuaGVscGVycyA9IHRoaXMubWVyZ2UoaGVscGVycywgSGFuZGxlYmFycy5oZWxwZXJzKTsgZGF0YSA9IGRhdGEgfHwge307XG4gIFxuXG5cbiAgcmV0dXJuIFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHZpZXdCb3g9XFxcIjAgMCA2MiA2MlxcXCI+XFxuICA8cGF0aCBkPVxcXCJNMjkuMzE2IDU5LjM3OGwtLjg5Ny0yLjM2LTMuOTA4LS42MjUtMy45MDYtLjYyNC00LjE2OC0zLjAyLTQuMTY4LTMuMDItMy4wMi00LjE2OC0zLjAyLTQuMTY4LS42MjMtMy45MDYtLjYyNS0zLjkwNy0yLjM2LS44OTYtMi4zNi0uODk3di0yLjFsMi4zNi0uODk2IDIuMzYtLjg5Ny42MjUtMy45MDYuNjI0LTMuOTA3IDMuMDItNC4xNjcgMy4wMi00LjE2OCA0LjE2OC0zLjAyIDQuMTY4LTMuMDIgMy45MDYtLjYyNCAzLjkwNy0uNjIzLjg5Ni0yLjM2Ljg5Ny0yLjM2aDIuMWwuODk2IDIuMzYuODk3IDIuMzYgMy45MDYuNjI0IDMuOTA2LjYyNiA0LjE2NyAzLjAyIDQuMTY4IDMuMDIgMy4wMiA0LjE2NyAzLjAyIDQuMTY3LjYyNCAzLjkwNy42MjMgMy45MDYgMi4zNi44OTggMi4zNi44OTh2Mi4xbC0yLjM2Ljg5Ni0yLjM2Ljg5Ny0uNjI0IDMuOTA4LS42MjYgMy45MDYtMy4wMiA0LjE2OC0zLjAyIDQuMTY4LTQuMTY3IDMuMDItNC4xNjggMy4wMi0zLjkwNy42MjMtMy45MDYuNjI1LS44OTggMi4zNi0uODk4IDIuMzZoLTIuMWwtLjg5Ni0yLjM2em0xMC45NjctMTAuMTY2YzUuNzEzLTIuOTIgMTAuMjA2LTkuMDYzIDExLjMyLTE1LjQ3NWwuNjEtMy41LS44ODItMy44LS44OC0zLjgwMi0yLjI1My0zLjI5LTIuMjU0LTMuMjg4LTMuMjktMi4yNTUtMy4yOTItMi4yNTUtNC4wNDgtLjkxLTQuMDUtLjkxLTQuMDQ4LjkxLTQuMDUuOTEtMy4yOSAyLjI1NS0zLjI5MiAyLjI1NS0yLjI1NSAzLjI5LTIuMjU1IDMuMjkyLS45MSA0LjA0OC0uOTEgNC4wNS45MSA0LjA0OC45MSA0LjA1IDIuMjU1IDMuMjkgMi4yNTUgMy4yOTIgMy4zMzUgMi4yODVjMS44MzQgMS4yNTYgNC44IDIuNjQyIDYuNTkgMy4wOGwzLjI1Ni43OTMgNC0uNTM4YzIuMi0uMjk1IDUuMTM0LTEuMTE3IDYuNTItMS44MjZ6bS0yMC4wMi02LjMzNGMwLS40NzIgMS41MzctNC4xODUgMy40MTctOC4yNWwzLjQxNy03LjM5IDYuNDc0LTQuNzVjNi4yNjYtNC41OTcgOC42OTMtNS42ODMgOC42OTMtMy44OTIgMCAuNDczLTEuNTM4IDQuMTg1LTMuNDE3IDguMjVsLTMuNDE3IDcuMzktNi40NzYgNC43NWMtNi4yNjUgNC41OTgtOC42OSA1LjY4NC04LjY5IDMuODkyek0zNS4zMSAyNy42NTJsMS4xMTUtMi4wODYtLjU3NS0uNTc1LS41NzUtLjU3NC0xLjk4MyAxLjc5NC0xLjk4MiAxLjc5NS41MzUuODY2Yy45MDIgMS40NiAyLjI5Mi45NyAzLjQ2NC0xLjIxOHpcXFwiLz5cXG4gIDwvc3ZnPlxcblwiO1xuICB9KTtcbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZShmdW5jdGlvbiAoSGFuZGxlYmFycyxkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHRoaXMuY29tcGlsZXJJbmZvID0gWzQsJz49IDEuMC4wJ107XG5oZWxwZXJzID0gdGhpcy5tZXJnZShoZWxwZXJzLCBIYW5kbGViYXJzLmhlbHBlcnMpOyBkYXRhID0gZGF0YSB8fCB7fTtcbiAgXG5cblxuICByZXR1cm4gXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgdmlld0JveD1cXFwiMCAwIDI4IDI4XFxcIj5cXG4gIDxwYXRoIGQ9XFxcIk0yNy4wODQgMjcuODc0bC0uNDU4LS4wMDMtMi40NzItMi4yNDUtMi40Ny0yLjI0Ni0xLjQxNi43LTEuNDE2LjdoLTQuMDg0bC0xLjYtLjc3NS0xLjYtLjc3NEgwVjBoMjEuNDQ0djExLjQxMmwuNjguMzYzLjY4LjM2NEwyMy43MyAxNGwuOTI4IDEuODY0djMuMjA4bC0uNzM3IDEuNTI0LS43MzggMS41MjMgMi40MDcgMi4yODJMMjggMjYuNjgybC0uMjMuNTk4LS4yMjguNTk3LS40NTgtLjAwM3pNMTcuNSAyMy4wMTdjLjY4LS4xMTMgMS42NjctLjQyNyAyLjE5LS42OTguNTI1LS4yNzIgMS4zNy0uOTg2IDEuODc2LTEuNTlsLjkyMi0xLjA5NC4yNC0xLjI3NS4yMzgtMS4yNzQtLjQwOC0xLjM2Mi0uNDA4LTEuMzYyLTEuMjQyLTEuMDktMS4yNDItMS4wOS0xLjQzNC0uMzg3LTEuNDM0LS4zODYtMS40MzUuMzg1LTEuNDM0LjM4Ny0xLjI0MyAxLjA5LTEuMjQgMS4wOS0uNDEgMS4zNjItLjQwOCAxLjM2Mi4yNDYgMS4zMTQuMjQ2IDEuMzE0IDEuMTQgMS4yMzcgMS4xNCAxLjIzOCAxLjQzLjUxOCAxLjQzLjUxNyAxLjIzOC0uMjA2ek01Ljg4IDIxLjQ0NGg0LjA5bC0uNTE3LTEuMjRjLS4yODUtLjY4LS41MTgtMS42NDYtLjUxOC0yLjE0NHYtLjkwNUg0LjI5di0xLjA3M2g0LjU2OGwuMjE3LS41NjZjLjEyLS4zMS4yMTctLjcxMy4yMTctLjg5M3YtLjMyOEg0LjI5di0uNzE1SDkuOThsLjM1LS42NWMuMTktLjM2Ljk2Ni0xLjA4IDEuNzIzLTEuNjA1bDEuMzc3LS45NTQgMS42NzgtLjMxMyAxLjY3OC0uMzEzIDEuNDM0LjI2MiAxLjQzNS4yNjJ2LTguNDhIMS43ODd2MTkuNjU3SDUuODh6TTkuMjkgOC45MzRINC4yOVY1LjAwNGgxMC4wMDZ2My45M0g5LjI5MnpcXFwiLz5cXG4gIDwvc3ZnPlxcblwiO1xuICB9KTtcbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZShmdW5jdGlvbiAoSGFuZGxlYmFycyxkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHRoaXMuY29tcGlsZXJJbmZvID0gWzQsJz49IDEuMC4wJ107XG5oZWxwZXJzID0gdGhpcy5tZXJnZShoZWxwZXJzLCBIYW5kbGViYXJzLmhlbHBlcnMpOyBkYXRhID0gZGF0YSB8fCB7fTtcbiAgXG5cblxuICByZXR1cm4gXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgdmlld0JveD1cXFwiMCAwIDI0LjE0MiAyNFxcXCI+XFxuICA8cGF0aCBkPVxcXCJNOS41MDQgMjMuMDg3Yy0uMjQ1LS42MTMtLjU0Ny0xLjQtLjY3LTEuNzQ1LS4yNC0uNjc2LS41NzMtLjY0Ni0yLjYxLjIzN2wtMS4yMTUuNTI1LTEuNTYtMS41ODgtMS41NjItMS41ODcuNjctMS40OTRjLjM3LS44MjIuNjIzLTEuNjQuNTYzLTEuODItLjA2LS4xOC0uNzg1LS41NzYtMS42MTQtLjg4MkwwIDE0LjE3OFY5LjgyMmwxLjUyLS41NjhjMS42ODctLjYzIDEuOC0xLjAwNC45MDgtMy4wM2wtLjUzMy0xLjIxNSAxLjU4OC0xLjU2TDUuMDcgMS44ODdsMS40OTQuNjdjLjgyMi4zNyAxLjY0LjYyMyAxLjgyLjU2My4xOC0uMDYuNTc2LS43ODUuODgyLTEuNjE0TDkuODIyIDBoNC4zNTZsLjU1NiAxLjUwNmMuMzA2LjgzLjcwMyAxLjU1NS44ODIgMS42MTUuMTguMDYuOTk4LS4xOTIgMS44Mi0uNTZsMS40OTQtLjY3MiAxLjU4NyAxLjU2IDEuNTg4IDEuNTYtLjUzMyAxLjIxNWMtLjg5IDIuMDI3LS43OCAyLjQwMi45MDcgMy4wM2wxLjUyLjU3djQuMzU1bC0xLjUyLjU2OGMtMS42ODcuNjMtMS44IDEuMDA0LS45MDggMy4wM2wuNTMzIDEuMjE1LTEuNTg4IDEuNTYtMS41ODcgMS41NjItMS40OTQtLjY3Yy0uODIyLS4zNy0xLjY0LS42MjMtMS44Mi0uNTYzLS4xOC4wNi0uNTc1Ljc4NS0uODggMS42MTRMMTQuMTggMjRsLTIuMTE0LjFjLTIuMTEuMTAyLTIuMTE2LjEtMi41NjItMS4wMTN6bTMuODEyLTIuMzEyYy4zMDQtMS4wMTIuNjk3LTEuNTAzIDEuNTItMS44OTUgMS4wMzUtLjQ5NCAxLjE5Ni0uNDgzIDIuNDYzLjE2MyAxLjI0LjYzNCAxLjQuNjQ2IDEuODk1LjE1Mi40OTQtLjQ5NC40ODQtLjY1LS4xMjItMS44MzctLjYwMi0xLjE4LS42MTgtMS40MDItLjE3NS0yLjQ2LjM4LS45MS43ODgtMS4yNTYgMS44NjUtMS41NzggMS4xNjctLjM1IDEuMzc4LS41NTIgMS4zNzgtMS4zMnMtLjIxLS45Ny0xLjM3Ny0xLjMyYy0xLjA3Ny0uMzIyLTEuNDg1LS42NjgtMS44NjUtMS41NzctLjQ0My0xLjA2LS40MjctMS4yODIuMTc1LTIuNDYuNjA2LTEuMTkuNjE2LTEuMzQ0LjEyMi0xLjgzOHMtLjY1NC0uNDgyLTEuODk2LjE1MmMtMS4yNjguNjQ2LTEuNDMuNjU3LTIuNDY1LjE2My0uODIyLS4zOTItMS4yMTUtLjg4My0xLjUyLTEuODk1QzEyLjk3IDIuMDcgMTIuNzY4IDEuODYgMTIgMS44NmMtLjc2NyAwLS45Ny4yMS0xLjMxNiAxLjM2NS0uMzA0IDEuMDEyLS42OTcgMS41MDMtMS41MiAxLjg5NS0xLjAzNS40OTQtMS4xOTYuNDgzLTIuNDYzLS4xNjMtMS4yNC0uNjM0LTEuNC0uNjQ2LTEuODk1LS4xNTItLjQ5NC40OTQtLjQ4Mi42NTQuMTUyIDEuODk2LjY0NiAxLjI2OC42NTcgMS40My4xNjMgMi40NjUtLjM5Mi44MjItLjg4MyAxLjIxNS0xLjg5NSAxLjUyQzIuMDcgMTEuMDMgMS44NiAxMS4yMzIgMS44NiAxMmMwIC43NjguMjEuOTcgMS4zNzcgMS4zMiAxLjA3Ny4zMjIgMS40ODUuNjY4IDEuODY1IDEuNTc3LjQ0MyAxLjA2LjQyNyAxLjI4Mi0uMTc1IDIuNDYtLjYwNiAxLjE5LS42MTYgMS4zNDQtLjEyMiAxLjgzOHMuNjU0LjQ4MiAxLjg5Ni0uMTUyYzEuMjY4LS42NDYgMS40My0uNjU3IDIuNDY1LS4xNjMuODIyLjM5MiAxLjIxNS44ODMgMS41MiAxLjg5NS4zNDUgMS4xNTUuNTQ4IDEuMzY2IDEuMzE1IDEuMzY2Ljc2NyAwIC45Ny0uMjEgMS4zMTYtMS4zNjV6TTEwLjQ4IDE1Ljc1Yy0xLjUwNi0uNjYtMi4zNjctMi4wMzMtMi4zNjctMy43NyAwLTEuNDIuMTU3LTEuODE1IDEuMTA1LTIuNzYyIDEuNi0xLjYwMiAzLjk2My0xLjYwMiA1LjU2NCAwIC45NS45NSAxLjEwNSAxLjM0IDEuMTA1IDIuNzgyIDAgMS40MjQtLjE1NyAxLjgzNS0xLjA0NSAyLjcyMy0xLjExNiAxLjExNi0zLjEgMS41ODMtNC4zNjMgMS4wMjh6bTIuODcyLTIuMzk4Yy4zNzItLjM3Mi42NzYtLjk4LjY3Ni0xLjM1MiAwLS44Ny0xLjE1Ny0yLjAyOC0yLjAyOC0yLjAyOC0uMzcyIDAtLjk4LjMwNC0xLjM1Mi42NzYtLjM3Mi4zNzItLjY3Ni45OC0uNjc2IDEuMzUyIDAgLjM3Mi4zMDQuOTguNjc2IDEuMzUyLjM3Mi4zNzIuOTguNjc2IDEuMzUyLjY3Ni4zNzIgMCAuOTgtLjMwNCAxLjM1Mi0uNjc2elxcXCIvPlxcbjwvc3ZnPlxcblwiO1xuICB9KTtcbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZShmdW5jdGlvbiAoSGFuZGxlYmFycyxkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHRoaXMuY29tcGlsZXJJbmZvID0gWzQsJz49IDEuMC4wJ107XG5oZWxwZXJzID0gdGhpcy5tZXJnZShoZWxwZXJzLCBIYW5kbGViYXJzLmhlbHBlcnMpOyBkYXRhID0gZGF0YSB8fCB7fTtcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMSwgaGVscGVyLCBvcHRpb25zLCBzZWxmPXRoaXMsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbjtcblxuZnVuY3Rpb24gcHJvZ3JhbTEoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJcXG4gICAgICA8b3B0aW9uIHZhbHVlPVxcXCJnb29nbGVcXFwiPkdvb2dsZTwvb3B0aW9uPlxcbiAgICAgIDxvcHRpb24gdmFsdWU9XFxcImJpbmdcXFwiPkJpbmc8L29wdGlvbj5cXG4gICAgICA8b3B0aW9uIHZhbHVlPVxcXCJ5YWhvb1xcXCI+WWFob288L29wdGlvbj5cXG4gICAgXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTMoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJjaGVja2VkXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTUoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJcXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlVTXFxcIj5Vbml0ZWQgU3RhdGVzPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJHQlxcXCI+VW5pdGVkIEtpbmdkb208L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIklOXFxcIj5JbmRpYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQ0FcXFwiPkNhbmFkYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiREVcXFwiPkdlcm1hbnk8L29wdGlvbj5cXG4gICAgICAgIDxvcHRncm91cCBsYWJlbD1cXFwiLS0tLS0tLS0tLVxcXCI+PC9vcHRncm91cD5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlxcXCI+Q291bnRyeTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQUZcXFwiPkFmZ2hhbmlzdGFuPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJBTFxcXCI+QWxiYW5pYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiRFpcXFwiPkFsZ2VyaWE8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkFTXFxcIj5BbWVyaWNhbiBTYW1vYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQURcXFwiPkFuZG9ycmE8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkFPXFxcIj5BbmdvbGE8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkFJXFxcIj5Bbmd1aWxsYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQVFcXFwiPkFudGFyY3RpY2E8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkFHXFxcIj5BbnRpZ3VhIGFuZCBCYXJidWRhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJBUlxcXCI+QXJnZW50aW5hPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJBTVxcXCI+QXJtZW5pYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQVdcXFwiPkFydWJhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJBVVxcXCI+QXVzdHJhbGlhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJBVFxcXCI+QXVzdHJpYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQVpcXFwiPkF6ZXJiYWlqYW48L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkJTXFxcIj5CYWhhbWFzPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJCSFxcXCI+QmFocmFpbjwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQkRcXFwiPkJhbmdsYWRlc2g8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkJCXFxcIj5CYXJiYWRvczwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQllcXFwiPkJlbGFydXM8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkJFXFxcIj5CZWxnaXVtPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJCWlxcXCI+QmVsaXplPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJCSlxcXCI+QmVuaW48L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkJNXFxcIj5CZXJtdWRhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJCVFxcXCI+Qmh1dGFuPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJCT1xcXCI+Qm9saXZpYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQkFcXFwiPkJvc25pYSBhbmQgSGVyemVnb3ZpbmE8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkJXXFxcIj5Cb3Rzd2FuYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQlZcXFwiPkJvdXZldCBJc2xhbmQ8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkJSXFxcIj5CcmF6aWw8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIklPXFxcIj5Ccml0aXNoIEluZGlhbiBPY2VhbiBUZXJyaXRvcnk8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlZHXFxcIj5Ccml0aXNoIFZpcmdpbiBJc2xhbmRzPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJCTlxcXCI+QnJ1bmVpPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJCR1xcXCI+QnVsZ2FyaWE8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkJGXFxcIj5CdXJraW5hIEZhc288L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkJJXFxcIj5CdXJ1bmRpPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJLSFxcXCI+Q2FtYm9kaWE8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkNNXFxcIj5DYW1lcm9vbjwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQ0FcXFwiPkNhbmFkYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQ1ZcXFwiPkNhcGUgVmVyZGU8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIktZXFxcIj5DYXltYW4gSXNsYW5kczwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQ0ZcXFwiPkNlbnRyYWwgQWZyaWNhbiBSZXB1YmxpYzwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVERcXFwiPkNoYWQ8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkNMXFxcIj5DaGlsZTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQ05cXFwiPkNoaW5hPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJDWFxcXCI+Q2hyaXN0bWFzIElzbGFuZDwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQ0NcXFwiPkNvY29zIFtLZWVsaW5nXSBJc2xhbmRzPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJDT1xcXCI+Q29sb21iaWE8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIktNXFxcIj5Db21vcm9zPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJDRFxcXCI+Q29uZ28gW0RSQ108L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkNHXFxcIj5Db25nbyBbUmVwdWJsaWNdPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJDS1xcXCI+Q29vayBJc2xhbmRzPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJDUlxcXCI+Q29zdGEgUmljYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQ0lcXFwiPkNvdGUgZCdJdm9pcmU8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkhSXFxcIj5Dcm9hdGlhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJDVVxcXCI+Q3ViYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQ1lcXFwiPkN5cHJ1czwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQ1pcXFwiPkN6ZWNoIFJlcHVibGljPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJES1xcXCI+RGVubWFyazwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiREpcXFwiPkRqaWJvdXRpPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJETVxcXCI+RG9taW5pY2E8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkRPXFxcIj5Eb21pbmljYW4gUmVwdWJsaWM8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkVDXFxcIj5FY3VhZG9yPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJFR1xcXCI+RWd5cHQ8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlNWXFxcIj5FbCBTYWx2YWRvcjwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiR1FcXFwiPkVxdWF0b3JpYWwgR3VpbmVhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJFUlxcXCI+RXJpdHJlYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiRUVcXFwiPkVzdG9uaWE8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkVUXFxcIj5FdGhpb3BpYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiRktcXFwiPkZhbGtsYW5kIElzbGFuZHMgW0lzbGFzIE1hbHZpbmFzXTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiRk9cXFwiPkZhcm9lIElzbGFuZHM8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkZKXFxcIj5GaWppPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJGSVxcXCI+RmlubGFuZDwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiRlJcXFwiPkZyYW5jZTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiR0ZcXFwiPkZyZW5jaCBHdWlhbmE8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlBGXFxcIj5GcmVuY2ggUG9seW5lc2lhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJURlxcXCI+RnJlbmNoIFNvdXRoZXJuIFRlcnJpdG9yaWVzPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJHQVxcXCI+R2Fib248L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkdNXFxcIj5HYW1iaWE8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkdFXFxcIj5HZW9yZ2lhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJERVxcXCI+R2VybWFueTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiR0hcXFwiPkdoYW5hPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJHSVxcXCI+R2licmFsdGFyPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJHUlxcXCI+R3JlZWNlPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJHTFxcXCI+R3JlZW5sYW5kPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJHRFxcXCI+R3JlbmFkYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiR1BcXFwiPkd1YWRlbG91cGU8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkdVXFxcIj5HdWFtPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJHVFxcXCI+R3VhdGVtYWxhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJHTlxcXCI+R3VpbmVhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJHV1xcXCI+R3VpbmVhLUJpc3NhdTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiR1lcXFwiPkd1eWFuYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiSFRcXFwiPkhhaXRpPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJITVxcXCI+SGVhcmQgSXNsYW5kIGFuZCBNY0RvbmFsZCBJc2xhbmRzPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJITlxcXCI+SG9uZHVyYXM8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkhLXFxcIj5Ib25nIEtvbmc8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkhVXFxcIj5IdW5nYXJ5PC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJJU1xcXCI+SWNlbGFuZDwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiSU5cXFwiPkluZGlhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJJRFxcXCI+SW5kb25lc2lhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJJUlxcXCI+SXJhbjwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiSVFcXFwiPklyYXE8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIklFXFxcIj5JcmVsYW5kPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJJTFxcXCI+SXNyYWVsPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJJVFxcXCI+SXRhbHk8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkpNXFxcIj5KYW1haWNhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJKUFxcXCI+SmFwYW48L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkpPXFxcIj5Kb3JkYW48L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIktaXFxcIj5LYXpha2hzdGFuPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJLRVxcXCI+S2VueWE8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIktJXFxcIj5LaXJpYmF0aTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiS1dcXFwiPkt1d2FpdDwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiS0dcXFwiPkt5cmd5enN0YW48L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkxBXFxcIj5MYW9zPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJMVlxcXCI+TGF0dmlhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJMQlxcXCI+TGViYW5vbjwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTFNcXFwiPkxlc290aG88L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkxSXFxcIj5MaWJlcmlhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJMWVxcXCI+TGlieWE8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkxJXFxcIj5MaWVjaHRlbnN0ZWluPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJMVFxcXCI+TGl0aHVhbmlhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJMVVxcXCI+THV4ZW1ib3VyZzwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTU9cXFwiPk1hY2F1PC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJNS1xcXCI+TWFjZWRvbmlhIFtGWVJPTV08L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk1HXFxcIj5NYWRhZ2FzY2FyPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJNV1xcXCI+TWFsYXdpPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJNWVxcXCI+TWFsYXlzaWE8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk1WXFxcIj5NYWxkaXZlczwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTUxcXFwiPk1hbGk8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk1UXFxcIj5NYWx0YTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTUhcXFwiPk1hcnNoYWxsIElzbGFuZHM8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk1RXFxcIj5NYXJ0aW5pcXVlPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJNUlxcXCI+TWF1cml0YW5pYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTVVcXFwiPk1hdXJpdGl1czwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiWVRcXFwiPk1heW90dGU8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk1YXFxcIj5NZXhpY288L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkZNXFxcIj5NaWNyb25lc2lhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJNRFxcXCI+TW9sZG92YTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTUNcXFwiPk1vbmFjbzwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTU5cXFwiPk1vbmdvbGlhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJNU1xcXCI+TW9udHNlcnJhdDwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTUFcXFwiPk1vcm9jY288L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk1aXFxcIj5Nb3phbWJpcXVlPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJNTVxcXCI+TXlhbm1hciBbQnVybWFdPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJOQVxcXCI+TmFtaWJpYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTlJcXFwiPk5hdXJ1PC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJOUFxcXCI+TmVwYWw8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk5MXFxcIj5OZXRoZXJsYW5kczwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQU5cXFwiPk5ldGhlcmxhbmRzIEFudGlsbGVzPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJOQ1xcXCI+TmV3IENhbGVkb25pYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTlpcXFwiPk5ldyBaZWFsYW5kPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJOSVxcXCI+TmljYXJhZ3VhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJORVxcXCI+TmlnZXI8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk5HXFxcIj5OaWdlcmlhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJOVVxcXCI+Tml1ZTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTkZcXFwiPk5vcmZvbGsgSXNsYW5kPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJLUFxcXCI+Tm9ydGggS29yZWE8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk1QXFxcIj5Ob3J0aGVybiBNYXJpYW5hIElzbGFuZHM8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk5PXFxcIj5Ob3J3YXk8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk9NXFxcIj5PbWFuPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJQS1xcXCI+UGFraXN0YW48L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlBXXFxcIj5QYWxhdTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiUFNcXFwiPlBhbGVzdGluaWFuIFRlcnJpdG9yaWVzPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJQQVxcXCI+UGFuYW1hPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJQR1xcXCI+UGFwdWEgTmV3IEd1aW5lYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiUFlcXFwiPlBhcmFndWF5PC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJQRVxcXCI+UGVydTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiUEhcXFwiPlBoaWxpcHBpbmVzPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJQTlxcXCI+UGl0Y2Fpcm4gSXNsYW5kczwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiUExcXFwiPlBvbGFuZDwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiUFRcXFwiPlBvcnR1Z2FsPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJQUlxcXCI+UHVlcnRvIFJpY288L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlFBXFxcIj5RYXRhcjwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiUkVcXFwiPlJldW5pb248L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlJPXFxcIj5Sb21hbmlhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJSVVxcXCI+UnVzc2lhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJSV1xcXCI+UndhbmRhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJTSFxcXCI+U2FpbnQgSGVsZW5hPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJLTlxcXCI+U2FpbnQgS2l0dHMgYW5kIE5ldmlzPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJMQ1xcXCI+U2FpbnQgTHVjaWE8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlBNXFxcIj5TYWludCBQaWVycmUgYW5kIE1pcXVlbG9uPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJWQ1xcXCI+U2FpbnQgVmluY2VudCBhbmQgdGhlIEdyZW5hZGluZXM8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIldTXFxcIj5TYW1vYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiU01cXFwiPlNhbiBNYXJpbm88L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlNUXFxcIj5TYW8gVG9tZSBhbmQgUHLDrW5jaXBlPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJTQVxcXCI+U2F1ZGkgQXJhYmlhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJTTlxcXCI+U2VuZWdhbDwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiWVVcXFwiPlNlcmJpYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiU0NcXFwiPlNleWNoZWxsZXM8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlNMXFxcIj5TaWVycmEgTGVvbmU8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlNHXFxcIj5TaW5nYXBvcmU8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlNLXFxcIj5TbG92YWtpYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiU0lcXFwiPlNsb3ZlbmlhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJTQlxcXCI+U29sb21vbiBJc2xhbmRzPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJTT1xcXCI+U29tYWxpYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiWkFcXFwiPlNvdXRoIEFmcmljYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiR1NcXFwiPlNvdXRoIEdlb3JnaWEgYW5kIHRoZSBTb3V0aCBTYW5kd2ljaCBJc2xhbmRzPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJLUlxcXCI+U291dGggS29yZWE8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkVTXFxcIj5TcGFpbjwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTEtcXFwiPlNyaSBMYW5rYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiU0RcXFwiPlN1ZGFuPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJTUlxcXCI+U3VyaW5hbWU8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlNKXFxcIj5TdmFsYmFyZCBhbmQgSmFuIE1heWVuPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJTWlxcXCI+U3dhemlsYW5kPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJTRVxcXCI+U3dlZGVuPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJDSFxcXCI+U3dpdHplcmxhbmQ8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlNZXFxcIj5TeXJpYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVFdcXFwiPlRhaXdhbjwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVEpcXFwiPlRhamlraXN0YW48L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlRaXFxcIj5UYW56YW5pYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVEhcXFwiPlRoYWlsYW5kPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJUR1xcXCI+VG9nbzwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVEtcXFwiPlRva2VsYXU8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlRPXFxcIj5Ub25nYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVFRcXFwiPlRyaW5pZGFkIGFuZCBUb2JhZ288L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlROXFxcIj5UdW5pc2lhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJUUlxcXCI+VHVya2V5PC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJUTVxcXCI+VHVya21lbmlzdGFuPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJUQ1xcXCI+VHVya3MgYW5kIENhaWNvcyBJc2xhbmRzPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJUVlxcXCI+VHV2YWx1PC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJVTVxcXCI+VS5TLiBNaW5vciBPdXRseWluZyBJc2xhbmRzPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJWSVxcXCI+VS5TLiBWaXJnaW4gSXNsYW5kczwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVUdcXFwiPlVnYW5kYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVUFcXFwiPlVrcmFpbmU8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkFFXFxcIj5Vbml0ZWQgQXJhYiBFbWlyYXRlczwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiR0JcXFwiPlVuaXRlZCBLaW5nZG9tPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJVU1xcXCI+VW5pdGVkIFN0YXRlczwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVVlcXFwiPlVydWd1YXk8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlVaXFxcIj5VemJla2lzdGFuPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJWVVxcXCI+VmFudWF0dTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVkFcXFwiPlZhdGljYW4gQ2l0eTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVkVcXFwiPlZlbmV6dWVsYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVk5cXFwiPlZpZXRuYW08L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIldGXFxcIj5XYWxsaXMgYW5kIEZ1dHVuYTwvb3B0aW9uPlxcbiAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiRUhcXFwiPldlc3Rlcm4gU2FoYXJhPC9vcHRpb24+XFxuICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJZRVxcXCI+WWVtZW48L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlpNXFxcIj5aYW1iaWE8L29wdGlvbj5cXG4gICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlpXXFxcIj5aaW1iYWJ3ZTwvb3B0aW9uPlxcbiAgICAgIFwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW03KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiXFxuICAgICAgICBVcGRhdGUgUHJvZmlsZVxcbiAgICAgIFwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW05KGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiXFxuICAgICAgICBDcmVhdGUgUHJvZmlsZVxcbiAgICAgIFwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xMShkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcIlxcbiAgICA8YnV0dG9uIGNsYXNzPVxcXCJkZWxldGVcXFwiPlxcbiAgICAgIERlbGV0ZSBQcm9maWxlXFxuICAgIDwvYnV0dG9uPlxcbiAgIFwiO1xuICB9XG5cbiAgYnVmZmVyICs9IFwiICA8ZGl2IGNsYXNzPVxcXCJwcm9maWxlLWVkaXRcXFwiPlxcbiAgPGgxPkFkZCBQcm9maWxlPC9oMT5cXG5cXG4gIDxwPkNyZWF0ZSBhIHByb2ZpbGUgc28geW91IGNhbiBxdWlja2x5IHJlcnVuIGN1c3RvbSwgdGFyZ2V0ZWQgc2VhcmNoIHJlc3VsdHMuPC9wPlxcblxcbiAgPGRpdj5cXG4gIDxzZWxlY3QgbmFtZT1cXFwiZW5naW5lXFxcIiBjbGFzcz1cXFwiZW5naW5lXFxcIj5cXG4gICAgXCI7XG4gIHN0YWNrMSA9IChoZWxwZXIgPSBoZWxwZXJzLnNlbGVjdCB8fCAoZGVwdGgwICYmIGRlcHRoMC5zZWxlY3QpLG9wdGlvbnM9e2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDEsIHByb2dyYW0xLCBkYXRhKSxkYXRhOmRhdGF9LGhlbHBlciA/IGhlbHBlci5jYWxsKGRlcHRoMCwgKGRlcHRoMCAmJiBkZXB0aDAuZW5naW5lKSwgb3B0aW9ucykgOiBoZWxwZXJNaXNzaW5nLmNhbGwoZGVwdGgwLCBcInNlbGVjdFwiLCAoZGVwdGgwICYmIGRlcHRoMC5lbmdpbmUpLCBvcHRpb25zKSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCJcXG4gIDwvc2VsZWN0PlxcbiAgPC9kaXY+XFxuICA8ZGl2PlxcbiAgPGxhYmVsPlxcbiAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIGNsYXNzPVxcXCJkaXNhYmxlLXBlcnNvbmFsaXphdGlvblxcXCJcXG4gICAgICBcIjtcbiAgc3RhY2sxID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKGRlcHRoMCAmJiBkZXB0aDAuZGlzYWJsZVBlcnNvbmFsaXphdGlvbiksIHtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbSgzLCBwcm9ncmFtMywgZGF0YSksZGF0YTpkYXRhfSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCI+XFxuICAgICAgU2hvdyBub24tcGVyc29uYWxpemVkIHJlc3VsdHM8L2lucHV0PlxcbiAgPC9sYWJlbD5cXG4gIDwvZGl2PlxcbiAgPGRpdj5cXG4gICAgPHNlbGVjdCBuYW1lPVxcXCJjb3VudHJ5XFxcIiBjbGFzcz1cXFwiY291bnRyeVxcXCI+XFxuICAgICAgXCI7XG4gIHN0YWNrMSA9IChoZWxwZXIgPSBoZWxwZXJzLnNlbGVjdCB8fCAoZGVwdGgwICYmIGRlcHRoMC5zZWxlY3QpLG9wdGlvbnM9e2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDUsIHByb2dyYW01LCBkYXRhKSxkYXRhOmRhdGF9LGhlbHBlciA/IGhlbHBlci5jYWxsKGRlcHRoMCwgKGRlcHRoMCAmJiBkZXB0aDAuY291bnRyeSksIG9wdGlvbnMpIDogaGVscGVyTWlzc2luZy5jYWxsKGRlcHRoMCwgXCJzZWxlY3RcIiwgKGRlcHRoMCAmJiBkZXB0aDAuY291bnRyeSksIG9wdGlvbnMpKTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcbiAgICA8L3NlbGVjdD5cXG4gIDwvZGl2PlxcblxcbiAgPGRpdj5cXG4gIDxzZWxlY3QgbmFtZT1cXFwicmVnaW9uXFxcIiBjbGFzcz1cXFwicmVnaW9uXFxcIj5cXG4gIDwvc2VsZWN0PlxcbiAgPC9kaXY+XFxuXFxuICA8ZGl2PlxcbiAgPHNlbGVjdCBuYW1lPVxcXCJjaXR5XFxcIiBjbGFzcz1cXFwiY2l0eVxcXCI+XFxuICA8L3NlbGVjdD5cXG4gIDwvZGl2PlxcblxcbiAgPGRpdj5cXG4gIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBuYW1lPVxcXCJuYW1lXFxcIiBwbGFjZWhvbGRlcj1cXFwiTmFtZVxcXCIgdmFsdWU9XFxcIlwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5uYW1lKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLm5hbWUpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiXFxcIiBjbGFzcz1cXFwibmFtZVxcXCIvPlxcbiAgPC9kaXY+XFxuXFxuICA8ZGl2IGNsYXNzPVxcXCJhY3Rpb25zXFxcIj5cXG4gICAgPGJ1dHRvbiBjbGFzcz1cXFwic2F2ZVxcXCI+XFxuICAgICAgXCI7XG4gIHN0YWNrMSA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgJiYgZGVwdGgwLmlkKSwge2hhc2g6e30saW52ZXJzZTpzZWxmLnByb2dyYW0oOSwgcHJvZ3JhbTksIGRhdGEpLGZuOnNlbGYucHJvZ3JhbSg3LCBwcm9ncmFtNywgZGF0YSksZGF0YTpkYXRhfSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCJcXG4gICAgPC9idXR0b24+XFxuICAgIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoZGVwdGgwICYmIGRlcHRoMC5pZCksIHtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbSgxMSwgcHJvZ3JhbTExLCBkYXRhKSxkYXRhOmRhdGF9KTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcbiAgICA8YnV0dG9uIGNsYXNzPVxcXCJjYW5jZWxcXFwiPkNhbmNlbDwvYnV0dG9uPlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH0pO1xuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKGZ1bmN0aW9uIChIYW5kbGViYXJzLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgdGhpcy5jb21waWxlckluZm8gPSBbNCwnPj0gMS4wLjAnXTtcbmhlbHBlcnMgPSB0aGlzLm1lcmdlKGhlbHBlcnMsIEhhbmRsZWJhcnMuaGVscGVycyk7IGRhdGEgPSBkYXRhIHx8IHt9O1xuICB2YXIgYnVmZmVyID0gXCJcIiwgc3RhY2sxLCBoZWxwZXIsIG9wdGlvbnMsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbiwgc2VsZj10aGlzLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBibG9ja0hlbHBlck1pc3Npbmc9aGVscGVycy5ibG9ja0hlbHBlck1pc3Npbmc7XG5cbmZ1bmN0aW9uIHByb2dyYW0xKGRlcHRoMCxkYXRhLGRlcHRoMSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIGhlbHBlciwgb3B0aW9ucztcbiAgYnVmZmVyICs9IFwiXFxuICBcIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoaGVscGVyID0gaGVscGVycy5vcHRpb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAub3B0aW9uKSxvcHRpb25zPXtoYXNoOntcbiAgICAndmFsdWUnOiAoKGRlcHRoMCAmJiBkZXB0aDAubmFtZSkpLFxuICAgICd0ZXh0JzogKChkZXB0aDAgJiYgZGVwdGgwLm5hbWUpKVxuICB9LGRhdGE6ZGF0YX0saGVscGVyID8gaGVscGVyLmNhbGwoZGVwdGgwLCAoZGVwdGgxICYmIGRlcHRoMS5jaXR5KSwgb3B0aW9ucykgOiBoZWxwZXJNaXNzaW5nLmNhbGwoZGVwdGgwLCBcIm9wdGlvblwiLCAoZGVwdGgxICYmIGRlcHRoMS5jaXR5KSwgb3B0aW9ucykpKVxuICAgICsgXCJcXG5cIjtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG4gIGJ1ZmZlciArPSBcIjxvcHRpb24gdmFsdWU9XFxcIlxcXCI+Q2l0eTwvb3B0aW9uPlxcblwiO1xuICBvcHRpb25zPXtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbVdpdGhEZXB0aCgxLCBwcm9ncmFtMSwgZGF0YSwgZGVwdGgwKSxkYXRhOmRhdGF9XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLmNpdGllcykgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIG9wdGlvbnMpOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5jaXRpZXMpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIG9wdGlvbnMpIDogaGVscGVyOyB9XG4gIGlmICghaGVscGVycy5jaXRpZXMpIHsgc3RhY2sxID0gYmxvY2tIZWxwZXJNaXNzaW5nLmNhbGwoZGVwdGgwLCBzdGFjazEsIHtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbVdpdGhEZXB0aCgxLCBwcm9ncmFtMSwgZGF0YSwgZGVwdGgwKSxkYXRhOmRhdGF9KTsgfVxuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxuXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH0pO1xuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKGZ1bmN0aW9uIChIYW5kbGViYXJzLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgdGhpcy5jb21waWxlckluZm8gPSBbNCwnPj0gMS4wLjAnXTtcbmhlbHBlcnMgPSB0aGlzLm1lcmdlKGhlbHBlcnMsIEhhbmRsZWJhcnMuaGVscGVycyk7IGRhdGEgPSBkYXRhIHx8IHt9O1xuICB2YXIgYnVmZmVyID0gXCJcIiwgc3RhY2sxLCBoZWxwZXIsIG9wdGlvbnMsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbiwgc2VsZj10aGlzLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBibG9ja0hlbHBlck1pc3Npbmc9aGVscGVycy5ibG9ja0hlbHBlck1pc3Npbmc7XG5cbmZ1bmN0aW9uIHByb2dyYW0xKGRlcHRoMCxkYXRhLGRlcHRoMSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIGhlbHBlciwgb3B0aW9ucztcbiAgYnVmZmVyICs9IFwiXFxuICBcIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoaGVscGVyID0gaGVscGVycy5vcHRpb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAub3B0aW9uKSxvcHRpb25zPXtoYXNoOntcbiAgICAndmFsdWUnOiAoKGRlcHRoMCAmJiBkZXB0aDAuY29kZSkpLFxuICAgICd0ZXh0JzogKChkZXB0aDAgJiYgZGVwdGgwLm5hbWUpKVxuICB9LGRhdGE6ZGF0YX0saGVscGVyID8gaGVscGVyLmNhbGwoZGVwdGgwLCAoZGVwdGgxICYmIGRlcHRoMS5yZWdpb24pLCBvcHRpb25zKSA6IGhlbHBlck1pc3NpbmcuY2FsbChkZXB0aDAsIFwib3B0aW9uXCIsIChkZXB0aDEgJiYgZGVwdGgxLnJlZ2lvbiksIG9wdGlvbnMpKSlcbiAgICArIFwiXFxuXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cblxuICBidWZmZXIgKz0gXCI8b3B0aW9uIHZhbHVlPVxcXCJcXFwiPlJlZ2lvbjwvb3B0aW9uPlxcblwiO1xuICBvcHRpb25zPXtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbVdpdGhEZXB0aCgxLCBwcm9ncmFtMSwgZGF0YSwgZGVwdGgwKSxkYXRhOmRhdGF9XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLnJlZ2lvbnMpIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCBvcHRpb25zKTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAucmVnaW9ucyk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwgb3B0aW9ucykgOiBoZWxwZXI7IH1cbiAgaWYgKCFoZWxwZXJzLnJlZ2lvbnMpIHsgc3RhY2sxID0gYmxvY2tIZWxwZXJNaXNzaW5nLmNhbGwoZGVwdGgwLCBzdGFjazEsIHtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbVdpdGhEZXB0aCgxLCBwcm9ncmFtMSwgZGF0YSwgZGVwdGgwKSxkYXRhOmRhdGF9KTsgfVxuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxuXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH0pO1xuIiwiLy8gaGJzZnkgY29tcGlsZWQgSGFuZGxlYmFycyB0ZW1wbGF0ZVxudmFyIEhhbmRsZWJhcnNDb21waWxlciA9IHJlcXVpcmUoJ2hic2Z5L3J1bnRpbWUnKTtcbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlYmFyc0NvbXBpbGVyLnRlbXBsYXRlKGZ1bmN0aW9uIChIYW5kbGViYXJzLGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcbiAgdGhpcy5jb21waWxlckluZm8gPSBbNCwnPj0gMS4wLjAnXTtcbmhlbHBlcnMgPSB0aGlzLm1lcmdlKGhlbHBlcnMsIEhhbmRsZWJhcnMuaGVscGVycyk7IGRhdGEgPSBkYXRhIHx8IHt9O1xuICB2YXIgYnVmZmVyID0gXCJcIiwgc3RhY2sxLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbiwgc2VsZj10aGlzO1xuXG5mdW5jdGlvbiBwcm9ncmFtMShkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMSwgaGVscGVyO1xuICBidWZmZXIgKz0gXCJcXG4gICAgICA8bGkgY2xhc3M9XFxcInNlYXJjaC1wcm9maWxlXFxcIiBkYXRhLWVuZ2luZT1cXFwiXCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLmVuZ2luZSkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5lbmdpbmUpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiXFxcIiBkYXRhLWlkPVxcXCJcIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMuaWQpIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAuaWQpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiXFxcIj5cXG4gICAgICAgIFwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5uYW1lKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLm5hbWUpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJlZGl0LXByb2ZpbGVcXFwiPjwvZGl2PlxcbiAgICAgIDwvbGk+XFxuICAgIFwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbiAgYnVmZmVyICs9IFwiPGRpdiBjbGFzcz1cXFwiY29udGVudFxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJkaXZpZGVyIGRpdmlkZXItdG9wXFxcIj48L2Rpdj5cXG4gIDx1bD5cXG4gICAgXCI7XG4gIHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCwgZGVwdGgwLCB7aGFzaDp7fSxpbnZlcnNlOnNlbGYubm9vcCxmbjpzZWxmLnByb2dyYW0oMSwgcHJvZ3JhbTEsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxuICAgIDxsaSBjbGFzcz1cXFwic2VhcmNoLXByb2ZpbGUgYWRkLW5ld1xcXCI+XFxuICAgICAgQWRkIE5ldyBQcm9maWxlXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiZWRpdC1wcm9maWxlXFxcIj48L2Rpdj5cXG4gICAgPC9saT5cXG4gIDwvdWw+XFxuICA8ZGl2IGNsYXNzPVxcXCJkaXZpZGVyIGRpdmlkZXItYm90dG9tXFxcIj48L2Rpdj5cXG48L2Rpdj5cXG5cIjtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfSk7XG4iLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoZnVuY3Rpb24gKEhhbmRsZWJhcnMsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICB0aGlzLmNvbXBpbGVySW5mbyA9IFs0LCc+PSAxLjAuMCddO1xuaGVscGVycyA9IHRoaXMubWVyZ2UoaGVscGVycywgSGFuZGxlYmFycy5oZWxwZXJzKTsgZGF0YSA9IGRhdGEgfHwge307XG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazEsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBzZWxmPXRoaXM7XG5cbmZ1bmN0aW9uIHByb2dyYW0xKGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiY2hlY2tcIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMyhkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMSwgaGVscGVyO1xuICBidWZmZXIgKz0gXCJcXG4gICAgICAgICAgPHA+U2NoZW1hLm9yZyBmb3VuZCBvbiB0aGlzIHBhZ2UuPC9wPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjdGFcXFwiPlxcbiAgICAgICAgICBQcmV2aWV3IGluXFxuICAgICAgICAgICAgPGEgaHJlZj1cXFwiXCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLnJpY2hTbmlwcGV0VG9vbFVybCkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5yaWNoU25pcHBldFRvb2xVcmwpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+XFxuICAgICAgICAgICAgICBTdHJ1Y3R1cmVkIERhdGEgVGVzdGluZyBUb29sXFxuICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIFwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW01KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gXCJcIiwgc3RhY2sxLCBoZWxwZXI7XG4gIGJ1ZmZlciArPSBcIlxcbiAgICAgICAgICA8cD5TY2hlbWEub3JnIG5vdCBmb3VuZCBvbiB0aGlzIHBhZ2UuPC9wPlxcblxcbiAgICAgICAgICA8cD5JbXBsZW1lbnRpbmcgc2NoZW1hLm9yZyBzdHJ1Y3R1cmVkIGRhdGEgaW4gYSBwYWdlIGxldHMgc2VhcmNoIGVuZ2luZXMgdW5kZXJzdGFuZCBtb3JlIGFib3V0IHRoZSBjb250ZW504oCUYW5kIGNhbiBhbGxvdyBwYWdlcyB0byBiZSBzaG93biBpbiBkaWZmZXJlbnQgc2VhcmNoIGZlYXR1cmVzLCBzdWNoIGFzIFJldmlld3MgYW5kIFJlY2lwZXMuIFRoaXMgY2FuIGluY3JlYXNlIGNsaWNrLXRocm91Z2ghPC9wPlxcblxcbiAgICAgICAgICA8cD5Hb29nbGUgcHJvdmlkZXMgYVxcbiAgICAgICAgICAgIDxhIGhyZWY9XFxcIlwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5yaWNoU25pcHBldFRvb2xVcmwpIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAucmljaFNuaXBwZXRUb29sVXJsKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIlxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPlxcbiAgICAgICAgICAgICAgU3RydWN0dXJlZCBEYXRhIFRlc3RpbmcgVG9vbFxcbiAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICB0aGF0IGFsbG93cyB5b3UgdG8gdGVzdCBhbmQgdmFsaWRhdGUgbWFya3VwLlxcbiAgICAgICAgICA8L3A+XFxuXFxuICAgICAgICAgIDxwPlxcbiAgICAgICAgICBUbyBsZWFybiBtb3JlIGFib3V0IHNjaGVtYS5vcmcsIHZpc2l0XFxuICAgICAgICAgIDxhIGhyZWY9XFxcImh0dHBzOi8vc3VwcG9ydC5nb29nbGUuY29tL3dlYm1hc3RlcnMvYW5zd2VyLzEyMTExNTg/aGw9ZW5cXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5cXG4gICAgICAgICAgR29vZ2xlJ3MgU2NoZW1hLm9yZyBGQVEuXFxuICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgPC9wPlxcbiAgICAgICAgXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTcoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazEsIGhlbHBlcjtcbiAgYnVmZmVyICs9IFwiXFxuICAgICAgICA8cD5PcGVuIEdyYXBoIHByb3RvY29sIGZvdW5kIG9uIHRoaXMgcGFnZS48L3A+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjdGFcXFwiPlxcbiAgICAgICAgICBQcmV2aWV3IGluXFxuICAgICAgICAgIDxhIGhyZWY9XFxcIlwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5vcGVuR3JhcGhUb29sVXJsKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLm9wZW5HcmFwaFRvb2xVcmwpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+XFxuICAgICAgICAgICAgRmFjZWJvb2sgT3BlbiBHcmFwaCBPYmplY3QgRGVidWdnZXIuXFxuICAgICAgICAgIDwvYT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTkoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazEsIGhlbHBlcjtcbiAgYnVmZmVyICs9IFwiXFxuICAgICAgICAgIDxwPk9wZW4gR3JhcGggcHJvdG9jb2wgbm90IGZvdW5kIG9uIHRoaXMgcGFnZS48L3A+XFxuXFxuICAgICAgICAgIDxwPlxcbiAgICAgICAgICAgIEltcGxlbWVudGluZyBPcGVuIEdyYXBoIHByb3RvY29sIHN0cnVjdHVyZWQgZGF0YSBkZXRlcm1pbmVzIGhvdyBhIHBhZ2UgYXBwZWFycyB3aGVuIGl0IGlzIHNoYXJlZCBvbiBGYWNlYm9va+KAlGFuZCBvbiBvdGhlciBzb2NpYWwgbWVkaWEgc2l0ZXMuIFRoaXMgY2FuIGluY3JlYXNlIGVuZ2FnZW1lbnQuXFxuICAgICAgICAgIDwvcD5cXG5cXG4gICAgICAgICAgPHA+XFxuICAgICAgICAgICAgRmFjZWJvb2sgcHJvdmlkZXMgYW5cXG4gICAgICAgICAgICA8YSBocmVmPVxcXCJcIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMub3BlbkdyYXBoVG9vbFVybCkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5vcGVuR3JhcGhUb29sVXJsKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIlxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPlxcbiAgICAgICAgICAgICAgT3BlbiBHcmFwaCBPYmplY3QgRGVidWdnZXJcXG4gICAgICAgICAgICA8L2E+XFxuICAgICAgICAgICAgdGhhdCBhbGxvd3MgeW91IHRvIHRlc3QgYW5kIHZhbGlkYXRlIHlvdXIgbWFya3VwLlxcbiAgICAgICAgICA8L3A+XFxuXFxuICAgICAgICAgIDxwPlxcbiAgICAgICAgICAgIFZpc2l0IHRoaXMgcGFnZSB0byBsZWFybiBtb3JlIGFib3V0XFxuICAgICAgICAgICAgPGEgaHJlZj1cXFwiaHR0cDovL29ncC5tZS9cXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5cXG4gICAgICAgICAgICAgIE9wZW4gR3JhcGggcHJvdG9jb2xcXG4gICAgICAgICAgICA8L2E+XFxuICAgICAgICAgIDwvcD5cXG4gICAgICAgIFwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xMShkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMSwgaGVscGVyO1xuICBidWZmZXIgKz0gXCJcXG4gICAgICAgICAgTWljcm9mb3JtYXRzIGZvdW5kIG9uIHRoaXMgcGFnZS5cXG5cXG4gICAgICAgICAgUHJldmlldyBpblxcbiAgICAgICAgICA8YSBocmVmPVxcXCJcIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMucmljaFNuaXBwZXRUb29sVXJsKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLnJpY2hTbmlwcGV0VG9vbFVybCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCJcXFwiICB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+XFxuICAgICAgICAgICAgR29vZ2xlIFN0cnVjdHVyZWQgRGF0YSBUZXN0aW5nIFRvb2xcXG4gICAgICAgICAgPC9hPi5cXG4gICAgICAgIFwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0xMyhkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMSwgaGVscGVyO1xuICBidWZmZXIgKz0gXCJcXG4gICAgICAgICAgPHA+TWljcm9mb3JtYXRzIG5vdCBmb3VuZCBvbiB0aGlzIHBhZ2UuPC9wPlxcblxcbiAgICAgICAgICA8cD5cXG4gICAgICAgICAgSW1wbGVtZW50aW5nIG1pY3JvZm9ybWF0cyBzdHJ1Y3R1cmVkIGRhdGEgb24gYSBwYWdlIGxldHMgc2VhcmNoIGVuZ2luZXMgdW5kZXJzdGFuZCBtb3JlIGFib3V0IHRoZSBjb250ZW504oCUYW5kIGFsbG93cyBwYWdlcyB0byBiZSBzaG93biBpbiBkaWZmZXJlbnQgc2VhcmNoIGZlYXR1cmVzLCBzdWNoIGFzIFJldmlld3MgYW5kIFJlY2lwZXMuIFRoZXNlIGNhbiBpbmNyZWFzZSBjbGljay10aHJvdWdoLlxcbiAgICAgICAgICA8L3A+XFxuXFxuICAgICAgICAgIDxwPlxcbiAgICAgICAgICBHb29nbGUgcHJvdmlkZXMgYVxcbiAgICAgICAgICA8YSBocmVmPVxcXCJcIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMucmljaFNuaXBwZXRUb29sVXJsKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLnJpY2hTbmlwcGV0VG9vbFVybCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCJcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5cXG4gICAgICAgICAgICBTdHJ1Y3R1cmVkIERhdGEgVGVzdGluZyBUb29sXFxuICAgICAgICAgIDwvYT4uXFxuICAgICAgICAgIHRoYXQgYWxsb3dzIHlvdSB0byB0ZXN0IGFuZCB2YWxpZGF0ZSBtYXJrdXAuXFxuICAgICAgICAgIDwvcD5cXG5cXG4gICAgICAgICAgPHA+XFxuICAgICAgICAgICAgVG8gbGVhcm4gbW9yZSBhYm91dCBtaWNyb2Zvcm1hdHMsIHZpc2l0XFxuICAgICAgICAgICAgPGEgaHJlZj1cXFwiaHR0cDovL21pY3JvZm9ybWF0cy5vcmcvXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+XFxuICAgICAgICAgICAgdGhlIG1pY3JvZm9ybWF0cyBkb2N1bWVudGF0aW9uIHBhZ2U8L2E+LlxcbiAgICAgICAgICA8L3A+XFxuICAgICAgICBcIjtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG4gIGJ1ZmZlciArPSBcIlxcblxcbjxkaXYgY2xhc3M9XFxcInNlbWFudGljc1xcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJjb2x1bW4gc25pcHBldC1jb2x1bW5cXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJoZWFkZXJcXFwiPlR5cGU8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwic25pcHBldCBzY3JvbGxhYmxlXFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb250ZW50IFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoZGVwdGgwICYmIGRlcHRoMC5oYXNTY2hlbWEpLCB7aGFzaDp7fSxpbnZlcnNlOnNlbGYubm9vcCxmbjpzZWxmLnByb2dyYW0oMSwgcHJvZ3JhbTEsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxcIlxcbiAgICAgICAgZGF0YS1zaG93PVxcXCJzY2hlbWFcXFwiPlNjaGVtYS5vcmc8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb250ZW50IFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoZGVwdGgwICYmIGRlcHRoMC5oYXNPcGVuR3JhcGgpLCB7aGFzaDp7fSxpbnZlcnNlOnNlbGYubm9vcCxmbjpzZWxmLnByb2dyYW0oMSwgcHJvZ3JhbTEsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxcIlxcbiAgICAgICAgZGF0YS1zaG93PVxcXCJvcGVuLWdyYXBoXFxcIj5PcGVuIEdyYXBoIFByb3RvY29sPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29udGVudCBcIjtcbiAgc3RhY2sxID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKGRlcHRoMCAmJiBkZXB0aDAuaGFzVHdpdHRlciksIHtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbSgxLCBwcm9ncmFtMSwgZGF0YSksZGF0YTpkYXRhfSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCJcXFwiXFxuICAgICAgICBkYXRhLXNob3c9XFxcInR3aXR0ZXJcXFwiPlR3aXR0ZXIgQ2FyZHM8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb250ZW50IFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoZGVwdGgwICYmIGRlcHRoMC5oYXNNaWNyb2Zvcm1hdHMpLCB7aGFzaDp7fSxpbnZlcnNlOnNlbGYubm9vcCxmbjpzZWxmLnByb2dyYW0oMSwgcHJvZ3JhbTEsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxcIlxcbiAgICAgICAgZGF0YS1zaG93PVxcXCJtaWNyb2Zvcm1hdHNcXFwiPk1pY3JvZm9ybWF0czwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcblxcbiAgPGRpdiBjbGFzcz1cXFwiY29sdW1uIHByZXZpZXctY29sdW1uXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiaGVhZGVyXFxcIj5QcmV2aWV3PC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInByZXZpZXcgc2Nyb2xsYWJsZVxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29udGVudCBzY2hlbWFcXFwiPlxcbiAgICAgICAgXCI7XG4gIHN0YWNrMSA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgJiYgZGVwdGgwLmhhc1NjaGVtYSksIHtoYXNoOnt9LGludmVyc2U6c2VsZi5wcm9ncmFtKDUsIHByb2dyYW01LCBkYXRhKSxmbjpzZWxmLnByb2dyYW0oMywgcHJvZ3JhbTMsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxuICAgICAgPC9kaXY+XFxuXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29udGVudCBvcGVuLWdyYXBoXFxcIj5cXG4gICAgICAgIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoZGVwdGgwICYmIGRlcHRoMC5oYXNPcGVuR3JhcGgpLCB7aGFzaDp7fSxpbnZlcnNlOnNlbGYucHJvZ3JhbSg5LCBwcm9ncmFtOSwgZGF0YSksZm46c2VsZi5wcm9ncmFtKDcsIHByb2dyYW03LCBkYXRhKSxkYXRhOmRhdGF9KTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRlbnQgdHdpdHRlclxcXCI+XFxuICAgICAgPC9kaXY+XFxuXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29udGVudCBtaWNyb2Zvcm1hdHNcXFwiPlxcbiAgICAgICAgXCI7XG4gIHN0YWNrMSA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgJiYgZGVwdGgwLmhhc01pY3JvZm9ybWF0cyksIHtoYXNoOnt9LGludmVyc2U6c2VsZi5wcm9ncmFtKDEzLCBwcm9ncmFtMTMsIGRhdGEpLGZuOnNlbGYucHJvZ3JhbSgxMSwgcHJvZ3JhbTExLCBkYXRhKSxkYXRhOmRhdGF9KTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9KTtcbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZShmdW5jdGlvbiAoSGFuZGxlYmFycyxkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHRoaXMuY29tcGlsZXJJbmZvID0gWzQsJz49IDEuMC4wJ107XG5oZWxwZXJzID0gdGhpcy5tZXJnZShoZWxwZXJzLCBIYW5kbGViYXJzLmhlbHBlcnMpOyBwYXJ0aWFscyA9IHRoaXMubWVyZ2UocGFydGlhbHMsIEhhbmRsZWJhcnMucGFydGlhbHMpOyBkYXRhID0gZGF0YSB8fCB7fTtcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMSwgaGVscGVyLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbiwgc2VsZj10aGlzO1xuXG5mdW5jdGlvbiBwcm9ncmFtMShkZXB0aDAsZGF0YSkge1xuICBcbiAgXG4gIHJldHVybiBcIi9cIjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMyhkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMSwgaGVscGVyO1xuICBidWZmZXIgKz0gXCI8cCBjbGFzcz1cXFwibGluZVxcXCI+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLm5pY2VVaXBsKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLm5pY2VVaXBsKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIiBSRHM8L3A+XCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTUoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazEsIGhlbHBlcjtcbiAgYnVmZmVyICs9IFwiXFxuICAgICAgICAgICAgPHAgY2xhc3M9XFxcImxpbmVcXFwiPlwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5uaWNlUHVpZCkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5uaWNlUHVpZCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCIgbGlua3MgLzwvcD5cXG4gICAgICAgICAgICA8cCBjbGFzcz1cXFwibGluZVxcXCI+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLm5pY2VQaWQpIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAubmljZVBpZCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCIgUkRzPC9wPlxcbiAgICAgICAgICBcIjtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtNyhkZXB0aDAsZGF0YSkge1xuICBcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMTtcbiAgYnVmZmVyICs9IFwiXFxuICAgICAgPGEgaHJlZj1cXFwiaHR0cDovL21vei5jb20vbG9naW5cXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJ0biBsb2NrXFxcIiBkYXRhLXRvb2x0aXA9XFxcIkdldCBtb3JlIG1ldHJpY3M8YnI+PHNwYW4gY2xhc3M9Y3RhPkxvZyBpbiB3aXRoIE1vejwvc3Bhbj5cXFwiPlxcbiAgICAgICAgICBcIjtcbiAgc3RhY2sxID0gc2VsZi5pbnZva2VQYXJ0aWFsKHBhcnRpYWxzWydsb2NrZWQtaWNvbiddLCAnbG9ja2VkLWljb24nLCBkZXB0aDAsIGhlbHBlcnMsIHBhcnRpYWxzLCBkYXRhKTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJvbmJvYXJkaW5nLXRleHRcXFwiPlxcbiAgICAgICAgICAgIExvZyBpbiB0byB5b3VyIDxlbT5Nb3ogUHJvPC9lbT4gYWNjb3VudCBmb3IgbW9yZSBmZWF0dXJlcywgbGlrZSBLZXl3b3JkIERpZmZpY3VsdHkgYW5kIGVuaGFuY2VkIGxpbmsgbWV0cmljcy5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2E+XFxuICAgIFwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9XG5cbiAgYnVmZmVyICs9IFwiPHN0eWxlPlxcblwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5jc3MpIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAuY3NzKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIlxcbjwvc3R5bGU+XFxuPGRpdiBjbGFzcz1cXFwibW96YmFyLWNzcy0jcmFuZG9tLWtleVxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJzZXJwLWl0ZW1cXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwYWdlLXN0YXRzXFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJzdGF0XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInBvc2l0aW9uXFxcIj5cIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMucG9zaXRpb24pIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAucG9zaXRpb24pOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiKTwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidGl0bGVcXFwiPlBBOiBcIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMubmljZVVwYSkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5uaWNlVXBhKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIjwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwic2NhbGUtb3V0ZXJcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzY2FsZS1pbm5lclxcXCIgc3R5bGU9XFxcIndpZHRoOiBcIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMubmljZVVwYSkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5uaWNlVXBhKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIiVcXFwiPjwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwibGlua3NcXFwiPlxcbiAgICAgICAgPGEgaHJlZj1cXFwiaHR0cDovL21vei5jb20vcmVzZWFyY2h0b29scy9vc2UvbGlua3M/c2l0ZT1cIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMucGFnZVVybCkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5wYWdlVXJsKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIiZzcmM9bWJcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5cXG4gICAgICAgICAgPHAgY2xhc3M9XFxcImxpbmVcXFwiPlwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5uaWNlVWlkKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLm5pY2VVaWQpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiIGxpbmtzIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLnVzZXIpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmlzUHJvKSwge2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDEsIHByb2dyYW0xLCBkYXRhKSxkYXRhOmRhdGF9KTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIjwvcD5cXG4gICAgICAgICAgXCI7XG4gIHN0YWNrMSA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAudXNlcikpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuaXNQcm8pLCB7aGFzaDp7fSxpbnZlcnNlOnNlbGYubm9vcCxmbjpzZWxmLnByb2dyYW0oMywgcHJvZ3JhbTMsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxuICAgICAgICA8L2E+XFxuICAgICAgPC9kaXY+XFxuXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiZGl2aWRlclxcXCI+PC9kaXY+XFxuXFxuICAgICAgPGRpdiBjbGFzcz1cXFwic3RhdFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0aXRsZVxcXCI+REE6IFwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5uaWNlUGRhKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLm5pY2VQZGEpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzY2FsZS1vdXRlclxcXCI+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNjYWxlLWlubmVyIGFsdFxcXCIgc3R5bGU9XFxcIndpZHRoOiBcIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMubmljZVBkYSkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5uaWNlUGRhKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIiVcXFwiPjwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuXFxuICAgICAgPGRpdiBjbGFzcz1cXFwibGlua3NcXFwiPlxcbiAgICAgICAgPGEgaHJlZj1cXFwiaHR0cDovL21vei5jb20vcmVzZWFyY2h0b29scy9vc2UvbGlua3M/c2l0ZT1cIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMucm9vdERvbWFpbikgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5yb290RG9tYWluKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIiZzcmM9bWJcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5cXG4gICAgICAgICAgXCI7XG4gIHN0YWNrMSA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAudXNlcikpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuaXNQcm8pLCB7aGFzaDp7fSxpbnZlcnNlOnNlbGYubm9vcCxmbjpzZWxmLnByb2dyYW0oNSwgcHJvZ3JhbTUsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxuICAgICAgICA8L2E+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICBcIjtcbiAgc3RhY2sxID0gaGVscGVycy51bmxlc3MuY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAudXNlcikpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuaXNQcm8pLCB7aGFzaDp7fSxpbnZlcnNlOnNlbGYubm9vcCxmbjpzZWxmLnByb2dyYW0oNywgcHJvZ3JhbTcsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxuXFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInJpZ2h0LXBhbmVsXFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJkaXZpZGVyXFxcIj48L2Rpdj5cXG5cXG4gICAgICA8YSBocmVmPVxcXCJodHRwOi8vbW96LmNvbS9yZXNlYXJjaHRvb2xzL29zZS9saW5rcz9zaXRlPVwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5wYWdlVXJsKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLnBhZ2VVcmwpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiJnNyYz1tYlxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYnRuIGxpbmstYW5hbHlzaXNcXFwiIGRhdGEtdG9vbHRpcD1cXFwiTGluayBBbmFseXNpcyB3aXRoIE9TRVxcXCI+XFxuICAgICAgICAgIFwiO1xuICBzdGFjazEgPSBzZWxmLmludm9rZVBhcnRpYWwocGFydGlhbHNbJ29zZS1pY29uJ10sICdvc2UtaWNvbicsIGRlcHRoMCwgaGVscGVycywgcGFydGlhbHMsIGRhdGEpO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxuICAgICAgICAgIDxwPkxpbmsgQW5hbHlzaXM8L3A+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm9uYm9hcmRpbmctdGV4dFxcXCI+XFxuICAgICAgICAgICAgRG8gYSBkZWVwZXIgbGluayBhbmFseXNpcyBieSBvcGVuaW5nIHRoaXMgcGFnZSBpbiA8ZW0+T3BlbiBTaXRlIEV4cGxvcmVyPC9lbT4uXFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9hPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9KTtcbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZShmdW5jdGlvbiAoSGFuZGxlYmFycyxkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHRoaXMuY29tcGlsZXJJbmZvID0gWzQsJz49IDEuMC4wJ107XG5oZWxwZXJzID0gdGhpcy5tZXJnZShoZWxwZXJzLCBIYW5kbGViYXJzLmhlbHBlcnMpOyBwYXJ0aWFscyA9IHRoaXMubWVyZ2UocGFydGlhbHMsIEhhbmRsZWJhcnMucGFydGlhbHMpOyBkYXRhID0gZGF0YSB8fCB7fTtcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMSwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb24sIHNlbGY9dGhpcztcblxuZnVuY3Rpb24gcHJvZ3JhbTEoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJcXG4gICAgPGRpdiBjbGFzcz1cXFwicmlnaHQtcGFuZWxcXFwiPlxcbiAgICAgIDxhIGhyZWY9XFxcImh0dHA6Ly9tb3ouY29tL2xvZ2luXFxcIiB0YXJnZXQ9J19ibGFuayc+XFxuICAgICAgICBMb2cgaW5cXG4gICAgICA8L2E+XFxuICAgIDwvZGl2PlxcbiAgXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTMoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazE7XG4gIGJ1ZmZlciArPSBcIlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyaWdodC1wYW5lbFxcXCI+XFxuICAgICAgPGEgaHJlZj1cXFwiaHR0cDovL21vei5jb20vY29tbXVuaXR5L3VzZXJzL1wiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC51c2VyKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5kaXNwbGF5X25hbWUpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpXG4gICAgKyBcIlxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPlxcbiAgICAgICAgXCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLnVzZXIpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmRpc3BsYXlfbmFtZSkpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKSlcbiAgICArIFwiXFxuICAgICAgPC9hPlxcblxcbiAgICAgIDxhIGhyZWY9XFxcImh0dHA6Ly9tb3ouY29tL2xvZ291dFxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiIGNsYXNzPVxcXCJsb2dvdXRcXFwiPlxcbiAgICAgICAgTG9nb3V0XFxuICAgICAgPC9hPlxcbiAgXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cblxuICBidWZmZXIgKz0gXCI8ZGl2IGNsYXNzPVxcXCJzZXJwLXRvb2xiYXJcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiYnRuIGV4cG9ydFxcXCIgZGF0YS10b29sdGlwPVxcXCJFeHBvcnQgU0VSUCBBbmFseXNpcyB0byBDU1ZcXFwiPlxcbiAgICBcIjtcbiAgc3RhY2sxID0gc2VsZi5pbnZva2VQYXJ0aWFsKHBhcnRpYWxzWydleHBvcnQtaWNvbiddLCAnZXhwb3J0LWljb24nLCBkZXB0aDAsIGhlbHBlcnMsIHBhcnRpYWxzLCBkYXRhKTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJvbmJvYXJkaW5nLXRleHRcXFwiPlxcbiAgICAgIDxlbT5FeHBvcnQgdGhpcyBTRVJQIHRvIGEgQ1NWLjwvZW0+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuXFxuICA8ZGl2IGNsYXNzPVxcXCJkaXZpZGVyXFxcIj48L2Rpdj5cXG5cXG4gIDxoMz5TZWFyY2ggUHJvZmlsZXM8L2gzPlxcblxcbiAgPGRpdiBjbGFzcz1cXFwiYnRuIHNlYXJjaC1wcm9maWxlIHNlbGVjdGVkXFxcIiBkYXRhLWVuZ2luZT1cXFwiXCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLnByb2ZpbGUpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmVuZ2luZSkpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKSlcbiAgICArIFwiXFxcIlxcbiAgICBkYXRhLXRvb2x0aXA9XFxcIlxcXCI+XFxuICAgICAgXCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLnByb2ZpbGUpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLm5hbWUpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpXG4gICAgKyBcIlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImFycm93IGFycm93LWRvd25cXFwiIC8+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwib25ib2FyZGluZy10ZXh0XFxcIj5cXG4gICAgICAgIDxwPk9wZW4gPGVtPlNlYXJjaCBQcm9maWxlczwvZW0+LjwvcD5cXG4gICAgICAgIDxwPlVzZSB0aGUgTW96QmFyIHRvIHBlcmZvcm0gZ2VvLWxvY2F0ZWQgc2VhcmNoZXMuPC9wPlxcbiAgICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuXFxuICBcIjtcbiAgc3RhY2sxID0gaGVscGVycy51bmxlc3MuY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAudXNlcikpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuaXNQcm8pLCB7aGFzaDp7fSxpbnZlcnNlOnNlbGYubm9vcCxmbjpzZWxmLnByb2dyYW0oMSwgcHJvZ3JhbTEsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxuXFxuICBcIjtcbiAgc3RhY2sxID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC51c2VyKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5pc1BybyksIHtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbSgzLCBwcm9ncmFtMywgZGF0YSksZGF0YTpkYXRhfSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCJcXG48L2Rpdj5cXG5cIjtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfSk7XG4iLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoZnVuY3Rpb24gKEhhbmRsZWJhcnMsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICB0aGlzLmNvbXBpbGVySW5mbyA9IFs0LCc+PSAxLjAuMCddO1xuaGVscGVycyA9IHRoaXMubWVyZ2UoaGVscGVycywgSGFuZGxlYmFycy5oZWxwZXJzKTsgZGF0YSA9IGRhdGEgfHwge307XG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazEsIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb24sIHNlbGY9dGhpcztcblxuZnVuY3Rpb24gcHJvZ3JhbTEoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPlxcbiAgICAgICAgPHA+XFxuICAgICAgICAgIENvbm5lY3RpbmcgeW91ciBNb3ogUHJvIHN1YnNjcmlwdGlvbiBnZXRzIHlvdSBhY2Nlc3MgdG8gbW9yZVxcbiAgICAgICAgICBsaW5rIG1ldHJpY3MgYW5kIGZ1bmN0aW9uYWxpdHkgd2l0aGluIHRoZSBNb3piYXIuXFxuICAgICAgICAgIDxhIGhyZWY9XFxcImh0dHA6Ly9tb3ouY29tL3Byby9tb3piYXJcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5MZWFybiBtb3JlPC9hPlxcbiAgICAgICAgPC9wPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+XFxuICAgICAgICA8YSBjbGFzcz1cXFwibG9naW4tYnV0dG9uXFxcIiBocmVmPVxcXCJodHRwOi8vbW96LmNvbS9sb2dpblxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPlxcbiAgICAgICAgICBMb2dpbiB3aXRoIE1veiBQcm9cXG4gICAgICAgIDwvYT5cXG4gICAgICA8L2Rpdj5cXG4gICAgXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTMoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazEsIGhlbHBlcjtcbiAgYnVmZmVyICs9IFwiXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInByb1xcXCI+XFxuICAgICAgICAgIDxwPkxvZ2dlZCBpbiBhczo8L3A+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInVzZXJuYW1lXFxcIj5cIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMuZGlzcGxheV9uYW1lKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLmRpc3BsYXlfbmFtZSk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCI8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwibG9nb3V0XFxcIj5cXG4gICAgICAgICAgPGEgaHJlZj1cXFwiaHR0cDovL21vei5jb20vbG9nb3V0XFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+KFgpIExvZ291dDwvYT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICBcIjtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG4gIGJ1ZmZlciArPSBcIjxkaXYgY2xhc3M9XFxcImFycm93LXVwXFxcIj48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJjb250ZW50XFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcInBhZGRlZFxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInJvdyBmdWxsXFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPlxcbiAgICAgICAgPGgyPk1vekJhciBTZXR0aW5nczwvaDI+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sIHN3aXRjaC1jb250YWluZXJcXFwiPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRpdGxlXFxcIj5UaGVtZTo8L3NwYW4+XFxuICAgICAgICA8bGFiZWwgY2xhc3M9XFxcInN3aXRjaC1sYWJlbCBsaWdodCBvblxcXCI+RGFyazwvbGFiZWw+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJvbm9mZnN3aXRjaFxcXCI+XFxuICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJjaGVja2JveFxcXCIgbmFtZT1cXFwib25vZmZzd2l0Y2hcXFwiIGNsYXNzPVxcXCJjaGVja2JveFxcXCIgaWQ9XFxcImxpZ2h0ZGFya3N3aXRjaFxcXCI+XFxuICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImxpZ2h0ZGFya3N3aXRjaFxcXCI+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImlubmVyXFxcIj48L3NwYW4+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInN3aXRjaFxcXCI+PC9zcGFuPlxcbiAgICAgICAgICA8L2xhYmVsPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8bGFiZWwgY2xhc3M9XFxcInN3aXRjaC1sYWJlbCBsaWdodFxcXCI+TGlnaHQ8L2xhYmVsPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwiZGl2aWRlclxcXCIgLz5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93IG1ldHJpY3NcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+XFxuICAgICAgICA8bGFiZWw+XFxuICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJjaGVja2JveFxcXCIgZGF0YS1jb2w9XFxcInVtcnBcXFwiPk1velJhbmsgKE1SKTwvaW5wdXQ+XFxuICAgICAgICA8L2xhYmVsPlxcbiAgICAgICAgPGxhYmVsPlxcbiAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIGRhdGEtY29sPVxcXCJwbXJwXFxcIj5Eb21haW4gTW96UmFuayAoRE1SKTwvaW5wdXQ+XFxuICAgICAgICA8L2xhYmVsPlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+XFxuICAgICAgICA8bGFiZWw+XFxuICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJjaGVja2JveFxcXCIgZGF0YS1jb2w9XFxcInV0cnBcXFwiPk1velRydXN0IChNVCk8L2lucHV0PlxcbiAgICAgICAgPC9sYWJlbD5cXG4gICAgICAgIDxsYWJlbD5cXG4gICAgICAgICAgPGlucHV0IHR5cGU9XFxcImNoZWNrYm94XFxcIiBkYXRhLWNvbD1cXFwicHRycFxcXCI+RG9tYWluIE1velRydXN0IChETVQpPC9pbnB1dD5cXG4gICAgICAgIDwvbGFiZWw+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj5cXG4gICAgICAgIDxsYWJlbD5cXG4gICAgICAgICAgPGlucHV0IHR5cGU9XFxcImNoZWNrYm94XFxcIiBkYXRhLWNvbD1cXFwibGlua3NcXFwiPkxpbmsgTWV0cmljczwvaW5wdXQ+XFxuICAgICAgICA8L2xhYmVsPlxcbiAgICAgICAgPGxhYmVsPlxcbiAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIGRhdGEtY29sPVxcXCJmc3BzY1xcXCI+U3BhbSBTY29yZTwvaW5wdXQ+XFxuICAgICAgICA8L2xhYmVsPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwicm93XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2xcXFwiPlxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcInRpcFxcXCI+XFxuICAgICAgICAgIDxlbT5USVA6IEVhc2lseSB0b2dnbGUgdGhlIE1vekJhciBiZXR3ZWVuIG1vZGVzPC9lbT4gKHdpdGhvdXQgZGlzYWJsaW5nIHRoZSBleHRlbnNpb24pXFxuICAgICAgICA8L3NwYW4+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcblxcbiAgICA8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbCBzaG9ydGN1dFxcXCI+XFxuICAgICAgICA8cD48Yj5PU1g6PC9iPiBDbWQrT3B0aW9uK0N0cmwrTTwvcD5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wgc2hvcnRjdXRcXFwiPlxcbiAgICAgICAgPHA+PGVtPldpbmRvd3M6PC9lbT4gU2hpZnQrQ3RybCtBbHQrTTwvcD5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj5cXG4gICAgICAgIDxoMj5Nb3JlIGJ5IE1vejwvaDI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkaXZpZGVyXFxcIj48L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj5cXG4gICAgICAgIDxhIGhyZWY9XFxcImh0dHA6Ly9hbmFseXRpY3MubW96LmNvbS9wcm8vaG9tZVxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPk1veiBDYW1wYWlnbiBEYXNoYm9hcmQ8L2E+XFxuICAgICAgICA8YSBocmVmPVxcXCJodHRwOi8vbW96LmNvbVxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPk1vei5jb208L2E+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJzcGFjZXJcXFwiPjwvZGl2PlxcbiAgICAgICAgPGEgaHJlZj1cXFwiaHR0cDovL21vei5jb20vYmxvZ1xcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPlRoZSBNb3ogQmxvZzwvYT5cXG4gICAgICAgIDxhIGhyZWY9XFxcImh0dHA6Ly9tb3ouY29tL2NvbW11bml0eS9xXFxcIiB0YXJldD1cXFwiX2JsYW5rXFxcIj5RJmFtcDtBPC9hPlxcbiAgICAgIDwvZGl2PlxcblxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbFxcXCI+XFxuICAgICAgICA8YSBocmVmPVxcXCJodHRwOi8vbW96LmNvbS9yZXNlYXJjaHRvb2xzL29zZS9saW5rcz9zaXRlPVwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5wYWdlVXJsKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLnBhZ2VVcmwpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiJnNyYz1tYlxcXCI+T3BlbiBTaXRlIEV4cGxvcmVyPC9hPlxcbiAgICAgICAgPGEgaHJlZj1cXFwiaHR0cDovL21vei5jb20vcmVzZWFyY2h0b29scy9vc2UvcGFnZXM/c2l0ZT1cIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMucGFnZVVybCkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5wYWdlVXJsKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIiZzcmM9bWJcXFwiPlRvcCBQYWdlczwvYT5cXG4gICAgICAgIDxhIGhyZWY9XFxcImh0dHA6Ly9wcm8ubW96LmNvbS90b29scy9rZXl3b3JkLWRpZmZpY3VsdHkvXFxcIj5LZXl3b3JkIEFuYWx5c2lzPC9hPlxcbiAgICAgICAgPGEgaHJlZj1cXFwiaHR0cDovL2dldGxpc3RlZC5vcmc/c3JjPW1iXFxcIj5HZXRMaXN0ZWQ8L2E+XFxuICAgICAgICA8YSBocmVmPVxcXCJodHRwOi8vZnJlc2h3ZWJleHBsb3Jlci5tb3ouY29tXFxcIj5GcmVzaCBXZWIgRXhwbG9yZXI8L2E+XFxuICAgICAgPC9kaXY+XFxuXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sXFxcIj5cXG4gICAgICAgIDxhIGhyZWY9XFxcImh0dHA6Ly9yYW5rdHJhY2tlci5tb3ouY29tLz9zcmM9bWJcXFwiPlJhbmsgVHJhY2tlcjwvYT5cXG4gICAgICAgIDxhIGhyZWY9XFxcImh0dHA6Ly9wcm8ubW96LmNvbS90b29scy9vbi1wYWdlLWtleXdvcmQtb3B0aW1pemF0aW9uL25ld1xcXCI+T24gUGFnZSBHcmFkZXI8L2E+XFxuICAgICAgICA8YSBocmVmPVxcXCJodHRwczovL2ZvbGxvd2Vyd29uay5jb20/c3JjPW1iXFxcIj5Gb2xsb3dlcndvbms8L2E+XFxuICAgICAgICA8YSBocmVmPVxcXCJodHRwOi8vbW96Y2FzdC5jb20/c3JjPW1iXFxcIj5Nb3pDYXN0PC9hPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwicm93IGZ1bGwgbG9naW5cXFwiPlxcbiAgICBcIjtcbiAgc3RhY2sxID0gaGVscGVycy51bmxlc3MuY2FsbChkZXB0aDAsIChkZXB0aDAgJiYgZGVwdGgwLmlzUHJvKSwge2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDEsIHByb2dyYW0xLCBkYXRhKSxkYXRhOmRhdGF9KTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcblxcbiAgICBcIjtcbiAgc3RhY2sxID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKGRlcHRoMCAmJiBkZXB0aDAuaXNQcm8pLCB7aGFzaDp7fSxpbnZlcnNlOnNlbGYubm9vcCxmbjpzZWxmLnByb2dyYW0oMywgcHJvZ3JhbTMsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxuICA8L2Rpdj5cXG5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJhcnJvdy1kb3duXFxcIj48L2Rpdj5cXG5cXG5cIjtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfSk7XG4iLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoZnVuY3Rpb24gKEhhbmRsZWJhcnMsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICB0aGlzLmNvbXBpbGVySW5mbyA9IFs0LCc+PSAxLjAuMCddO1xuaGVscGVycyA9IHRoaXMubWVyZ2UoaGVscGVycywgSGFuZGxlYmFycy5oZWxwZXJzKTsgZGF0YSA9IGRhdGEgfHwge307XG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazEsIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb247XG5cblxuICBidWZmZXIgKz0gXCI8ZGl2IGNsYXNzPVxcXCJzb2NpYWxcXFwiIGRhdGEtdG9vbHRpcD1cXFwiXCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLnRvb2x0aXApIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAudG9vbHRpcCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCJcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiaWNvbiBcIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMuc2l0ZSkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5zaXRlKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIlxcXCI+PC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJjb3VudFxcXCI+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLmNvdW50KSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLmNvdW50KTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIjwvZGl2PlxcbjwvZGl2PlxcblwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9KTtcbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZShmdW5jdGlvbiAoSGFuZGxlYmFycyxkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHRoaXMuY29tcGlsZXJJbmZvID0gWzQsJz49IDEuMC4wJ107XG5oZWxwZXJzID0gdGhpcy5tZXJnZShoZWxwZXJzLCBIYW5kbGViYXJzLmhlbHBlcnMpOyBwYXJ0aWFscyA9IHRoaXMubWVyZ2UocGFydGlhbHMsIEhhbmRsZWJhcnMucGFydGlhbHMpOyBkYXRhID0gZGF0YSB8fCB7fTtcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMSwgc2VsZj10aGlzO1xuXG5cbiAgYnVmZmVyICs9IFwiPGRpdiBjbGFzcz1cXFwidG9vbGJhciB0b29sdGlwLWNvbnRhaW5lclxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJsb2dvXFxcIj48L2Rpdj5cXG5cXG4gIDxkaXYgY2xhc3M9XFxcInRvb2xiYXItcGFuZWxcXFwiPjwvZGl2PlxcblxcbiAgPGRpdiBjbGFzcz1cXFwicmlnaHQtcGFuZWxcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJidG4gaGVscFxcXCIgZGF0YS10b29sdGlwPVxcXCJIZWxwXFxcIj5cXG4gICAgICA8cD4/PC9wPlxcblxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIm9uYm9hcmRpbmctdGV4dFxcXCI+XFxuICAgICAgICA8cD5HZXQgPGVtPkhlbHA8L2VtPi48L3A+XFxuXFxuICAgICAgICA8cD5GaW5kIGhlbHAgb24gdGhlIE1vekJhciBhbmQgcmVxdWVzdCBmZWF0dXJlcywgYW5kIGdldCBiYWNrIHRvIHRoaXMgdHV0b3JpYWwuPC9wPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG5cXG4gICAgPGRpdiBjbGFzcz1cXFwiZGl2aWRlclxcXCI+PC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcImJ0biBzZXR0aW5nc1xcXCIgZGF0YS10b29sdGlwPVxcXCJUb29scyAmYW1wOyBTZXR0aW5nc1xcXCI+XFxuICAgICAgXCI7XG4gIHN0YWNrMSA9IHNlbGYuaW52b2tlUGFydGlhbChwYXJ0aWFsc1snc2V0dGluZ3MtaWNvbiddLCAnc2V0dGluZ3MtaWNvbicsIGRlcHRoMCwgaGVscGVycywgcGFydGlhbHMsIGRhdGEpO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxuXFxuICAgICAgPGRpdiBjbGFzcz1cXFwib25ib2FyZGluZy10ZXh0XFxcIj5cXG4gICAgICAgIDxwPk9wZW4gPGVtPlRvb2wgYW5kIFNldHRpbmdzPC9lbT4uXFxuXFxuICAgICAgICA8cD5DdXN0b21pemUgeW91ciBNb3pCYXIgdG8gZml0IHlvdXIgbmVlZHMgYW5kIGxvb2sgYXMgd2VsbCBhcyBhY2Nlc3MgaGVscGZ1bCBsaW5rcy48L3A+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJidG4gZG9ja1xcXCIgZGF0YS10b29sdGlwPVxcXCJEb2NrIHRvIEJvdHRvbSBvZiBCcm93c2VyXFxcIj5cXG4gICAgICBcIjtcbiAgc3RhY2sxID0gc2VsZi5pbnZva2VQYXJ0aWFsKHBhcnRpYWxzWydkb2NrLWljb24nXSwgJ2RvY2staWNvbicsIGRlcHRoMCwgaGVscGVycywgcGFydGlhbHMsIGRhdGEpO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJidG4gY2xvc2VcXFwiIGRhdGEtdG9vbHRpcD1cXFwiVHVybiBPZmY8YnIgLz5Nb3pCYXJcXFwiID5cXG4gICAgICBcIjtcbiAgc3RhY2sxID0gc2VsZi5pbnZva2VQYXJ0aWFsKHBhcnRpYWxzWydjbG9zZS1pY29uJ10sICdjbG9zZS1pY29uJywgZGVwdGgwLCBoZWxwZXJzLCBwYXJ0aWFscywgZGF0YSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJvbmJvYXJkaW5nLXRleHRcXFwiPlxcbiAgICAgICAgPHA+PGVtPlR1cm4gb2ZmIHRoZSBNb3pCYXI8L2VtPi48L3A+XFxuXFxuICAgICAgICA8cD5Zb3UgY2FuIHR1cm4gaXQgb24gYXQgYW55IHRpbWUgYnkgY2xpY2tpbmcgdGhlIDxzcGFuIGNsYXNzPVxcXCJpY29uIG9mZlxcXCI+PC9zcGFuPiBpY29uIHRvIHRoZSByaWdodCBvZiB0aGUgYWRkcmVzcyBiYXIuPC9wPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcInBhbmVsXFxcIj48L2Rpdj5cXG5cIjtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfSk7XG4iLCIvLyBoYnNmeSBjb21waWxlZCBIYW5kbGViYXJzIHRlbXBsYXRlXG52YXIgSGFuZGxlYmFyc0NvbXBpbGVyID0gcmVxdWlyZSgnaGJzZnkvcnVudGltZScpO1xubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGViYXJzQ29tcGlsZXIudGVtcGxhdGUoZnVuY3Rpb24gKEhhbmRsZWJhcnMsZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xuICB0aGlzLmNvbXBpbGVySW5mbyA9IFs0LCc+PSAxLjAuMCddO1xuaGVscGVycyA9IHRoaXMubWVyZ2UoaGVscGVycywgSGFuZGxlYmFycy5oZWxwZXJzKTsgZGF0YSA9IGRhdGEgfHwge307XG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazEsIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb247XG5cblxuICBidWZmZXIgKz0gXCI8ZGl2IGNsYXNzPVxcXCJcIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMucGxhY2VtZW50KSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLnBsYWNlbWVudCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCJcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiYXJyb3ctdXBcXFwiPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwidGV4dFxcXCI+PHA+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLnRleHQpIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAudGV4dCk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIjwvcD48L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcImFycm93LWRvd25cXFwiPjwvZGl2PlxcbjwvZGl2PlxcblwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9KTtcbiIsIi8vIGhic2Z5IGNvbXBpbGVkIEhhbmRsZWJhcnMgdGVtcGxhdGVcbnZhciBIYW5kbGViYXJzQ29tcGlsZXIgPSByZXF1aXJlKCdoYnNmeS9ydW50aW1lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEhhbmRsZWJhcnNDb21waWxlci50ZW1wbGF0ZShmdW5jdGlvbiAoSGFuZGxlYmFycyxkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gIHRoaXMuY29tcGlsZXJJbmZvID0gWzQsJz49IDEuMC4wJ107XG5oZWxwZXJzID0gdGhpcy5tZXJnZShoZWxwZXJzLCBIYW5kbGViYXJzLmhlbHBlcnMpOyBkYXRhID0gZGF0YSB8fCB7fTtcbiAgdmFyIGJ1ZmZlciA9IFwiXCIsIHN0YWNrMSwgaGVscGVyLCBvcHRpb25zLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbiwgc2VsZj10aGlzLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZztcblxuZnVuY3Rpb24gcHJvZ3JhbTEoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIFxuICByZXR1cm4gXCJcXG4gIFR3aXR0ZXIgY2FyZHMgZm91bmQgb24gdGhpcyBwYWdlLlxcblwiO1xuICB9XG5cbmZ1bmN0aW9uIHByb2dyYW0zKGRlcHRoMCxkYXRhKSB7XG4gIFxuICBcbiAgcmV0dXJuIFwiXFxuICA8cD5Ud2l0dGVyIENhcmRzIG5vdCBmb3VuZCBvbiB0aGlzIHBhZ2UuPC9wPlxcblxcbiAgPHA+XFxuICAgIEltcGxlbWVudGluZyBUd2l0dGVyIENhcmRzIG1ldGFkYXRhIGRldGVybWluZXMgaG93IGEgcGFnZSBhcHBlYXJzIHdoZW4gaXQgaXMgc2hhcmVkIG9uIFR3aXR0ZXIuIFRoaXMgY2FuIGluY3JlYXNlIGVuZ2FnZW1lbnQuXFxuICA8L3A+XFxuXFxuICA8cD5cXG4gICAgVG8gbGVhcm4gbW9yZSBhYm91dCBUd2l0dGVyIENhcmRzLCB2aXNpdCB0aGVcXG4gICAgICA8YSBocmVmPVxcXCJodHRwczovL2Rldi50d2l0dGVyLmNvbS9kb2NzL2NhcmRzXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+XFxuICAgICAgICBUd2l0dGVyIGNhcmRcXG4gICAgICA8L2E+XFxuICAgIGRvY3VtZW50YXRpb24uXFxuICA8L3A+XFxuXCI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTUoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazEsIGhlbHBlcjtcbiAgYnVmZmVyICs9IFwiXFxuICA8ZGl2IGNsYXNzPVxcXCJzdW1tYXJ5XFxcIj5cXG4gICAgPGgzPlN1bW1hcnkgQ2FyZDwvaDM+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNpdGVcXFwiPlxcbiAgICAgIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLnNpdGUpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmltYWdlKSwge2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDYsIHByb2dyYW02LCBkYXRhKSxkYXRhOmRhdGF9KTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcbiAgICAgIFwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5zaXRlKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5uYW1lKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKVxuICAgICsgXCJcXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbnRhaW5lclxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sMVxcXCI+XFxuICAgICAgICA8aDQ+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLnRpdGxlKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLnRpdGxlKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIjwvaDQ+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJieWxpbmVcXFwiPlwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5jcmVhdG9yKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5uYW1lKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKVxuICAgICsgXCIgXCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLmNyZWF0b3IpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmhhbmRsZSkpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKSlcbiAgICArIFwiIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYmx1cmJcXFwiPlwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5kZXNjcmlwdGlvbikgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5kZXNjcmlwdGlvbik7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCI8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wyXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNhcmQtaW1hZ2VcXFwiIHN0eWxlPVxcXCJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ1wiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5pbWFnZSkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5pbWFnZSk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCInKVxcXCI+PC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cbmZ1bmN0aW9uIHByb2dyYW02KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gXCJcIiwgc3RhY2sxO1xuICBidWZmZXIgKz0gXCI8aW1nIHNyYz1cXFwiXCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLnNpdGUpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmltYWdlKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKVxuICAgICsgXCJcXFwiIC8+XCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTgoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazEsIGhlbHBlcjtcbiAgYnVmZmVyICs9IFwiXFxuICA8ZGl2IGNsYXNzPVxcXCJzdW1tYXJ5LWxhcmdlLWltYWdlXFxcIj5cXG4gICAgPGgzPlN1bW1hcnkgTGFyZ2UgSW1hZ2UgQ2FyZDwvaDM+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNpdGVcXFwiPlxcbiAgICAgIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLnNpdGUpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmltYWdlKSwge2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDYsIHByb2dyYW02LCBkYXRhKSxkYXRhOmRhdGF9KTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcbiAgICAgIFwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5zaXRlKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5uYW1lKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKVxuICAgICsgXCJcXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNhcmQtaW1hZ2VcXFwiPjxpbWcgc3JjPVxcXCJcIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMuaW1hZ2UpIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAuaW1hZ2UpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiXFxcIiAvPjwvZGl2PlxcbiAgICA8aDQ+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLnRpdGxlKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLnRpdGxlKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIjwvaDQ+XFxuICAgIDxkaXYgY2xhc3M9XFxcImJ5bGluZVxcXCI+XCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLmNyZWF0b3IpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLm5hbWUpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpXG4gICAgKyBcIiBcIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAuY3JlYXRvcikpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuaGFuZGxlKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKVxuICAgICsgXCIgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImJsdXJiXFxcIj5cIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMuZGVzY3JpcHRpb24pIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAuZGVzY3JpcHRpb24pOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiPC9kaXY+XFxuICA8L2Rpdj5cXG5cIjtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMTAoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazEsIGhlbHBlcjtcbiAgYnVmZmVyICs9IFwiXFxuICA8ZGl2IGNsYXNzPVxcXCJwcm9kdWN0XFxcIj5cXG4gICAgPGgzPlByb2R1Y3QgQ2FyZDwvaDM+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNpdGVcXFwiPlxcbiAgICAgIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLnNpdGUpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmltYWdlKSwge2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDYsIHByb2dyYW02LCBkYXRhKSxkYXRhOmRhdGF9KTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcbiAgICAgIFwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5zaXRlKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5uYW1lKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKVxuICAgICsgXCJcXG4gICAgPC9kaXY+XFxuICAgIDxoND5cIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMudGl0bGUpIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAudGl0bGUpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiPC9oND5cXG4gICAgQnkgPGRpdiBjbGFzcz1cXFwiYnlsaW5lXFxcIj5cIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAuY3JlYXRvcikpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEubmFtZSkpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKSlcbiAgICArIFwiIFwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5jcmVhdG9yKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5oYW5kbGUpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpXG4gICAgKyBcIiA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2wxXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNhcmQtaW1hZ2VcXFwiIHN0eWxlPVxcXCJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ1wiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5pbWFnZSkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5pbWFnZSk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCInKVxcXCI+PC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sMlxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkaXZpZGVyXFxcIj48L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImRhdGFcXFwiPlwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5kYXRhMSkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5kYXRhMSk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCI8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImxhYmVsXFxcIj5cIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMubGFiZWwxKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLmxhYmVsMSk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCI8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImRpdmlkZXJcXFwiPjwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZGF0YVxcXCI+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLmRhdGEyKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLmRhdGEyKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIjwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwibGFiZWxcXFwiPlwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5sYWJlbDIpIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAubGFiZWwyKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIjwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZGl2aWRlclxcXCI+PC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJibHVyYlxcXCI+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLmRlc2NyaXB0aW9uKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLmRlc2NyaXB0aW9uKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIjwvZGl2PlxcbiAgPC9kaXY+XFxuXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTEyKGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gXCJcIiwgc3RhY2sxLCBoZWxwZXI7XG4gIGJ1ZmZlciArPSBcIlxcbiAgPGRpdiBjbGFzcz1cXFwicGhvdG9cXFwiPlxcbiAgICA8aDM+UGhvdG8gQ2FyZDwvaDM+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNhcmQtaW1hZ2VcXFwiPjxpbWcgc3JjPVxcXCJcIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMuaW1hZ2UpIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAuaW1hZ2UpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiXFxcIiAvPjwvZGl2PlxcbiAgICA8aDQ+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLnRpdGxlKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLnRpdGxlKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIjwvaDQ+XFxuICAgIDxkaXYgY2xhc3M9XFxcImJ5bGluZVxcXCI+XCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLmNyZWF0b3IpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLm5hbWUpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpXG4gICAgKyBcIiBcIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAuY3JlYXRvcikpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuaGFuZGxlKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKVxuICAgICsgXCIgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImJsdXJiXFxcIj5cIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMuZGVzY3JpcHRpb24pIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAuZGVzY3JpcHRpb24pOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNpdGVcXFwiPlxcbiAgICAgIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLnNpdGUpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmltYWdlKSwge2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDYsIHByb2dyYW02LCBkYXRhKSxkYXRhOmRhdGF9KTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcbiAgICAgIFwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5zaXRlKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5uYW1lKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKVxuICAgICsgXCJcXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG5cIjtcbiAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuXG5mdW5jdGlvbiBwcm9ncmFtMTQoZGVwdGgwLGRhdGEpIHtcbiAgXG4gIHZhciBidWZmZXIgPSBcIlwiLCBzdGFjazEsIGhlbHBlcjtcbiAgYnVmZmVyICs9IFwiXFxuICA8ZGl2IGNsYXNzPVxcXCJnYWxsZXJ5XFxcIj5cXG4gICAgPGgzPkdhbGxlcnkgQ2FyZDwvaDM+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNpdGVcXFwiPlxcbiAgICAgIFwiO1xuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLnNpdGUpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmltYWdlKSwge2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDYsIHByb2dyYW02LCBkYXRhKSxkYXRhOmRhdGF9KTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcbiAgICAgIFwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5zaXRlKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5uYW1lKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKVxuICAgICsgXCJcXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNhcmQtaW1hZ2VcXFwiIHN0eWxlPVxcXCJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ1wiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5pbWFnZTApIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAuaW1hZ2UwKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIicpXFxcIj48L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY2FyZC1pbWFnZVxcXCIgc3R5bGU9XFxcImJhY2tncm91bmQtaW1hZ2U6IHVybCgnXCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLmltYWdlMSkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC5pbWFnZTEpOyBzdGFjazEgPSB0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pIDogaGVscGVyOyB9XG4gIGJ1ZmZlciArPSBlc2NhcGVFeHByZXNzaW9uKHN0YWNrMSlcbiAgICArIFwiJylcXFwiPjwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjYXJkLWltYWdlXFxcIiBzdHlsZT1cXFwiYmFja2dyb3VuZC1pbWFnZTogdXJsKCdcIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMuaW1hZ2UyKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLmltYWdlMik7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCInKVxcXCI+PC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNhcmQtaW1hZ2VcXFwiIHN0eWxlPVxcXCJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ1wiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy5pbWFnZTMpIHsgc3RhY2sxID0gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KTsgfVxuICBlbHNlIHsgaGVscGVyID0gKGRlcHRoMCAmJiBkZXB0aDAuaW1hZ2UzKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIicpXFxcIj48L2Rpdj5cXG4gICAgPGg0PlwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy50aXRsZSkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC50aXRsZSk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCI8L2g0PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJieWxpbmVcXFwiPlwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5jcmVhdG9yKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5uYW1lKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKVxuICAgICsgXCIgXCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLmNyZWF0b3IpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmhhbmRsZSkpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKSlcbiAgICArIFwiIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJibHVyYlxcXCI+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLmRlc2NyaXB0aW9uKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLmRlc2NyaXB0aW9uKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIjwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJzaXRlXFxcIj5cXG4gICAgICBcIjtcbiAgc3RhY2sxID0gaGVscGVyc1snaWYnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5zaXRlKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5pbWFnZSksIHtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbSg2LCBwcm9ncmFtNiwgZGF0YSksZGF0YTpkYXRhfSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCJcXG4gICAgICBcIlxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAuc2l0ZSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEubmFtZSkpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKSlcbiAgICArIFwiXFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cblxuZnVuY3Rpb24gcHJvZ3JhbTE2KGRlcHRoMCxkYXRhKSB7XG4gIFxuICB2YXIgYnVmZmVyID0gXCJcIiwgc3RhY2sxLCBoZWxwZXI7XG4gIGJ1ZmZlciArPSBcIlxcbiAgPGRpdiBjbGFzcz1cXFwicGxheWVyXFxcIj5cXG4gICAgPGgzPlBsYXllciBDYXJkPC9oMz5cXG4gICAgPGRpdiBjbGFzcz1cXFwic2l0ZVxcXCI+XFxuICAgICAgXCI7XG4gIHN0YWNrMSA9IGhlbHBlcnNbJ2lmJ10uY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKGRlcHRoMCAmJiBkZXB0aDAuc2l0ZSkpLHN0YWNrMSA9PSBudWxsIHx8IHN0YWNrMSA9PT0gZmFsc2UgPyBzdGFjazEgOiBzdGFjazEuaW1hZ2UpLCB7aGFzaDp7fSxpbnZlcnNlOnNlbGYubm9vcCxmbjpzZWxmLnByb2dyYW0oNiwgcHJvZ3JhbTYsIGRhdGEpLGRhdGE6ZGF0YX0pO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxuICAgICAgXCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLnNpdGUpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLm5hbWUpKSx0eXBlb2Ygc3RhY2sxID09PSBmdW5jdGlvblR5cGUgPyBzdGFjazEuYXBwbHkoZGVwdGgwKSA6IHN0YWNrMSkpXG4gICAgKyBcIlxcbiAgICA8L2Rpdj5cXG4gICAgPGlmcmFtZSB3aWR0aD1cXFwiNTAwXFxcIiBoZWlnaHQ9XFxcIjM3NVxcXCIgc3JjPVxcXCJcIjtcbiAgaWYgKGhlbHBlciA9IGhlbHBlcnMucGxheWVyKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLnBsYXllcik7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCJcXFwiXFxuICAgICAgZnJhbWVib3JkZXI9XFxcIjBcXFwiIGFsbG93ZnVsbHNjcmVlbj48L2lmcmFtZT5cXG5cXG4gICAgPGg0PlwiO1xuICBpZiAoaGVscGVyID0gaGVscGVycy50aXRsZSkgeyBzdGFjazEgPSBoZWxwZXIuY2FsbChkZXB0aDAsIHtoYXNoOnt9LGRhdGE6ZGF0YX0pOyB9XG4gIGVsc2UgeyBoZWxwZXIgPSAoZGVwdGgwICYmIGRlcHRoMC50aXRsZSk7IHN0YWNrMSA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSkgOiBoZWxwZXI7IH1cbiAgYnVmZmVyICs9IGVzY2FwZUV4cHJlc3Npb24oc3RhY2sxKVxuICAgICsgXCI8L2g0PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJieWxpbmVcXFwiPlwiXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICYmIGRlcHRoMC5jcmVhdG9yKSksc3RhY2sxID09IG51bGwgfHwgc3RhY2sxID09PSBmYWxzZSA/IHN0YWNrMSA6IHN0YWNrMS5uYW1lKSksdHlwZW9mIHN0YWNrMSA9PT0gZnVuY3Rpb25UeXBlID8gc3RhY2sxLmFwcGx5KGRlcHRoMCkgOiBzdGFjazEpKVxuICAgICsgXCIgXCJcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgJiYgZGVwdGgwLmNyZWF0b3IpKSxzdGFjazEgPT0gbnVsbCB8fCBzdGFjazEgPT09IGZhbHNlID8gc3RhY2sxIDogc3RhY2sxLmhhbmRsZSkpLHR5cGVvZiBzdGFjazEgPT09IGZ1bmN0aW9uVHlwZSA/IHN0YWNrMS5hcHBseShkZXB0aDApIDogc3RhY2sxKSlcbiAgICArIFwiIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJibHVyYlxcXCI+XCI7XG4gIGlmIChoZWxwZXIgPSBoZWxwZXJzLmRlc2NyaXB0aW9uKSB7IHN0YWNrMSA9IGhlbHBlci5jYWxsKGRlcHRoMCwge2hhc2g6e30sZGF0YTpkYXRhfSk7IH1cbiAgZWxzZSB7IGhlbHBlciA9IChkZXB0aDAgJiYgZGVwdGgwLmRlc2NyaXB0aW9uKTsgc3RhY2sxID0gdHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7aGFzaDp7fSxkYXRhOmRhdGF9KSA6IGhlbHBlcjsgfVxuICBidWZmZXIgKz0gZXNjYXBlRXhwcmVzc2lvbihzdGFjazEpXG4gICAgKyBcIjwvZGl2PlxcbiAgPC9kaXY+XFxuXCI7XG4gIHJldHVybiBidWZmZXI7XG4gIH1cblxuICBzdGFjazEgPSBoZWxwZXJzWydpZiddLmNhbGwoZGVwdGgwLCAoZGVwdGgwICYmIGRlcHRoMC5oYXNUd2l0dGVyKSwge2hhc2g6e30saW52ZXJzZTpzZWxmLnByb2dyYW0oMywgcHJvZ3JhbTMsIGRhdGEpLGZuOnNlbGYucHJvZ3JhbSgxLCBwcm9ncmFtMSwgZGF0YSksZGF0YTpkYXRhfSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCJcXG5cXG5cIjtcbiAgc3RhY2sxID0gKGhlbHBlciA9IGhlbHBlcnMuaWZFcXVhbCB8fCAoZGVwdGgwICYmIGRlcHRoMC5pZkVxdWFsKSxvcHRpb25zPXtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbSg1LCBwcm9ncmFtNSwgZGF0YSksZGF0YTpkYXRhfSxoZWxwZXIgPyBoZWxwZXIuY2FsbChkZXB0aDAsIChkZXB0aDAgJiYgZGVwdGgwLmNhcmRUeXBlKSwgXCJzdW1tYXJ5XCIsIG9wdGlvbnMpIDogaGVscGVyTWlzc2luZy5jYWxsKGRlcHRoMCwgXCJpZkVxdWFsXCIsIChkZXB0aDAgJiYgZGVwdGgwLmNhcmRUeXBlKSwgXCJzdW1tYXJ5XCIsIG9wdGlvbnMpKTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcblxcblwiO1xuICBzdGFjazEgPSAoaGVscGVyID0gaGVscGVycy5pZkVxdWFsIHx8IChkZXB0aDAgJiYgZGVwdGgwLmlmRXF1YWwpLG9wdGlvbnM9e2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDgsIHByb2dyYW04LCBkYXRhKSxkYXRhOmRhdGF9LGhlbHBlciA/IGhlbHBlci5jYWxsKGRlcHRoMCwgKGRlcHRoMCAmJiBkZXB0aDAuY2FyZFR5cGUpLCBcInN1bW1hcnlfbGFyZ2VfaW1hZ2VcIiwgb3B0aW9ucykgOiBoZWxwZXJNaXNzaW5nLmNhbGwoZGVwdGgwLCBcImlmRXF1YWxcIiwgKGRlcHRoMCAmJiBkZXB0aDAuY2FyZFR5cGUpLCBcInN1bW1hcnlfbGFyZ2VfaW1hZ2VcIiwgb3B0aW9ucykpO1xuICBpZihzdGFjazEgfHwgc3RhY2sxID09PSAwKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cbiAgYnVmZmVyICs9IFwiXFxuXFxuXCI7XG4gIHN0YWNrMSA9IChoZWxwZXIgPSBoZWxwZXJzLmlmRXF1YWwgfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWZFcXVhbCksb3B0aW9ucz17aGFzaDp7fSxpbnZlcnNlOnNlbGYubm9vcCxmbjpzZWxmLnByb2dyYW0oMTAsIHByb2dyYW0xMCwgZGF0YSksZGF0YTpkYXRhfSxoZWxwZXIgPyBoZWxwZXIuY2FsbChkZXB0aDAsIChkZXB0aDAgJiYgZGVwdGgwLmNhcmRUeXBlKSwgXCJwcm9kdWN0XCIsIG9wdGlvbnMpIDogaGVscGVyTWlzc2luZy5jYWxsKGRlcHRoMCwgXCJpZkVxdWFsXCIsIChkZXB0aDAgJiYgZGVwdGgwLmNhcmRUeXBlKSwgXCJwcm9kdWN0XCIsIG9wdGlvbnMpKTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcblxcblwiO1xuICBzdGFjazEgPSAoaGVscGVyID0gaGVscGVycy5pZkVxdWFsIHx8IChkZXB0aDAgJiYgZGVwdGgwLmlmRXF1YWwpLG9wdGlvbnM9e2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDEyLCBwcm9ncmFtMTIsIGRhdGEpLGRhdGE6ZGF0YX0saGVscGVyID8gaGVscGVyLmNhbGwoZGVwdGgwLCAoZGVwdGgwICYmIGRlcHRoMC5jYXJkVHlwZSksIFwicGhvdG9cIiwgb3B0aW9ucykgOiBoZWxwZXJNaXNzaW5nLmNhbGwoZGVwdGgwLCBcImlmRXF1YWxcIiwgKGRlcHRoMCAmJiBkZXB0aDAuY2FyZFR5cGUpLCBcInBob3RvXCIsIG9wdGlvbnMpKTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcblxcblwiO1xuICBzdGFjazEgPSAoaGVscGVyID0gaGVscGVycy5pZkVxdWFsIHx8IChkZXB0aDAgJiYgZGVwdGgwLmlmRXF1YWwpLG9wdGlvbnM9e2hhc2g6e30saW52ZXJzZTpzZWxmLm5vb3AsZm46c2VsZi5wcm9ncmFtKDE0LCBwcm9ncmFtMTQsIGRhdGEpLGRhdGE6ZGF0YX0saGVscGVyID8gaGVscGVyLmNhbGwoZGVwdGgwLCAoZGVwdGgwICYmIGRlcHRoMC5jYXJkVHlwZSksIFwiZ2FsbGVyeVwiLCBvcHRpb25zKSA6IGhlbHBlck1pc3NpbmcuY2FsbChkZXB0aDAsIFwiaWZFcXVhbFwiLCAoZGVwdGgwICYmIGRlcHRoMC5jYXJkVHlwZSksIFwiZ2FsbGVyeVwiLCBvcHRpb25zKSk7XG4gIGlmKHN0YWNrMSB8fCBzdGFjazEgPT09IDApIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxuICBidWZmZXIgKz0gXCJcXG5cXG5cIjtcbiAgc3RhY2sxID0gKGhlbHBlciA9IGhlbHBlcnMuaWZFcXVhbCB8fCAoZGVwdGgwICYmIGRlcHRoMC5pZkVxdWFsKSxvcHRpb25zPXtoYXNoOnt9LGludmVyc2U6c2VsZi5ub29wLGZuOnNlbGYucHJvZ3JhbSgxNiwgcHJvZ3JhbTE2LCBkYXRhKSxkYXRhOmRhdGF9LGhlbHBlciA/IGhlbHBlci5jYWxsKGRlcHRoMCwgKGRlcHRoMCAmJiBkZXB0aDAuY2FyZFR5cGUpLCBcInBsYXllclwiLCBvcHRpb25zKSA6IGhlbHBlck1pc3NpbmcuY2FsbChkZXB0aDAsIFwiaWZFcXVhbFwiLCAoZGVwdGgwICYmIGRlcHRoMC5jYXJkVHlwZSksIFwicGxheWVyXCIsIG9wdGlvbnMpKTtcbiAgaWYoc3RhY2sxIHx8IHN0YWNrMSA9PT0gMCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XG4gIGJ1ZmZlciArPSBcIlxcblwiO1xuICByZXR1cm4gYnVmZmVyO1xuICB9KTtcbiIsbnVsbCwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzLWFycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxudmFyIGtNYXhMZW5ndGggPSAweDNmZmZmZmZmXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIE5vdGU6XG4gKlxuICogLSBJbXBsZW1lbnRhdGlvbiBtdXN0IHN1cHBvcnQgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMuXG4gKiAgIEZpcmVmb3ggNC0yOSBsYWNrZWQgc3VwcG9ydCwgZml4ZWQgaW4gRmlyZWZveCAzMCsuXG4gKiAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG4gKlxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXkgd2lsbFxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgd2lsbCB3b3JrIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSAoZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIDQyID09PSBhcnIuZm9vKCkgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoMSkuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKVxuXG4gIHZhciB0eXBlID0gdHlwZW9mIHN1YmplY3RcblxuICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgdmFyIGxlbmd0aFxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpXG4gICAgbGVuZ3RoID0gc3ViamVjdCA+IDAgPyBzdWJqZWN0ID4+PiAwIDogMFxuICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpXG4gICAgICBzdWJqZWN0ID0gYmFzZTY0Y2xlYW4oc3ViamVjdClcbiAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiBzdWJqZWN0ICE9PSBudWxsKSB7IC8vIGFzc3VtZSBvYmplY3QgaXMgYXJyYXktbGlrZVxuICAgIGlmIChzdWJqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkoc3ViamVjdC5kYXRhKSlcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0LmRhdGFcbiAgICBsZW5ndGggPSArc3ViamVjdC5sZW5ndGggPiAwID8gTWF0aC5mbG9vcigrc3ViamVjdC5sZW5ndGgpIDogMFxuICB9IGVsc2VcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHN0YXJ0IHdpdGggbnVtYmVyLCBidWZmZXIsIGFycmF5IG9yIHN0cmluZycpXG5cbiAgaWYgKHRoaXMubGVuZ3RoID4ga01heExlbmd0aClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuXG4gIHZhciBidWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUHJlZmVycmVkOiBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGJ1ZiA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gVEhJUyBpbnN0YW5jZSBvZiBCdWZmZXIgKGNyZWF0ZWQgYnkgYG5ld2ApXG4gICAgYnVmID0gdGhpc1xuICAgIGJ1Zi5sZW5ndGggPSBsZW5ndGhcbiAgICBidWYuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBzdWJqZWN0LmJ5dGVMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gU3BlZWQgb3B0aW1pemF0aW9uIC0tIHVzZSBzZXQgaWYgd2UncmUgY29weWluZyBmcm9tIGEgdHlwZWQgYXJyYXlcbiAgICBidWYuX3NldChzdWJqZWN0KVxuICB9IGVsc2UgaWYgKGlzQXJyYXlpc2goc3ViamVjdCkpIHtcbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXlcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3QucmVhZFVJbnQ4KGkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgYnVmW2ldID0gKChzdWJqZWN0W2ldICUgMjU2KSArIDI1NikgJSAyNTZcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBidWYud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICFub1plcm8pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IDBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuICYmIGFbaV0gPT09IGJbaV07IGkrKykge31cbiAgaWYgKGkgIT09IGxlbikge1xuICAgIHggPSBhW2ldXG4gICAgeSA9IGJbaV1cbiAgfVxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdFssIGxlbmd0aF0pJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGxpc3RbMF1cbiAgfVxuXG4gIHZhciBpXG4gIGlmICh0b3RhbExlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdG90YWxMZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICB2YXIgcmV0XG4gIHN0ciA9IHN0ciArICcnXG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgJ3V0ZjgnKSB7XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAncmF3JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggKiAyXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoID4+PiAxXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vLyBwcmUtc2V0IGZvciB2YWx1ZXMgdGhhdCBtYXkgZXhpc3QgaW4gdGhlIGZ1dHVyZVxuQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSB1bmRlZmluZWRcbkJ1ZmZlci5wcm90b3R5cGUucGFyZW50ID0gdW5kZWZpbmVkXG5cbi8vIHRvU3RyaW5nKGVuY29kaW5nLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA9PT0gSW5maW5pdHkgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG4gIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmIChlbmQgPD0gc3RhcnQpIHJldHVybiAnJ1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGIpIHtcbiAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpXG4gICAgICBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbi8vIGBnZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihieXRlKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gdXRmMTZsZVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCwgMilcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSB1dGYxNmxlV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmVzID0gJydcbiAgdmFyIHRtcCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChidWZbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgICAgIHRtcCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcCArPSAnJScgKyBidWZbaV0udG9TdHJpbmcoMTYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcClcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBiaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBhc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZClcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuO1xuICAgIGlmIChzdGFydCA8IDApXG4gICAgICBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMClcbiAgICAgIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydClcbiAgICBlbmQgPSBzdGFydFxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHJldHVybiBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIHZhciBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQsIHRydWUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0J1ZlxuICB9XG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKVxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpXG4gICAgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXNcblxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoIXRhcmdldF9zdGFydCkgdGFyZ2V0X3N0YXJ0ID0gMFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHNvdXJjZS5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpXG4gIGlmICh0YXJnZXRfc3RhcnQgPCAwIHx8IHRhcmdldF9zdGFydCA+PSB0YXJnZXQubGVuZ3RoKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHNvdXJjZS5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiBzb3VyY2UubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKVxuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0IDwgZW5kIC0gc3RhcnQpXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0X3N0YXJ0KVxuICB9XG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSB1dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuY29uc3RydWN0b3IgPSBCdWZmZXJcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IGdldC9zZXQgbWV0aG9kcyBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9nZXQgPSBhcnIuZ2V0XG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmVxdWFscyA9IEJQLmVxdWFsc1xuICBhcnIuY29tcGFyZSA9IEJQLmNvbXBhcmVcbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLXpdL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiBpc0FycmF5aXNoIChzdWJqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5KHN1YmplY3QpIHx8IEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSB8fFxuICAgICAgc3ViamVjdCAmJiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBzdWJqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBpZiAoYiA8PSAweDdGKSB7XG4gICAgICBieXRlQXJyYXkucHVzaChiKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhcnQgPSBpXG4gICAgICBpZiAoYiA+PSAweEQ4MDAgJiYgYiA8PSAweERGRkYpIGkrK1xuICAgICAgdmFyIGggPSBlbmNvZGVVUklDb21wb25lbnQoc3RyLnNsaWNlKHN0YXJ0LCBpKzEpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHBhcnNlSW50KGhbal0sIDE2KSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoc3RyKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgsIHVuaXRTaXplKSB7XG4gIGlmICh1bml0U2l6ZSkgbGVuZ3RoIC09IGxlbmd0aCAlIHVuaXRTaXplO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cbiIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIG5CaXRzID0gLTcsXG4gICAgICBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNMRSA/IC0xIDogMSxcbiAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG59O1xuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGMsXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApLFxuICAgICAgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzTEUgPyAxIDogLTEsXG4gICAgICBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcblxuICBlID0gKGUgPDwgbUxlbikgfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCk7XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xufTtcbiIsIlxuLyoqXG4gKiBpc0FycmF5XG4gKi9cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIHRvU3RyaW5nXG4gKi9cblxudmFyIHN0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIGdpdmVuIGB2YWxgXG4gKiBpcyBhbiBhcnJheS5cbiAqXG4gKiBleGFtcGxlOlxuICpcbiAqICAgICAgICBpc0FycmF5KFtdKTtcbiAqICAgICAgICAvLyA+IHRydWVcbiAqICAgICAgICBpc0FycmF5KGFyZ3VtZW50cyk7XG4gKiAgICAgICAgLy8gPiBmYWxzZVxuICogICAgICAgIGlzQXJyYXkoJycpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge21peGVkfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2x9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5IHx8IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuICEhIHZhbCAmJiAnW29iamVjdCBBcnJheV0nID09IHN0ci5jYWxsKHZhbCk7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIHRocm93IFR5cGVFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIHZhciBtO1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gMDtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbihlbWl0dGVyLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IDE7XG4gIGVsc2VcbiAgICByZXQgPSBlbWl0dGVyLl9ldmVudHNbdHlwZV0ubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwidmFyIGh0dHAgPSBtb2R1bGUuZXhwb3J0cztcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgUmVxdWVzdCA9IHJlcXVpcmUoJy4vbGliL3JlcXVlc3QnKTtcbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKVxuXG5odHRwLnJlcXVlc3QgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJhbXMgPSB1cmwucGFyc2UocGFyYW1zKVxuICAgIH1cbiAgICBpZiAoIXBhcmFtcykgcGFyYW1zID0ge307XG4gICAgaWYgKCFwYXJhbXMuaG9zdCAmJiAhcGFyYW1zLnBvcnQpIHtcbiAgICAgICAgcGFyYW1zLnBvcnQgPSBwYXJzZUludCh3aW5kb3cubG9jYXRpb24ucG9ydCwgMTApO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcy5ob3N0ICYmIHBhcmFtcy5ob3N0bmFtZSkge1xuICAgICAgICBwYXJhbXMuaG9zdCA9IHBhcmFtcy5ob3N0bmFtZTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5wcm90b2NvbCkge1xuICAgICAgICBpZiAocGFyYW1zLnNjaGVtZSkge1xuICAgICAgICAgICAgcGFyYW1zLnByb3RvY29sID0gcGFyYW1zLnNjaGVtZSArICc6JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcy5wcm90b2NvbCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFyYW1zLmhvc3QpIHtcbiAgICAgICAgcGFyYW1zLmhvc3QgPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgfHwgd2luZG93LmxvY2F0aW9uLmhvc3Q7XG4gICAgfVxuICAgIGlmICgvOi8udGVzdChwYXJhbXMuaG9zdCkpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMucG9ydCkge1xuICAgICAgICAgICAgcGFyYW1zLnBvcnQgPSBwYXJhbXMuaG9zdC5zcGxpdCgnOicpWzFdO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5ob3N0ID0gcGFyYW1zLmhvc3Quc3BsaXQoJzonKVswXTtcbiAgICB9XG4gICAgaWYgKCFwYXJhbXMucG9ydCkgcGFyYW1zLnBvcnQgPSBwYXJhbXMucHJvdG9jb2wgPT0gJ2h0dHBzOicgPyA0NDMgOiA4MDtcbiAgICBcbiAgICB2YXIgcmVxID0gbmV3IFJlcXVlc3QobmV3IHhockh0dHAsIHBhcmFtcyk7XG4gICAgaWYgKGNiKSByZXEub24oJ3Jlc3BvbnNlJywgY2IpO1xuICAgIHJldHVybiByZXE7XG59O1xuXG5odHRwLmdldCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNiKSB7XG4gICAgcGFyYW1zLm1ldGhvZCA9ICdHRVQnO1xuICAgIHZhciByZXEgPSBodHRwLnJlcXVlc3QocGFyYW1zLCBjYik7XG4gICAgcmVxLmVuZCgpO1xuICAgIHJldHVybiByZXE7XG59O1xuXG5odHRwLkFnZW50ID0gZnVuY3Rpb24gKCkge307XG5odHRwLkFnZW50LmRlZmF1bHRNYXhTb2NrZXRzID0gNDtcblxudmFyIHhockh0dHAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHdpbmRvdyBvYmplY3QgcHJlc2VudCcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5YTUxIdHRwUmVxdWVzdDtcbiAgICB9XG4gICAgZWxzZSBpZiAod2luZG93LkFjdGl2ZVhPYmplY3QpIHtcbiAgICAgICAgdmFyIGF4cyA9IFtcbiAgICAgICAgICAgICdNc3htbDIuWE1MSFRUUC42LjAnLFxuICAgICAgICAgICAgJ01zeG1sMi5YTUxIVFRQLjMuMCcsXG4gICAgICAgICAgICAnTWljcm9zb2Z0LlhNTEhUVFAnXG4gICAgICAgIF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBheCA9IG5ldyh3aW5kb3cuQWN0aXZlWE9iamVjdCkoYXhzW2ldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBheF8gPSBheDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBheF87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHdpbmRvdy5BY3RpdmVYT2JqZWN0KShheHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYWpheCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FqYXggbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICB9XG59KSgpO1xuXG5odHRwLlNUQVRVU19DT0RFUyA9IHtcbiAgICAxMDAgOiAnQ29udGludWUnLFxuICAgIDEwMSA6ICdTd2l0Y2hpbmcgUHJvdG9jb2xzJyxcbiAgICAxMDIgOiAnUHJvY2Vzc2luZycsICAgICAgICAgICAgICAgICAvLyBSRkMgMjUxOCwgb2Jzb2xldGVkIGJ5IFJGQyA0OTE4XG4gICAgMjAwIDogJ09LJyxcbiAgICAyMDEgOiAnQ3JlYXRlZCcsXG4gICAgMjAyIDogJ0FjY2VwdGVkJyxcbiAgICAyMDMgOiAnTm9uLUF1dGhvcml0YXRpdmUgSW5mb3JtYXRpb24nLFxuICAgIDIwNCA6ICdObyBDb250ZW50JyxcbiAgICAyMDUgOiAnUmVzZXQgQ29udGVudCcsXG4gICAgMjA2IDogJ1BhcnRpYWwgQ29udGVudCcsXG4gICAgMjA3IDogJ011bHRpLVN0YXR1cycsICAgICAgICAgICAgICAgLy8gUkZDIDQ5MThcbiAgICAzMDAgOiAnTXVsdGlwbGUgQ2hvaWNlcycsXG4gICAgMzAxIDogJ01vdmVkIFBlcm1hbmVudGx5JyxcbiAgICAzMDIgOiAnTW92ZWQgVGVtcG9yYXJpbHknLFxuICAgIDMwMyA6ICdTZWUgT3RoZXInLFxuICAgIDMwNCA6ICdOb3QgTW9kaWZpZWQnLFxuICAgIDMwNSA6ICdVc2UgUHJveHknLFxuICAgIDMwNyA6ICdUZW1wb3JhcnkgUmVkaXJlY3QnLFxuICAgIDQwMCA6ICdCYWQgUmVxdWVzdCcsXG4gICAgNDAxIDogJ1VuYXV0aG9yaXplZCcsXG4gICAgNDAyIDogJ1BheW1lbnQgUmVxdWlyZWQnLFxuICAgIDQwMyA6ICdGb3JiaWRkZW4nLFxuICAgIDQwNCA6ICdOb3QgRm91bmQnLFxuICAgIDQwNSA6ICdNZXRob2QgTm90IEFsbG93ZWQnLFxuICAgIDQwNiA6ICdOb3QgQWNjZXB0YWJsZScsXG4gICAgNDA3IDogJ1Byb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkJyxcbiAgICA0MDggOiAnUmVxdWVzdCBUaW1lLW91dCcsXG4gICAgNDA5IDogJ0NvbmZsaWN0JyxcbiAgICA0MTAgOiAnR29uZScsXG4gICAgNDExIDogJ0xlbmd0aCBSZXF1aXJlZCcsXG4gICAgNDEyIDogJ1ByZWNvbmRpdGlvbiBGYWlsZWQnLFxuICAgIDQxMyA6ICdSZXF1ZXN0IEVudGl0eSBUb28gTGFyZ2UnLFxuICAgIDQxNCA6ICdSZXF1ZXN0LVVSSSBUb28gTGFyZ2UnLFxuICAgIDQxNSA6ICdVbnN1cHBvcnRlZCBNZWRpYSBUeXBlJyxcbiAgICA0MTYgOiAnUmVxdWVzdGVkIFJhbmdlIE5vdCBTYXRpc2ZpYWJsZScsXG4gICAgNDE3IDogJ0V4cGVjdGF0aW9uIEZhaWxlZCcsXG4gICAgNDE4IDogJ0lcXCdtIGEgdGVhcG90JywgICAgICAgICAgICAgIC8vIFJGQyAyMzI0XG4gICAgNDIyIDogJ1VucHJvY2Vzc2FibGUgRW50aXR5JywgICAgICAgLy8gUkZDIDQ5MThcbiAgICA0MjMgOiAnTG9ja2VkJywgICAgICAgICAgICAgICAgICAgICAvLyBSRkMgNDkxOFxuICAgIDQyNCA6ICdGYWlsZWQgRGVwZW5kZW5jeScsICAgICAgICAgIC8vIFJGQyA0OTE4XG4gICAgNDI1IDogJ1Vub3JkZXJlZCBDb2xsZWN0aW9uJywgICAgICAgLy8gUkZDIDQ5MThcbiAgICA0MjYgOiAnVXBncmFkZSBSZXF1aXJlZCcsICAgICAgICAgICAvLyBSRkMgMjgxN1xuICAgIDQyOCA6ICdQcmVjb25kaXRpb24gUmVxdWlyZWQnLCAgICAgIC8vIFJGQyA2NTg1XG4gICAgNDI5IDogJ1RvbyBNYW55IFJlcXVlc3RzJywgICAgICAgICAgLy8gUkZDIDY1ODVcbiAgICA0MzEgOiAnUmVxdWVzdCBIZWFkZXIgRmllbGRzIFRvbyBMYXJnZScsLy8gUkZDIDY1ODVcbiAgICA1MDAgOiAnSW50ZXJuYWwgU2VydmVyIEVycm9yJyxcbiAgICA1MDEgOiAnTm90IEltcGxlbWVudGVkJyxcbiAgICA1MDIgOiAnQmFkIEdhdGV3YXknLFxuICAgIDUwMyA6ICdTZXJ2aWNlIFVuYXZhaWxhYmxlJyxcbiAgICA1MDQgOiAnR2F0ZXdheSBUaW1lLW91dCcsXG4gICAgNTA1IDogJ0hUVFAgVmVyc2lvbiBOb3QgU3VwcG9ydGVkJyxcbiAgICA1MDYgOiAnVmFyaWFudCBBbHNvIE5lZ290aWF0ZXMnLCAgICAvLyBSRkMgMjI5NVxuICAgIDUwNyA6ICdJbnN1ZmZpY2llbnQgU3RvcmFnZScsICAgICAgIC8vIFJGQyA0OTE4XG4gICAgNTA5IDogJ0JhbmR3aWR0aCBMaW1pdCBFeGNlZWRlZCcsXG4gICAgNTEwIDogJ05vdCBFeHRlbmRlZCcsICAgICAgICAgICAgICAgLy8gUkZDIDI3NzRcbiAgICA1MTEgOiAnTmV0d29yayBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZCcgLy8gUkZDIDY1ODVcbn07IiwidmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xudmFyIFJlc3BvbnNlID0gcmVxdWlyZSgnLi9yZXNwb25zZScpO1xudmFyIEJhc2U2NCA9IHJlcXVpcmUoJ0Jhc2U2NCcpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxudmFyIFJlcXVlc3QgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh4aHIsIHBhcmFtcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBzZWxmLnhociA9IHhocjtcbiAgICBzZWxmLmJvZHkgPSBbXTtcbiAgICBcbiAgICBzZWxmLnVyaSA9IChwYXJhbXMucHJvdG9jb2wgfHwgJ2h0dHA6JykgKyAnLy8nXG4gICAgICAgICsgcGFyYW1zLmhvc3RcbiAgICAgICAgKyAocGFyYW1zLnBvcnQgPyAnOicgKyBwYXJhbXMucG9ydCA6ICcnKVxuICAgICAgICArIChwYXJhbXMucGF0aCB8fCAnLycpXG4gICAgO1xuICAgIFxuICAgIGlmICh0eXBlb2YgcGFyYW1zLndpdGhDcmVkZW50aWFscyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGFyYW1zLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgdHJ5IHsgeGhyLndpdGhDcmVkZW50aWFscyA9IHBhcmFtcy53aXRoQ3JlZGVudGlhbHMgfVxuICAgIGNhdGNoIChlKSB7fVxuICAgIFxuICAgIGlmIChwYXJhbXMucmVzcG9uc2VUeXBlKSB0cnkgeyB4aHIucmVzcG9uc2VUeXBlID0gcGFyYW1zLnJlc3BvbnNlVHlwZSB9XG4gICAgY2F0Y2ggKGUpIHt9XG4gICAgXG4gICAgeGhyLm9wZW4oXG4gICAgICAgIHBhcmFtcy5tZXRob2QgfHwgJ0dFVCcsXG4gICAgICAgIHNlbGYudXJpLFxuICAgICAgICB0cnVlXG4gICAgKTtcblxuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignTmV0d29yayBlcnJvcicpKTtcbiAgICB9O1xuXG4gICAgc2VsZi5faGVhZGVycyA9IHt9O1xuICAgIFxuICAgIGlmIChwYXJhbXMuaGVhZGVycykge1xuICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMocGFyYW1zLmhlYWRlcnMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmlzU2FmZVJlcXVlc3RIZWFkZXIoa2V5KSkgY29udGludWU7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbXMuaGVhZGVyc1trZXldO1xuICAgICAgICAgICAgc2VsZi5zZXRIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKHBhcmFtcy5hdXRoKSB7XG4gICAgICAgIC8vYmFzaWMgYXV0aFxuICAgICAgICB0aGlzLnNldEhlYWRlcignQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICsgQmFzZTY0LmJ0b2EocGFyYW1zLmF1dGgpKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzID0gbmV3IFJlc3BvbnNlO1xuICAgIHJlcy5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnKTtcbiAgICB9KTtcbiAgICBcbiAgICByZXMub24oJ3JlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmVtaXQoJ3Jlc3BvbnNlJywgcmVzKTtcbiAgICB9KTtcblxuICAgIHJlcy5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH0pO1xuICAgIFxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEZpeCBmb3IgSUU5IGJ1Z1xuICAgICAgICAvLyBTQ1JJUFQ1NzU6IENvdWxkIG5vdCBjb21wbGV0ZSB0aGUgb3BlcmF0aW9uIGR1ZSB0byBlcnJvciBjMDBjMDIzZlxuICAgICAgICAvLyBJdCBoYXBwZW5zIHdoZW4gYSByZXF1ZXN0IGlzIGFib3J0ZWQsIGNhbGxpbmcgdGhlIHN1Y2Nlc3MgY2FsbGJhY2sgYW55d2F5IHdpdGggcmVhZHlTdGF0ZSA9PT0gNFxuICAgICAgICBpZiAoeGhyLl9fYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgICByZXMuaGFuZGxlKHhocik7XG4gICAgfTtcbn07XG5cbmluaGVyaXRzKFJlcXVlc3QsIFN0cmVhbSk7XG5cblJlcXVlc3QucHJvdG90eXBlLnNldEhlYWRlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5faGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZVxufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuZ2V0SGVhZGVyID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXVxufTtcblxuUmVxdWVzdC5wcm90b3R5cGUucmVtb3ZlSGVhZGVyID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGRlbGV0ZSB0aGlzLl9oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXVxufTtcblxuUmVxdWVzdC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocykge1xuICAgIHRoaXMuYm9keS5wdXNoKHMpO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgdGhpcy54aHIuX19hYm9ydGVkID0gdHJ1ZTtcbiAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgaWYgKHMgIT09IHVuZGVmaW5lZCkgdGhpcy5ib2R5LnB1c2gocyk7XG5cbiAgICB2YXIga2V5cyA9IG9iamVjdEtleXModGhpcy5faGVhZGVycyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9oZWFkZXJzW2tleV07XG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB0aGlzLnhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWUpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYm9keS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy54aHIuc2VuZCgnJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLmJvZHlbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMueGhyLnNlbmQodGhpcy5ib2R5LmpvaW4oJycpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheSh0aGlzLmJvZHlbMF0pKSB7XG4gICAgICAgIHZhciBib2R5ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBib2R5LnB1c2guYXBwbHkoYm9keSwgdGhpcy5ib2R5W2ldKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnhoci5zZW5kKGJvZHkpO1xuICAgIH1cbiAgICBlbHNlIGlmICgvQXJyYXkvLnRlc3QoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMuYm9keVswXSkpKSB7XG4gICAgICAgIHZhciBsZW4gPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGVuICs9IHRoaXMuYm9keVtpXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvZHkgPSBuZXcodGhpcy5ib2R5WzBdLmNvbnN0cnVjdG9yKShsZW4pO1xuICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmJvZHlbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBib2R5W2srK10gPSBiW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMueGhyLnNlbmQoYm9keSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzWEhSMkNvbXBhdGlibGUodGhpcy5ib2R5WzBdKSkge1xuICAgICAgICB0aGlzLnhoci5zZW5kKHRoaXMuYm9keVswXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgYm9keSA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYm9keSArPSB0aGlzLmJvZHlbaV0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnhoci5zZW5kKGJvZHkpO1xuICAgIH1cbn07XG5cbi8vIFRha2VuIGZyb20gaHR0cDovL2R4ci5tb3ppbGxhLm9yZy9tb3ppbGxhL21vemlsbGEtY2VudHJhbC9jb250ZW50L2Jhc2Uvc3JjL25zWE1MSHR0cFJlcXVlc3QuY3BwLmh0bWxcblJlcXVlc3QudW5zYWZlSGVhZGVycyA9IFtcbiAgICBcImFjY2VwdC1jaGFyc2V0XCIsXG4gICAgXCJhY2NlcHQtZW5jb2RpbmdcIixcbiAgICBcImFjY2Vzcy1jb250cm9sLXJlcXVlc3QtaGVhZGVyc1wiLFxuICAgIFwiYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1tZXRob2RcIixcbiAgICBcImNvbm5lY3Rpb25cIixcbiAgICBcImNvbnRlbnQtbGVuZ3RoXCIsXG4gICAgXCJjb29raWVcIixcbiAgICBcImNvb2tpZTJcIixcbiAgICBcImNvbnRlbnQtdHJhbnNmZXItZW5jb2RpbmdcIixcbiAgICBcImRhdGVcIixcbiAgICBcImV4cGVjdFwiLFxuICAgIFwiaG9zdFwiLFxuICAgIFwia2VlcC1hbGl2ZVwiLFxuICAgIFwib3JpZ2luXCIsXG4gICAgXCJyZWZlcmVyXCIsXG4gICAgXCJ0ZVwiLFxuICAgIFwidHJhaWxlclwiLFxuICAgIFwidHJhbnNmZXItZW5jb2RpbmdcIixcbiAgICBcInVwZ3JhZGVcIixcbiAgICBcInVzZXItYWdlbnRcIixcbiAgICBcInZpYVwiXG5dO1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5pc1NhZmVSZXF1ZXN0SGVhZGVyID0gZnVuY3Rpb24gKGhlYWRlck5hbWUpIHtcbiAgICBpZiAoIWhlYWRlck5hbWUpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gaW5kZXhPZihSZXF1ZXN0LnVuc2FmZUhlYWRlcnMsIGhlYWRlck5hbWUudG9Mb3dlckNhc2UoKSkgPT09IC0xO1xufTtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICByZXR1cm4ga2V5cztcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnZhciBpbmRleE9mID0gZnVuY3Rpb24gKHhzLCB4KSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHJldHVybiB4cy5pbmRleE9mKHgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcblxudmFyIGlzWEhSMkNvbXBhdGlibGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgcmV0dXJuIHRydWU7XG4gICAgaWYgKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqIGluc3RhbmNlb2YgRm9ybURhdGEpIHJldHVybiB0cnVlO1xufTtcbiIsInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgUmVzcG9uc2UgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG59O1xuXG51dGlsLmluaGVyaXRzKFJlc3BvbnNlLCBTdHJlYW0pO1xuXG52YXIgY2FwYWJsZSA9IHtcbiAgICBzdHJlYW1pbmcgOiB0cnVlLFxuICAgIHN0YXR1czIgOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMgKHJlcykge1xuICAgIHZhciBsaW5lcyA9IHJlcy5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS5zcGxpdCgvXFxyP1xcbi8pO1xuICAgIHZhciBoZWFkZXJzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICBpZiAobGluZSA9PT0gJycpIGNvbnRpbnVlO1xuICAgICAgICBcbiAgICAgICAgdmFyIG0gPSBsaW5lLm1hdGNoKC9eKFteOl0rKTpcXHMqKC4qKS8pO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IG1bMV0udG9Mb3dlckNhc2UoKSwgdmFsdWUgPSBtWzJdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoaGVhZGVyc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGhlYWRlcnNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1trZXldLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1trZXldID0gWyBoZWFkZXJzW2tleV0sIHZhbHVlIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWFkZXJzW2xpbmVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbn1cblxuUmVzcG9uc2UucHJvdG90eXBlLmdldFJlc3BvbnNlID0gZnVuY3Rpb24gKHhocikge1xuICAgIHZhciByZXNwVHlwZSA9IFN0cmluZyh4aHIucmVzcG9uc2VUeXBlKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChyZXNwVHlwZSA9PT0gJ2Jsb2InKSByZXR1cm4geGhyLnJlc3BvbnNlQmxvYiB8fCB4aHIucmVzcG9uc2U7XG4gICAgaWYgKHJlc3BUeXBlID09PSAnYXJyYXlidWZmZXInKSByZXR1cm4geGhyLnJlc3BvbnNlO1xuICAgIHJldHVybiB4aHIucmVzcG9uc2VUZXh0O1xufVxuXG5SZXNwb25zZS5wcm90b3R5cGUuZ2V0SGVhZGVyID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldO1xufTtcblxuUmVzcG9uc2UucHJvdG90eXBlLmhhbmRsZSA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICBpZiAocmVzLnJlYWR5U3RhdGUgPT09IDIgJiYgY2FwYWJsZS5zdGF0dXMyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gcGFyc2VIZWFkZXJzKHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2FwYWJsZS5zdGF0dXMyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChjYXBhYmxlLnN0YXR1czIpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChjYXBhYmxlLnN0cmVhbWluZyAmJiByZXMucmVhZHlTdGF0ZSA9PT0gMykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IHBhcnNlSGVhZGVycyhyZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7fVxuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXREYXRhKHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2FwYWJsZS5zdHJlYW1pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChyZXMucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gcmVzLnN0YXR1cztcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbWl0RGF0YShyZXMpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHJlcy5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHRoaXMuZ2V0UmVzcG9uc2UocmVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB0aGlzLmVtaXQoJ2VuZCcpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICAgIH1cbn07XG5cblJlc3BvbnNlLnByb3RvdHlwZS5fZW1pdERhdGEgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgdmFyIHJlc3BCb2R5ID0gdGhpcy5nZXRSZXNwb25zZShyZXMpO1xuICAgIGlmIChyZXNwQm9keS50b1N0cmluZygpLm1hdGNoKC9BcnJheUJ1ZmZlci8pKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIG5ldyBVaW50OEFycmF5KHJlc3BCb2R5LCB0aGlzLm9mZnNldCkpO1xuICAgICAgICB0aGlzLm9mZnNldCA9IHJlc3BCb2R5LmJ5dGVMZW5ndGg7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlc3BCb2R5Lmxlbmd0aCA+IHRoaXMub2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIHJlc3BCb2R5LnNsaWNlKHRoaXMub2Zmc2V0KSk7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gcmVzcEJvZHkubGVuZ3RoO1xuICAgIH1cbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCI7KGZ1bmN0aW9uICgpIHtcblxuICB2YXIgb2JqZWN0ID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpczsgLy8gIzg6IHdlYiB3b3JrZXJzXG4gIHZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbiAgZnVuY3Rpb24gSW52YWxpZENoYXJhY3RlckVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG4gIEludmFsaWRDaGFyYWN0ZXJFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3I7XG4gIEludmFsaWRDaGFyYWN0ZXJFcnJvci5wcm90b3R5cGUubmFtZSA9ICdJbnZhbGlkQ2hhcmFjdGVyRXJyb3InO1xuXG4gIC8vIGVuY29kZXJcbiAgLy8gW2h0dHBzOi8vZ2lzdC5naXRodWIuY29tLzk5OTE2Nl0gYnkgW2h0dHBzOi8vZ2l0aHViLmNvbS9uaWduYWddXG4gIG9iamVjdC5idG9hIHx8IChcbiAgb2JqZWN0LmJ0b2EgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBmb3IgKFxuICAgICAgLy8gaW5pdGlhbGl6ZSByZXN1bHQgYW5kIGNvdW50ZXJcbiAgICAgIHZhciBibG9jaywgY2hhckNvZGUsIGlkeCA9IDAsIG1hcCA9IGNoYXJzLCBvdXRwdXQgPSAnJztcbiAgICAgIC8vIGlmIHRoZSBuZXh0IGlucHV0IGluZGV4IGRvZXMgbm90IGV4aXN0OlxuICAgICAgLy8gICBjaGFuZ2UgdGhlIG1hcHBpbmcgdGFibGUgdG8gXCI9XCJcbiAgICAgIC8vICAgY2hlY2sgaWYgZCBoYXMgbm8gZnJhY3Rpb25hbCBkaWdpdHNcbiAgICAgIGlucHV0LmNoYXJBdChpZHggfCAwKSB8fCAobWFwID0gJz0nLCBpZHggJSAxKTtcbiAgICAgIC8vIFwiOCAtIGlkeCAlIDEgKiA4XCIgZ2VuZXJhdGVzIHRoZSBzZXF1ZW5jZSAyLCA0LCA2LCA4XG4gICAgICBvdXRwdXQgKz0gbWFwLmNoYXJBdCg2MyAmIGJsb2NrID4+IDggLSBpZHggJSAxICogOClcbiAgICApIHtcbiAgICAgIGNoYXJDb2RlID0gaW5wdXQuY2hhckNvZGVBdChpZHggKz0gMy80KTtcbiAgICAgIGlmIChjaGFyQ29kZSA+IDB4RkYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRDaGFyYWN0ZXJFcnJvcihcIididG9hJyBmYWlsZWQ6IFRoZSBzdHJpbmcgdG8gYmUgZW5jb2RlZCBjb250YWlucyBjaGFyYWN0ZXJzIG91dHNpZGUgb2YgdGhlIExhdGluMSByYW5nZS5cIik7XG4gICAgICB9XG4gICAgICBibG9jayA9IGJsb2NrIDw8IDggfCBjaGFyQ29kZTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSk7XG5cbiAgLy8gZGVjb2RlclxuICAvLyBbaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTAyMDM5Nl0gYnkgW2h0dHBzOi8vZ2l0aHViLmNvbS9hdGtdXG4gIG9iamVjdC5hdG9iIHx8IChcbiAgb2JqZWN0LmF0b2IgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoLz0rJC8sICcnKTtcbiAgICBpZiAoaW5wdXQubGVuZ3RoICUgNCA9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZENoYXJhY3RlckVycm9yKFwiJ2F0b2InIGZhaWxlZDogVGhlIHN0cmluZyB0byBiZSBkZWNvZGVkIGlzIG5vdCBjb3JyZWN0bHkgZW5jb2RlZC5cIik7XG4gICAgfVxuICAgIGZvciAoXG4gICAgICAvLyBpbml0aWFsaXplIHJlc3VsdCBhbmQgY291bnRlcnNcbiAgICAgIHZhciBiYyA9IDAsIGJzLCBidWZmZXIsIGlkeCA9IDAsIG91dHB1dCA9ICcnO1xuICAgICAgLy8gZ2V0IG5leHQgY2hhcmFjdGVyXG4gICAgICBidWZmZXIgPSBpbnB1dC5jaGFyQXQoaWR4KyspO1xuICAgICAgLy8gY2hhcmFjdGVyIGZvdW5kIGluIHRhYmxlPyBpbml0aWFsaXplIGJpdCBzdG9yYWdlIGFuZCBhZGQgaXRzIGFzY2lpIHZhbHVlO1xuICAgICAgfmJ1ZmZlciAmJiAoYnMgPSBiYyAlIDQgPyBicyAqIDY0ICsgYnVmZmVyIDogYnVmZmVyLFxuICAgICAgICAvLyBhbmQgaWYgbm90IGZpcnN0IG9mIGVhY2ggNCBjaGFyYWN0ZXJzLFxuICAgICAgICAvLyBjb252ZXJ0IHRoZSBmaXJzdCA4IGJpdHMgdG8gb25lIGFzY2lpIGNoYXJhY3RlclxuICAgICAgICBiYysrICUgNCkgPyBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUgJiBicyA+PiAoLTIgKiBiYyAmIDYpKSA6IDBcbiAgICApIHtcbiAgICAgIC8vIHRyeSB0byBmaW5kIGNoYXJhY3RlciBpbiB0YWJsZSAoMC02Mywgbm90IGZvdW5kID0+IC0xKVxuICAgICAgYnVmZmVyID0gY2hhcnMuaW5kZXhPZihidWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9KTtcblxufSgpKTtcbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG4iLCIvKiEgaHR0cDovL210aHMuYmUvcHVueWNvZGUgdjEuMi40IGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHRtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW14gLX5dLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1xceDJFfFxcdTMwMDJ8XFx1RkYwRXxcXHVGRjYxL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0YXJyYXlbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gYXJyYXk7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHJldHVybiBtYXAoc3RyaW5nLnNwbGl0KHJlZ2V4U2VwYXJhdG9ycyksIGZuKS5qb2luKCcuJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgdG8gYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgdG8gVW5pY29kZS4gT25seSB0aGVcblx0ICogUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLiBpdCBkb2Vzbid0XG5cdCAqIG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gY29udmVydGVkIHRvXG5cdCAqIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBQdW55Y29kZSBkb21haW4gbmFtZSB0byBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoZG9tYWluKSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihkb21haW4sIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIHRvIFB1bnljb2RlLiBPbmx5IHRoZVxuXHQgKiBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLCBpLmUuIGl0IGRvZXNuJ3Rcblx0ICogbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW4gQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSB0byBjb252ZXJ0LCBhcyBhIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShkb21haW4pIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGRvbWFpbiwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuMi40Jyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcblx0XHRpZiAoZnJlZU1vZHVsZSkgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXCIpXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG5mb3JFYWNoKG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKSwgZnVuY3Rpb24obWV0aG9kKSB7XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKVxuICAgIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xufSk7XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKVxuICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKVxuICAgIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzLm5leHRUaWNrKHRoaXMuZW5kLmJpbmQodGhpcykpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKVxuICAgIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5pZiAoIUVFLmxpc3RlbmVyQ291bnQpIEVFLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiAxNiAqIDEwMjQ7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBmYWxzZTtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gSW4gc3RyZWFtcyB0aGF0IG5ldmVyIGhhdmUgYW55IGRhdGEsIGFuZCBkbyBwdXNoKG51bGwpIHJpZ2h0IGF3YXksXG4gIC8vIHRoZSBjb25zdW1lciBjYW4gbWlzcyB0aGUgJ2VuZCcgZXZlbnQgaWYgdGhleSBkbyBzb21lIEkvTyBiZWZvcmVcbiAgLy8gY29uc3VtaW5nIHRoZSBzdHJlYW0uICBTbywgd2UgZG9uJ3QgZW1pdCgnZW5kJykgdW50aWwgc29tZSByZWFkaW5nXG4gIC8vIGhhcHBlbnMuXG4gIHRoaXMuY2FsbGVkUmVhZCA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWN1YXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG5cblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXG4gIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpXG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICBlbmNvZGluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgJycsIHRydWUpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcbiAgdmFyIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIGlmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIGlmICghc3RhdGUuZW5kZWQpXG4gICAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgIGlmIChzdGF0ZS5lbmRlZCAmJiAhYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZEVtaXR0ZWQgJiYgYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWFkZFRvRnJvbnQgJiYgIWVuY29kaW5nKVxuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpXG4gICAgICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuXG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIChzdGF0ZS5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8XG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbihlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKVxuICAgIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDEyOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDJcbiAgICBuLS07XG4gICAgZm9yICh2YXIgcCA9IDE7IHAgPCAzMjsgcCA8PD0gMSkgbiB8PSBuID4+IHA7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpXG4gICAgcmV0dXJuIG4gPT09IDAgPyAwIDogMTtcblxuICBpZiAobiA9PT0gbnVsbCB8fCBpc05hTihuKSkge1xuICAgIC8vIG9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICByZXR1cm4gc3RhdGUuYnVmZmVyWzBdLmxlbmd0aDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgaWYgKG4gPD0gMClcbiAgICByZXR1cm4gMDtcblxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgdGFyZ2V0IGJ1ZmZlciBsZXZlbCxcbiAgLy8gdGhlbiByYWlzZSB0aGUgd2F0ZXIgbWFyay4gIEJ1bXAgdXAgdG8gdGhlIG5leHQgaGlnaGVzdFxuICAvLyBwb3dlciBvZiAyLCB0byBwcmV2ZW50IGluY3JlYXNpbmcgaXQgZXhjZXNzaXZlbHkgaW4gdGlueVxuICAvLyBhbW91bnRzLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgc3RhdGUuaGlnaFdhdGVyTWFyayA9IHJvdW5kVXBUb05leHRQb3dlck9mMihuKTtcblxuICAvLyBkb24ndCBoYXZlIHRoYXQgbXVjaC4gIHJldHVybiBudWxsLCB1bmxlc3Mgd2UndmUgZW5kZWQuXG4gIGlmIChuID4gc3RhdGUubGVuZ3RoKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBuO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLmNhbGxlZFJlYWQgPSB0cnVlO1xuICB2YXIgbk9yaWcgPSBuO1xuICB2YXIgcmV0O1xuXG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA+IDApXG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJlxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlICYmXG4gICAgICAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICByZXQgPSBudWxsO1xuXG4gICAgLy8gSW4gY2FzZXMgd2hlcmUgdGhlIGRlY29kZXIgZGlkIG5vdCByZWNlaXZlIGVub3VnaCBkYXRhXG4gICAgLy8gdG8gcHJvZHVjZSBhIGZ1bGwgY2h1bmssIHRoZW4gaW1tZWRpYXRlbHkgcmVjZWl2ZWQgYW5cbiAgICAvLyBFT0YsIHN0YXRlLmJ1ZmZlciB3aWxsIGNvbnRhaW4gWzxCdWZmZXIgPiwgPEJ1ZmZlciAwMCAuLi4+XS5cbiAgICAvLyBob3dNdWNoVG9SZWFkIHdpbGwgc2VlIHRoaXMgYW5kIGNvZXJjZSB0aGUgYW1vdW50IHRvXG4gICAgLy8gcmVhZCB0byB6ZXJvIChiZWNhdXNlIGl0J3MgbG9va2luZyBhdCB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgIC8vIGZpcnN0IDxCdWZmZXIgPiBpbiBzdGF0ZS5idWZmZXIpLCBhbmQgd2UnbGwgZW5kIHVwIGhlcmUuXG4gICAgLy9cbiAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbiB2aWEgc3RhdGUuZGVjb2RlciAtLSBubyBvdGhlciB2ZW51ZVxuICAgIC8vIGV4aXN0cyBmb3IgcHVzaGluZyBhIHplcm8tbGVuZ3RoIGNodW5rIGludG8gc3RhdGUuYnVmZmVyXG4gICAgLy8gYW5kIHRyaWdnZXJpbmcgdGhpcyBiZWhhdmlvci4gSW4gdGhpcyBjYXNlLCB3ZSByZXR1cm4gb3VyXG4gICAgLy8gcmVtYWluaW5nIGRhdGEgYW5kIGVuZCB0aGUgc3RyZWFtLCBpZiBhcHByb3ByaWF0ZS5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID4gMCAmJiBzdGF0ZS5kZWNvZGVyKSB7XG4gICAgICByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5sZW5ndGggLT0gcmV0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgZW5kUmVhZGFibGUodGhpcyk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggLSBuIDw9IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgZG9SZWFkID0gdHJ1ZTtcblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKVxuICAgIGRvUmVhZCA9IGZhbHNlO1xuXG4gIGlmIChkb1JlYWQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIF9yZWFkIGNhbGxlZCBpdHMgY2FsbGJhY2sgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2BcbiAgLy8gd2lsbCBiZSBmYWxzZSwgYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZVxuICAvLyBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICBpZiAoZG9SZWFkICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG5cbiAgaWYgKG4gPiAwKVxuICAgIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtcbiAgZWxzZVxuICAgIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH1cblxuICBzdGF0ZS5sZW5ndGggLT0gbjtcblxuICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5lbmRlZClcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIElmIHdlIGhhcHBlbmVkIHRvIHJlYWQoKSBleGFjdGx5IHRoZSByZW1haW5pbmcgYW1vdW50IGluIHRoZVxuICAvLyBidWZmZXIsIGFuZCB0aGUgRU9GIGhhcyBiZWVuIHNlZW4gYXQgdGhpcyBwb2ludCwgdGhlbiBtYWtlIHN1cmVcbiAgLy8gdGhhdCB3ZSBlbWl0ICdlbmQnIG9uIHRoZSB2ZXJ5IG5leHQgdGljay5cbiAgaWYgKHN0YXRlLmVuZGVkICYmICFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICdzdHJpbmcnICE9PSB0eXBlb2YgY2h1bmsgJiZcbiAgICAgIGNodW5rICE9PSBudWxsICYmXG4gICAgICBjaHVuayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCBhbmQgd2UgaGF2ZSBzb21lIGRhdGEgbGVmdCwgdGhlbiBlbWl0XG4gIC8vICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApXG4gICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIGVsc2VcbiAgICBlbmRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoc3RhdGUuZW1pdHRlZFJlYWRhYmxlKVxuICAgIHJldHVybjtcblxuICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICBpZiAoc3RhdGUuc3luYylcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICAgIH0pO1xuICBlbHNlXG4gICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbn1cblxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gICAgZWxzZVxuICAgICAgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO1xuICBlbHNlXG4gICAgc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlKSB7XG4gICAgaWYgKHJlYWRhYmxlICE9PSBzcmMpIHJldHVybjtcbiAgICBjbGVhbnVwKCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbilcbiAgICAgIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKVxuICAgICAgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuICAvLyBUaGlzIGlzIGEgYnJ1dGFsbHkgdWdseSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyXG4gIC8vIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnkgdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuXG4gIGlmICghZGVzdC5fZXZlbnRzIHx8ICFkZXN0Ll9ldmVudHMuZXJyb3IpXG4gICAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZWxzZSBpZiAoaXNBcnJheShkZXN0Ll9ldmVudHMuZXJyb3IpKVxuICAgIGRlc3QuX2V2ZW50cy5lcnJvci51bnNoaWZ0KG9uZXJyb3IpO1xuICBlbHNlXG4gICAgZGVzdC5fZXZlbnRzLmVycm9yID0gW29uZXJyb3IsIGRlc3QuX2V2ZW50cy5lcnJvcl07XG5cblxuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICAvLyB0aGUgaGFuZGxlciB0aGF0IHdhaXRzIGZvciByZWFkYWJsZSBldmVudHMgYWZ0ZXIgYWxsXG4gICAgLy8gdGhlIGRhdGEgZ2V0cyBzdWNrZWQgb3V0IGluIGZsb3cuXG4gICAgLy8gVGhpcyB3b3VsZCBiZSBlYXNpZXIgdG8gZm9sbG93IHdpdGggYSAub25jZSgpIGhhbmRsZXJcbiAgICAvLyBpbiBmbG93KCksIGJ1dCB0aGF0IGlzIHRvbyBzbG93LlxuICAgIHRoaXMub24oJ3JlYWRhYmxlJywgcGlwZU9uUmVhZGFibGUpO1xuXG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVzdCA9IHRoaXM7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMClcbiAgICAgIGZsb3coc3JjKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmxvdyhzcmMpIHtcbiAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgY2h1bms7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuXG4gIGZ1bmN0aW9uIHdyaXRlKGRlc3QsIGksIGxpc3QpIHtcbiAgICB2YXIgd3JpdHRlbiA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gd3JpdHRlbikge1xuICAgICAgc3RhdGUuYXdhaXREcmFpbisrO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5waXBlc0NvdW50ICYmIG51bGwgIT09IChjaHVuayA9IHNyYy5yZWFkKCkpKSB7XG5cbiAgICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICAgIHdyaXRlKHN0YXRlLnBpcGVzLCAwLCBudWxsKTtcbiAgICBlbHNlXG4gICAgICBmb3JFYWNoKHN0YXRlLnBpcGVzLCB3cml0ZSk7XG5cbiAgICBzcmMuZW1pdCgnZGF0YScsIGNodW5rKTtcblxuICAgIC8vIGlmIGFueW9uZSBuZWVkcyBhIGRyYWluLCB0aGVuIHdlIGhhdmUgdG8gd2FpdCBmb3IgdGhhdC5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA+IDApXG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBpZiBldmVyeSBkZXN0aW5hdGlvbiB3YXMgdW5waXBlZCwgZWl0aGVyIGJlZm9yZSBlbnRlcmluZyB0aGlzXG4gIC8vIGZ1bmN0aW9uLCBvciBpbiB0aGUgd2hpbGUgbG9vcCwgdGhlbiBzdG9wIGZsb3dpbmcuXG4gIC8vXG4gIC8vIE5COiBUaGlzIGlzIGEgcHJldHR5IHJhcmUgZWRnZSBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkge1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIC8vIGlmIHRoZXJlIHdlcmUgZGF0YSBldmVudCBsaXN0ZW5lcnMgYWRkZWQsIHRoZW4gc3dpdGNoIHRvIG9sZCBtb2RlLlxuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSA+IDApXG4gICAgICBlbWl0RGF0YUV2ZW50cyhzcmMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGF0IHRoaXMgcG9pbnQsIG5vIG9uZSBuZWVkZWQgYSBkcmFpbiwgc28gd2UganVzdCByYW4gb3V0IG9mIGRhdGFcbiAgLy8gb24gdGhlIG5leHQgcmVhZGFibGUgZXZlbnQsIHN0YXJ0IGl0IG92ZXIgYWdhaW4uXG4gIHN0YXRlLnJhbk91dCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHBpcGVPblJlYWRhYmxlKCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5yYW5PdXQpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJhbk91dCA9IGZhbHNlO1xuICAgIGZsb3codGhpcyk7XG4gIH1cbn1cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24oZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpXG4gICAgICBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBwaXBlT25SZWFkYWJsZSk7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KVxuICAgICAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBwaXBlT25SZWFkYWJsZSk7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJyAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKVxuICAgIGVtaXREYXRhRXZlbnRzKHRoaXMpO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyAmJiB0aGlzLnJlYWRhYmxlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgdGhpcy5yZWFkKDApO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICBlbWl0RGF0YUV2ZW50cyh0aGlzKTtcbiAgdGhpcy5yZWFkKDApO1xuICB0aGlzLmVtaXQoJ3Jlc3VtZScpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIGVtaXREYXRhRXZlbnRzKHRoaXMsIHRydWUpO1xuICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG59O1xuXG5mdW5jdGlvbiBlbWl0RGF0YUV2ZW50cyhzdHJlYW0sIHN0YXJ0UGF1c2VkKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuZmxvd2luZykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3MvcmVhZGFibGUtc3RyZWFtL2lzc3Vlcy8xNlxuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN3aXRjaCB0byBvbGQgbW9kZSBub3cuJyk7XG4gIH1cblxuICB2YXIgcGF1c2VkID0gc3RhcnRQYXVzZWQgfHwgZmFsc2U7XG4gIHZhciByZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGNvbnZlcnQgdG8gYW4gb2xkLXN0eWxlIHN0cmVhbS5cbiAgc3RyZWFtLnJlYWRhYmxlID0gdHJ1ZTtcbiAgc3RyZWFtLnBpcGUgPSBTdHJlYW0ucHJvdG90eXBlLnBpcGU7XG4gIHN0cmVhbS5vbiA9IHN0cmVhbS5hZGRMaXN0ZW5lciA9IFN0cmVhbS5wcm90b3R5cGUub247XG5cbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uKCkge1xuICAgIHJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIHZhciBjO1xuICAgIHdoaWxlICghcGF1c2VkICYmIChudWxsICE9PSAoYyA9IHN0cmVhbS5yZWFkKCkpKSlcbiAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgYyk7XG5cbiAgICBpZiAoYyA9PT0gbnVsbCkge1xuICAgICAgcmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgc3RyZWFtLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgcGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH07XG5cbiAgc3RyZWFtLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIGlmIChyZWFkYWJsZSlcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgdGhpcy5yZWFkKDApO1xuICAgIHRoaXMuZW1pdCgncmVzdW1lJyk7XG4gIH07XG5cbiAgLy8gbm93IG1ha2UgaXQgc3RhcnQsIGp1c3QgaW4gY2FzZSBpdCBoYWRuJ3QgYWxyZWFkeS5cbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aClcbiAgICAgICAgc2VsZi5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBzZWxmLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpXG4gICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgLy9pZiAoc3RhdGUub2JqZWN0TW9kZSAmJiB1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSlcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpXG4gICAgICByZXR1cm47XG4gICAgZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSlcbiAgICAgIHJldHVybjtcblxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIHR5cGVvZiB0aGlzW2ldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uKG1ldGhvZCkgeyByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICB9fShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIHZhciBldmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG4gIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbihldikge1xuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5cblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICB2YXIgbGlzdCA9IHN0YXRlLmJ1ZmZlcjtcbiAgdmFyIGxlbmd0aCA9IHN0YXRlLmxlbmd0aDtcbiAgdmFyIHN0cmluZ01vZGUgPSAhIXN0YXRlLmRlY29kZXI7XG4gIHZhciBvYmplY3RNb2RlID0gISFzdGF0ZS5vYmplY3RNb2RlO1xuICB2YXIgcmV0O1xuXG4gIC8vIG5vdGhpbmcgaW4gdGhlIGxpc3QsIGRlZmluaXRlbHkgZW1wdHkuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAobGVuZ3RoID09PSAwKVxuICAgIHJldCA9IG51bGw7XG4gIGVsc2UgaWYgKG9iamVjdE1vZGUpXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICBlbHNlIGlmICghbiB8fCBuID49IGxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgYXJyYXkuXG4gICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICByZXQgPSBsaXN0LmpvaW4oJycpO1xuICAgIGVsc2VcbiAgICAgIHJldCA9IEJ1ZmZlci5jb25jYXQobGlzdCwgbGVuZ3RoKTtcbiAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBqdXN0IHNvbWUgb2YgaXQuXG4gICAgaWYgKG4gPCBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8ganVzdCB0YWtlIGEgcGFydCBvZiB0aGUgZmlyc3QgbGlzdCBpdGVtLlxuICAgICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgIHJldCA9IGJ1Zi5zbGljZSgwLCBuKTtcbiAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgfSBlbHNlIGlmIChuID09PSBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8gZmlyc3QgbGlzdCBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29tcGxleCBjYXNlLlxuICAgICAgLy8gd2UgaGF2ZSBlbm91Z2ggdG8gY292ZXIgaXQsIGJ1dCBpdCBzcGFucyBwYXN0IHRoZSBmaXJzdCBidWZmZXIuXG4gICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgcmV0ID0gJyc7XG4gICAgICBlbHNlXG4gICAgICAgIHJldCA9IG5ldyBCdWZmZXIobik7XG5cbiAgICAgIHZhciBjID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsICYmIGMgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICAgIHZhciBjcHkgPSBNYXRoLm1pbihuIC0gYywgYnVmLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgICAgcmV0ICs9IGJ1Zi5zbGljZSgwLCBjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYnVmLmNvcHkocmV0LCBjLCAwLCBjcHkpO1xuXG4gICAgICAgIGlmIChjcHkgPCBidWYubGVuZ3RoKVxuICAgICAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2UoY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcblxuICAgICAgICBjICs9IGNweTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZFJlYWRhYmxlIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmNhbGxlZFJlYWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICAgICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24oZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgaWYgKGNiKVxuICAgIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpXG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHRoaXMuX2ZsdXNoKVxuICAgICAgdGhpcy5fZmx1c2goZnVuY3Rpb24oZXIpIHtcbiAgICAgICAgZG9uZShzdHJlYW0sIGVyKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIGRvbmUoc3RyZWFtKTtcbiAgfSk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8XG4gICAgICAgIHJzLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKVxuICAgICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHdzLmxlbmd0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogMTYgKiAxMDI0O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWN1YXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24oZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0aG91Z2ggdGhleSdyZSBub3RcbiAgLy8gaW5zdGFuY2VvZiBXcml0YWJsZSwgdGhleSdyZSBpbnN0YW5jZW9mIFJlYWRhYmxlLlxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUuIE5vdCByZWFkYWJsZS4nKSk7XG59O1xuXG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIGNiKGVyKTtcbiAgfSk7XG59XG5cbi8vIElmIHdlIGdldCBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgbnVsbCwgb3IgdW5kZWZpbmVkLFxuLy8gYW5kIHdlJ3JlIG5vdCBpbiBvYmplY3RNb2RlLCB0aGVuIHRoYXQncyBhbiBlcnJvci5cbi8vIE90aGVyd2lzZSBzdHJlYW0gY2h1bmtzIGFyZSBhbGwgY29uc2lkZXJlZCB0byBiZSBvZiBsZW5ndGg9MSwgYW5kIHRoZVxuLy8gd2F0ZXJtYXJrcyBkZXRlcm1pbmUgaG93IG1hbnkgb2JqZWN0cyB0byBrZWVwIGluIHRoZSBidWZmZXIsIHJhdGhlciB0aGFuXG4vLyBob3cgbWFueSBieXRlcyBvciBjaGFyYWN0ZXJzLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmXG4gICAgICAnc3RyaW5nJyAhPT0gdHlwZW9mIGNodW5rICYmXG4gICAgICBjaHVuayAhPT0gbnVsbCAmJlxuICAgICAgY2h1bmsgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICB2YXIgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKVxuICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIGVsc2UgaWYgKCFlbmNvZGluZylcbiAgICBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKVxuICAgIGNiID0gZnVuY3Rpb24oKSB7fTtcblxuICBpZiAoc3RhdGUuZW5kZWQpXG4gICAgd3JpdGVBZnRlckVuZCh0aGlzLCBzdGF0ZSwgY2IpO1xuICBlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKVxuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJlxuICAgICAgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiZcbiAgICAgIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldClcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nKVxuICAgIHN0YXRlLmJ1ZmZlci5wdXNoKG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSk7XG4gIGVsc2VcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICBpZiAoc3luYylcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICBlbHNlXG4gICAgY2IoZXIpO1xuXG4gIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKVxuICAgIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO1xuICBlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKVxuICAgIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgY2IoKTtcbiAgaWYgKGZpbmlzaGVkKVxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcblxuICBmb3IgKHZhciBjID0gMDsgYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGg7IGMrKykge1xuICAgIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcltjXTtcbiAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICBjKys7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG4gIGlmIChjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICBzdGF0ZS5idWZmZXIgPSBzdGF0ZS5idWZmZXIuc2xpY2UoYyk7XG4gIGVsc2VcbiAgICBzdGF0ZS5idWZmZXIubGVuZ3RoID0gMDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIGNodW5rICE9PSAndW5kZWZpbmVkJyAmJiBjaHVuayAhPT0gbnVsbClcbiAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpXG4gICAgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIHJldHVybiAoc3RhdGUuZW5kaW5nICYmXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICAgIXN0YXRlLndyaXRpbmcpO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYik7XG4gICAgZWxzZVxuICAgICAgc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGFyZyk7XG59XG5leHBvcnRzLmlzQnVmZmVyID0gaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCIpXG4iLCJ2YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7IC8vIGhhY2sgdG8gZml4IGEgY2lyY3VsYXIgZGVwZW5kZW5jeSBpc3N1ZSB3aGVuIHVzZWQgd2l0aCBicm93c2VyaWZ5XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IFN0cmVhbTtcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1wiKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV93cml0YWJsZS5qc1wiKVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcycpO1xuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIGlzQnVmZmVyRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZ1xuICB8fCBmdW5jdGlvbihlbmNvZGluZykge1xuICAgICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgY2FzZSAnaGV4JzogY2FzZSAndXRmOCc6IGNhc2UgJ3V0Zi04JzogY2FzZSAnYXNjaWknOiBjYXNlICdiaW5hcnknOiBjYXNlICdiYXNlNjQnOiBjYXNlICd1Y3MyJzogY2FzZSAndWNzLTInOiBjYXNlICd1dGYxNmxlJzogY2FzZSAndXRmLTE2bGUnOiBjYXNlICdyYXcnOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgIH1cblxuXG5mdW5jdGlvbiBhc3NlcnRFbmNvZGluZyhlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgJiYgIWlzQnVmZmVyRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB9XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy4gQ0VTVS04IGlzIGhhbmRsZWQgYXMgcGFydCBvZiB0aGUgVVRGLTggZW5jb2RpbmcuXG4vL1xuLy8gQFRPRE8gSGFuZGxpbmcgYWxsIGVuY29kaW5ncyBpbnNpZGUgYSBzaW5nbGUgb2JqZWN0IG1ha2VzIGl0IHZlcnkgZGlmZmljdWx0XG4vLyB0byByZWFzb24gYWJvdXQgdGhpcyBjb2RlLCBzbyBpdCBzaG91bGQgYmUgc3BsaXQgdXAgaW4gdGhlIGZ1dHVyZS5cbi8vIEBUT0RPIFRoZXJlIHNob3VsZCBiZSBhIHV0Zjgtc3RyaWN0IGVuY29kaW5nIHRoYXQgcmVqZWN0cyBpbnZhbGlkIFVURi04IGNvZGVcbi8vIHBvaW50cyBhcyB1c2VkIGJ5IENFU1UtOC5cbnZhciBTdHJpbmdEZWNvZGVyID0gZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IChlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXS8sICcnKTtcbiAgYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIC8vIENFU1UtOCByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMy1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgLy8gVVRGLTE2IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAyLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAyO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgLy8gQmFzZS02NCBzdG9yZXMgMyBieXRlcyBpbiA0IGNoYXJzLCBhbmQgcGFkcyB0aGUgcmVtYWluZGVyLlxuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gcGFzc1Rocm91Z2hXcml0ZTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEVub3VnaCBzcGFjZSB0byBzdG9yZSBhbGwgYnl0ZXMgb2YgYSBzaW5nbGUgY2hhcmFjdGVyLiBVVEYtOCBuZWVkcyA0XG4gIC8vIGJ5dGVzLCBidXQgQ0VTVS04IG1heSByZXF1aXJlIHVwIHRvIDYgKDMgYnl0ZXMgcGVyIHN1cnJvZ2F0ZSkuXG4gIHRoaXMuY2hhckJ1ZmZlciA9IG5ldyBCdWZmZXIoNik7XG4gIC8vIE51bWJlciBvZiBieXRlcyByZWNlaXZlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSAwO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhckxlbmd0aCA9IDA7XG59O1xuXG5cbi8vIHdyaXRlIGRlY29kZXMgdGhlIGdpdmVuIGJ1ZmZlciBhbmQgcmV0dXJucyBpdCBhcyBKUyBzdHJpbmcgdGhhdCBpc1xuLy8gZ3VhcmFudGVlZCB0byBub3QgY29udGFpbiBhbnkgcGFydGlhbCBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuIEFueSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGlzIGJ1ZmZlcmVkIHVwLCBhbmQgd2lsbCBiZVxuLy8gcmV0dXJuZWQgd2hlbiBjYWxsaW5nIHdyaXRlIGFnYWluIHdpdGggdGhlIHJlbWFpbmluZyBieXRlcy5cbi8vXG4vLyBOb3RlOiBDb252ZXJ0aW5nIGEgQnVmZmVyIGNvbnRhaW5pbmcgYW4gb3JwaGFuIHN1cnJvZ2F0ZSB0byBhIFN0cmluZ1xuLy8gY3VycmVudGx5IHdvcmtzLCBidXQgY29udmVydGluZyBhIFN0cmluZyB0byBhIEJ1ZmZlciAodmlhIGBuZXcgQnVmZmVyYCwgb3Jcbi8vIEJ1ZmZlciN3cml0ZSkgd2lsbCByZXBsYWNlIGluY29tcGxldGUgc3Vycm9nYXRlcyB3aXRoIHRoZSB1bmljb2RlXG4vLyByZXBsYWNlbWVudCBjaGFyYWN0ZXIuIFNlZSBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzEyMTE3MzAwOS8gLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIGNoYXJTdHIgPSAnJztcbiAgLy8gaWYgb3VyIGxhc3Qgd3JpdGUgZW5kZWQgd2l0aCBhbiBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJcbiAgd2hpbGUgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGRldGVybWluZSBob3cgbWFueSByZW1haW5pbmcgYnl0ZXMgdGhpcyBidWZmZXIgaGFzIHRvIG9mZmVyIGZvciB0aGlzIGNoYXJcbiAgICB2YXIgYXZhaWxhYmxlID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cbiAgICAgICAgdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQgOlxuICAgICAgICBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoZSBuZXcgYnl0ZXMgdG8gdGhlIGNoYXIgYnVmZmVyXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgMCwgYXZhaWxhYmxlKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBhdmFpbGFibGU7XG5cbiAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGJ5dGVzIGJlbG9uZ2luZyB0byB0aGUgY3VycmVudCBjaGFyYWN0ZXIgZnJvbSB0aGUgYnVmZmVyXG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGF2YWlsYWJsZSwgYnVmZmVyLmxlbmd0aCk7XG5cbiAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBzcGxpdFxuICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoY2hhclN0ci5sZW5ndGggLSAxKTtcbiAgICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoICs9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICAgIGNoYXJTdHIgPSAnJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IHRoaXMuY2hhckxlbmd0aCA9IDA7XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBpbiB0aGlzIGJ1ZmZlciwganVzdCBlbWl0IG91ciBjaGFyXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyU3RyO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGRldGVybWluZSBhbmQgc2V0IGNoYXJMZW5ndGggLyBjaGFyUmVjZWl2ZWRcbiAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpO1xuXG4gIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gYnVmZmVyIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlciBieXRlcyB3ZSBnb3RcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCwgZW5kKTtcbiAgICBlbmQgLT0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gIH1cblxuICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xuXG4gIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XG4gIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChlbmQpO1xuICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgdGhpcy5jaGFyTGVuZ3RoICs9IHNpemU7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJCdWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHNpemUsIDAsIHNpemUpO1xuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgMCwgc2l6ZSk7XG4gICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gIH1cblxuICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcbiAgcmV0dXJuIGNoYXJTdHI7XG59O1xuXG4vLyBkZXRlY3RJbmNvbXBsZXRlQ2hhciBkZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGFuIGluY29tcGxldGUgVVRGLTggY2hhcmFjdGVyIGF0XG4vLyB0aGUgZW5kIG9mIHRoZSBnaXZlbiBidWZmZXIuIElmIHNvLCBpdCBzZXRzIHRoaXMuY2hhckxlbmd0aCB0byB0aGUgYnl0ZVxuLy8gbGVuZ3RoIHRoYXQgY2hhcmFjdGVyLCBhbmQgc2V0cyB0aGlzLmNoYXJSZWNlaXZlZCB0byB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4vLyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIHRoaXMgY2hhcmFjdGVyLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IGJ5dGVzIHdlIGhhdmUgdG8gY2hlY2sgYXQgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlclxuICB2YXIgaSA9IChidWZmZXIubGVuZ3RoID49IDMpID8gMyA6IGJ1ZmZlci5sZW5ndGg7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBvbmUgb2YgdGhlIGxhc3QgaSBieXRlcyBvZiBvdXIgYnVmZmVyIGFubm91bmNlcyBhblxuICAvLyBpbmNvbXBsZXRlIGNoYXIuXG4gIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIGMgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIGldO1xuXG4gICAgLy8gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cblxuICAgIC8vIDExMFhYWFhYXG4gICAgaWYgKGkgPT0gMSAmJiBjID4+IDUgPT0gMHgwNikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTBYWFhYXG4gICAgaWYgKGkgPD0gMiAmJiBjID4+IDQgPT0gMHgwRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTEwWFhYXG4gICAgaWYgKGkgPD0gMyAmJiBjID4+IDMgPT0gMHgxRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGk7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpXG4gICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xuXG4gIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xuICAgIHZhciBjciA9IHRoaXMuY2hhclJlY2VpdmVkO1xuICAgIHZhciBidWYgPSB0aGlzLmNoYXJCdWZmZXI7XG4gICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgcmVzICs9IGJ1Zi5zbGljZSgwLCBjcikudG9TdHJpbmcoZW5jKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAyO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDIgOiAwO1xufVxuXG5mdW5jdGlvbiBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMztcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAzIDogMDtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eW2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oW2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCFpc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55IGNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHRoZSBwYXJ0IG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXMgbm9uIEFTQ0lJIGNoYXJhY3RlcnMuIEkuZS4gaXQgZG9zZW50IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgaW4gQVNDSUkuXG4gICAgICB2YXIgZG9tYWluQXJyYXkgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KCcuJyk7XG4gICAgICB2YXIgbmV3T3V0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvbWFpbkFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzID0gZG9tYWluQXJyYXlbaV07XG4gICAgICAgIG5ld091dC5wdXNoKHMubWF0Y2goL1teQS1aYS16MC05Xy1dLykgP1xuICAgICAgICAgICAgJ3huLS0nICsgcHVueWNvZGUuZW5jb2RlKHMpIDogcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmhvc3RuYW1lID0gbmV3T3V0LmpvaW4oJy4nKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKGlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIGlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmIChpc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgT2JqZWN0LmtleXModGhpcykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgcmVzdWx0W2tdID0gdGhpc1trXTtcbiAgfSwgdGhpcyk7XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICBPYmplY3Qua2V5cyhyZWxhdGl2ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICBpZiAoayAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgfSk7XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgT2JqZWN0LmtleXMocmVsYXRpdmUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH0pO1xuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIWlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCkgJiYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fFxuICAgICAgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIWlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gIGFyZyA9PSBudWxsO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuLypnbG9iYWxzIEhhbmRsZWJhcnM6IHRydWUgKi9cbnZhciBIYW5kbGViYXJzID0gcmVxdWlyZShcIi4vaGFuZGxlYmFycy5ydW50aW1lXCIpW1wiZGVmYXVsdFwiXTtcblxuLy8gQ29tcGlsZXIgaW1wb3J0c1xudmFyIEFTVCA9IHJlcXVpcmUoXCIuL2hhbmRsZWJhcnMvY29tcGlsZXIvYXN0XCIpW1wiZGVmYXVsdFwiXTtcbnZhciBQYXJzZXIgPSByZXF1aXJlKFwiLi9oYW5kbGViYXJzL2NvbXBpbGVyL2Jhc2VcIikucGFyc2VyO1xudmFyIHBhcnNlID0gcmVxdWlyZShcIi4vaGFuZGxlYmFycy9jb21waWxlci9iYXNlXCIpLnBhcnNlO1xudmFyIENvbXBpbGVyID0gcmVxdWlyZShcIi4vaGFuZGxlYmFycy9jb21waWxlci9jb21waWxlclwiKS5Db21waWxlcjtcbnZhciBjb21waWxlID0gcmVxdWlyZShcIi4vaGFuZGxlYmFycy9jb21waWxlci9jb21waWxlclwiKS5jb21waWxlO1xudmFyIHByZWNvbXBpbGUgPSByZXF1aXJlKFwiLi9oYW5kbGViYXJzL2NvbXBpbGVyL2NvbXBpbGVyXCIpLnByZWNvbXBpbGU7XG52YXIgSmF2YVNjcmlwdENvbXBpbGVyID0gcmVxdWlyZShcIi4vaGFuZGxlYmFycy9jb21waWxlci9qYXZhc2NyaXB0LWNvbXBpbGVyXCIpW1wiZGVmYXVsdFwiXTtcblxudmFyIF9jcmVhdGUgPSBIYW5kbGViYXJzLmNyZWF0ZTtcbnZhciBjcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhiID0gX2NyZWF0ZSgpO1xuXG4gIGhiLmNvbXBpbGUgPSBmdW5jdGlvbihpbnB1dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBjb21waWxlKGlucHV0LCBvcHRpb25zLCBoYik7XG4gIH07XG4gIGhiLnByZWNvbXBpbGUgPSBmdW5jdGlvbiAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcHJlY29tcGlsZShpbnB1dCwgb3B0aW9ucywgaGIpO1xuICB9O1xuXG4gIGhiLkFTVCA9IEFTVDtcbiAgaGIuQ29tcGlsZXIgPSBDb21waWxlcjtcbiAgaGIuSmF2YVNjcmlwdENvbXBpbGVyID0gSmF2YVNjcmlwdENvbXBpbGVyO1xuICBoYi5QYXJzZXIgPSBQYXJzZXI7XG4gIGhiLnBhcnNlID0gcGFyc2U7XG5cbiAgcmV0dXJuIGhiO1xufTtcblxuSGFuZGxlYmFycyA9IGNyZWF0ZSgpO1xuSGFuZGxlYmFycy5jcmVhdGUgPSBjcmVhdGU7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gSGFuZGxlYmFyczsiLCJcInVzZSBzdHJpY3RcIjtcbi8qZ2xvYmFscyBIYW5kbGViYXJzOiB0cnVlICovXG52YXIgYmFzZSA9IHJlcXVpcmUoXCIuL2hhbmRsZWJhcnMvYmFzZVwiKTtcblxuLy8gRWFjaCBvZiB0aGVzZSBhdWdtZW50IHRoZSBIYW5kbGViYXJzIG9iamVjdC4gTm8gbmVlZCB0byBzZXR1cCBoZXJlLlxuLy8gKFRoaXMgaXMgZG9uZSB0byBlYXNpbHkgc2hhcmUgY29kZSBiZXR3ZWVuIGNvbW1vbmpzIGFuZCBicm93c2UgZW52cylcbnZhciBTYWZlU3RyaW5nID0gcmVxdWlyZShcIi4vaGFuZGxlYmFycy9zYWZlLXN0cmluZ1wiKVtcImRlZmF1bHRcIl07XG52YXIgRXhjZXB0aW9uID0gcmVxdWlyZShcIi4vaGFuZGxlYmFycy9leGNlcHRpb25cIilbXCJkZWZhdWx0XCJdO1xudmFyIFV0aWxzID0gcmVxdWlyZShcIi4vaGFuZGxlYmFycy91dGlsc1wiKTtcbnZhciBydW50aW1lID0gcmVxdWlyZShcIi4vaGFuZGxlYmFycy9ydW50aW1lXCIpO1xuXG4vLyBGb3IgY29tcGF0aWJpbGl0eSBhbmQgdXNhZ2Ugb3V0c2lkZSBvZiBtb2R1bGUgc3lzdGVtcywgbWFrZSB0aGUgSGFuZGxlYmFycyBvYmplY3QgYSBuYW1lc3BhY2VcbnZhciBjcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhiID0gbmV3IGJhc2UuSGFuZGxlYmFyc0Vudmlyb25tZW50KCk7XG5cbiAgVXRpbHMuZXh0ZW5kKGhiLCBiYXNlKTtcbiAgaGIuU2FmZVN0cmluZyA9IFNhZmVTdHJpbmc7XG4gIGhiLkV4Y2VwdGlvbiA9IEV4Y2VwdGlvbjtcbiAgaGIuVXRpbHMgPSBVdGlscztcblxuICBoYi5WTSA9IHJ1bnRpbWU7XG4gIGhiLnRlbXBsYXRlID0gZnVuY3Rpb24oc3BlYykge1xuICAgIHJldHVybiBydW50aW1lLnRlbXBsYXRlKHNwZWMsIGhiKTtcbiAgfTtcblxuICByZXR1cm4gaGI7XG59O1xuXG52YXIgSGFuZGxlYmFycyA9IGNyZWF0ZSgpO1xuSGFuZGxlYmFycy5jcmVhdGUgPSBjcmVhdGU7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gSGFuZGxlYmFyczsiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIEV4Y2VwdGlvbiA9IHJlcXVpcmUoXCIuL2V4Y2VwdGlvblwiKVtcImRlZmF1bHRcIl07XG5cbnZhciBWRVJTSU9OID0gXCIxLjMuMFwiO1xuZXhwb3J0cy5WRVJTSU9OID0gVkVSU0lPTjt2YXIgQ09NUElMRVJfUkVWSVNJT04gPSA0O1xuZXhwb3J0cy5DT01QSUxFUl9SRVZJU0lPTiA9IENPTVBJTEVSX1JFVklTSU9OO1xudmFyIFJFVklTSU9OX0NIQU5HRVMgPSB7XG4gIDE6ICc8PSAxLjAucmMuMicsIC8vIDEuMC5yYy4yIGlzIGFjdHVhbGx5IHJldjIgYnV0IGRvZXNuJ3QgcmVwb3J0IGl0XG4gIDI6ICc9PSAxLjAuMC1yYy4zJyxcbiAgMzogJz09IDEuMC4wLXJjLjQnLFxuICA0OiAnPj0gMS4wLjAnXG59O1xuZXhwb3J0cy5SRVZJU0lPTl9DSEFOR0VTID0gUkVWSVNJT05fQ0hBTkdFUztcbnZhciBpc0FycmF5ID0gVXRpbHMuaXNBcnJheSxcbiAgICBpc0Z1bmN0aW9uID0gVXRpbHMuaXNGdW5jdGlvbixcbiAgICB0b1N0cmluZyA9IFV0aWxzLnRvU3RyaW5nLFxuICAgIG9iamVjdFR5cGUgPSAnW29iamVjdCBPYmplY3RdJztcblxuZnVuY3Rpb24gSGFuZGxlYmFyc0Vudmlyb25tZW50KGhlbHBlcnMsIHBhcnRpYWxzKSB7XG4gIHRoaXMuaGVscGVycyA9IGhlbHBlcnMgfHwge307XG4gIHRoaXMucGFydGlhbHMgPSBwYXJ0aWFscyB8fCB7fTtcblxuICByZWdpc3RlckRlZmF1bHRIZWxwZXJzKHRoaXMpO1xufVxuXG5leHBvcnRzLkhhbmRsZWJhcnNFbnZpcm9ubWVudCA9IEhhbmRsZWJhcnNFbnZpcm9ubWVudDtIYW5kbGViYXJzRW52aXJvbm1lbnQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogSGFuZGxlYmFyc0Vudmlyb25tZW50LFxuXG4gIGxvZ2dlcjogbG9nZ2VyLFxuICBsb2c6IGxvZyxcblxuICByZWdpc3RlckhlbHBlcjogZnVuY3Rpb24obmFtZSwgZm4sIGludmVyc2UpIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xuICAgICAgaWYgKGludmVyc2UgfHwgZm4pIHsgdGhyb3cgbmV3IEV4Y2VwdGlvbignQXJnIG5vdCBzdXBwb3J0ZWQgd2l0aCBtdWx0aXBsZSBoZWxwZXJzJyk7IH1cbiAgICAgIFV0aWxzLmV4dGVuZCh0aGlzLmhlbHBlcnMsIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW52ZXJzZSkgeyBmbi5ub3QgPSBpbnZlcnNlOyB9XG4gICAgICB0aGlzLmhlbHBlcnNbbmFtZV0gPSBmbjtcbiAgICB9XG4gIH0sXG5cbiAgcmVnaXN0ZXJQYXJ0aWFsOiBmdW5jdGlvbihuYW1lLCBzdHIpIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xuICAgICAgVXRpbHMuZXh0ZW5kKHRoaXMucGFydGlhbHMsICBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJ0aWFsc1tuYW1lXSA9IHN0cjtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdEhlbHBlcnMoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2hlbHBlck1pc3NpbmcnLCBmdW5jdGlvbihhcmcpIHtcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFwiTWlzc2luZyBoZWxwZXI6ICdcIiArIGFyZyArIFwiJ1wiKTtcbiAgICB9XG4gIH0pO1xuXG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdibG9ja0hlbHBlck1pc3NpbmcnLCBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgdmFyIGludmVyc2UgPSBvcHRpb25zLmludmVyc2UgfHwgZnVuY3Rpb24oKSB7fSwgZm4gPSBvcHRpb25zLmZuO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oY29udGV4dCkpIHsgY29udGV4dCA9IGNvbnRleHQuY2FsbCh0aGlzKTsgfVxuXG4gICAgaWYoY29udGV4dCA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGZuKHRoaXMpO1xuICAgIH0gZWxzZSBpZihjb250ZXh0ID09PSBmYWxzZSB8fCBjb250ZXh0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBpbnZlcnNlKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShjb250ZXh0KSkge1xuICAgICAgaWYoY29udGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5oZWxwZXJzLmVhY2goY29udGV4dCwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW52ZXJzZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZuKGNvbnRleHQpO1xuICAgIH1cbiAgfSk7XG5cbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2VhY2gnLCBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgdmFyIGZuID0gb3B0aW9ucy5mbiwgaW52ZXJzZSA9IG9wdGlvbnMuaW52ZXJzZTtcbiAgICB2YXIgaSA9IDAsIHJldCA9IFwiXCIsIGRhdGE7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihjb250ZXh0KSkgeyBjb250ZXh0ID0gY29udGV4dC5jYWxsKHRoaXMpOyB9XG5cbiAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICBkYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICB9XG5cbiAgICBpZihjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0ID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGlzQXJyYXkoY29udGV4dCkpIHtcbiAgICAgICAgZm9yKHZhciBqID0gY29udGV4dC5sZW5ndGg7IGk8ajsgaSsrKSB7XG4gICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIGRhdGEuaW5kZXggPSBpO1xuICAgICAgICAgICAgZGF0YS5maXJzdCA9IChpID09PSAwKTtcbiAgICAgICAgICAgIGRhdGEubGFzdCAgPSAoaSA9PT0gKGNvbnRleHQubGVuZ3RoLTEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0ID0gcmV0ICsgZm4oY29udGV4dFtpXSwgeyBkYXRhOiBkYXRhIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IodmFyIGtleSBpbiBjb250ZXh0KSB7XG4gICAgICAgICAgaWYoY29udGV4dC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBpZihkYXRhKSB7IFxuICAgICAgICAgICAgICBkYXRhLmtleSA9IGtleTsgXG4gICAgICAgICAgICAgIGRhdGEuaW5kZXggPSBpO1xuICAgICAgICAgICAgICBkYXRhLmZpcnN0ID0gKGkgPT09IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0ID0gcmV0ICsgZm4oY29udGV4dFtrZXldLCB7ZGF0YTogZGF0YX0pO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKGkgPT09IDApe1xuICAgICAgcmV0ID0gaW52ZXJzZSh0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9KTtcblxuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignaWYnLCBmdW5jdGlvbihjb25kaXRpb25hbCwgb3B0aW9ucykge1xuICAgIGlmIChpc0Z1bmN0aW9uKGNvbmRpdGlvbmFsKSkgeyBjb25kaXRpb25hbCA9IGNvbmRpdGlvbmFsLmNhbGwodGhpcyk7IH1cblxuICAgIC8vIERlZmF1bHQgYmVoYXZpb3IgaXMgdG8gcmVuZGVyIHRoZSBwb3NpdGl2ZSBwYXRoIGlmIHRoZSB2YWx1ZSBpcyB0cnV0aHkgYW5kIG5vdCBlbXB0eS5cbiAgICAvLyBUaGUgYGluY2x1ZGVaZXJvYCBvcHRpb24gbWF5IGJlIHNldCB0byB0cmVhdCB0aGUgY29uZHRpb25hbCBhcyBwdXJlbHkgbm90IGVtcHR5IGJhc2VkIG9uIHRoZVxuICAgIC8vIGJlaGF2aW9yIG9mIGlzRW1wdHkuIEVmZmVjdGl2ZWx5IHRoaXMgZGV0ZXJtaW5lcyBpZiAwIGlzIGhhbmRsZWQgYnkgdGhlIHBvc2l0aXZlIHBhdGggb3IgbmVnYXRpdmUuXG4gICAgaWYgKCghb3B0aW9ucy5oYXNoLmluY2x1ZGVaZXJvICYmICFjb25kaXRpb25hbCkgfHwgVXRpbHMuaXNFbXB0eShjb25kaXRpb25hbCkpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmZuKHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ3VubGVzcycsIGZ1bmN0aW9uKGNvbmRpdGlvbmFsLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLmhlbHBlcnNbJ2lmJ10uY2FsbCh0aGlzLCBjb25kaXRpb25hbCwge2ZuOiBvcHRpb25zLmludmVyc2UsIGludmVyc2U6IG9wdGlvbnMuZm4sIGhhc2g6IG9wdGlvbnMuaGFzaH0pO1xuICB9KTtcblxuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignd2l0aCcsIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihjb250ZXh0KSkgeyBjb250ZXh0ID0gY29udGV4dC5jYWxsKHRoaXMpOyB9XG5cbiAgICBpZiAoIVV0aWxzLmlzRW1wdHkoY29udGV4dCkpIHJldHVybiBvcHRpb25zLmZuKGNvbnRleHQpO1xuICB9KTtcblxuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignbG9nJywgZnVuY3Rpb24oY29udGV4dCwgb3B0aW9ucykge1xuICAgIHZhciBsZXZlbCA9IG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmRhdGEubGV2ZWwgIT0gbnVsbCA/IHBhcnNlSW50KG9wdGlvbnMuZGF0YS5sZXZlbCwgMTApIDogMTtcbiAgICBpbnN0YW5jZS5sb2cobGV2ZWwsIGNvbnRleHQpO1xuICB9KTtcbn1cblxudmFyIGxvZ2dlciA9IHtcbiAgbWV0aG9kTWFwOiB7IDA6ICdkZWJ1ZycsIDE6ICdpbmZvJywgMjogJ3dhcm4nLCAzOiAnZXJyb3InIH0sXG5cbiAgLy8gU3RhdGUgZW51bVxuICBERUJVRzogMCxcbiAgSU5GTzogMSxcbiAgV0FSTjogMixcbiAgRVJST1I6IDMsXG4gIGxldmVsOiAzLFxuXG4gIC8vIGNhbiBiZSBvdmVycmlkZGVuIGluIHRoZSBob3N0IGVudmlyb25tZW50XG4gIGxvZzogZnVuY3Rpb24obGV2ZWwsIG9iaikge1xuICAgIGlmIChsb2dnZXIubGV2ZWwgPD0gbGV2ZWwpIHtcbiAgICAgIHZhciBtZXRob2QgPSBsb2dnZXIubWV0aG9kTWFwW2xldmVsXTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZVttZXRob2RdKSB7XG4gICAgICAgIGNvbnNvbGVbbWV0aG9kXS5jYWxsKGNvbnNvbGUsIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuZXhwb3J0cy5sb2dnZXIgPSBsb2dnZXI7XG5mdW5jdGlvbiBsb2cobGV2ZWwsIG9iaikgeyBsb2dnZXIubG9nKGxldmVsLCBvYmopOyB9XG5cbmV4cG9ydHMubG9nID0gbG9nO3ZhciBjcmVhdGVGcmFtZSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgb2JqID0ge307XG4gIFV0aWxzLmV4dGVuZChvYmosIG9iamVjdCk7XG4gIHJldHVybiBvYmo7XG59O1xuZXhwb3J0cy5jcmVhdGVGcmFtZSA9IGNyZWF0ZUZyYW1lOyIsIlwidXNlIHN0cmljdFwiO1xudmFyIEV4Y2VwdGlvbiA9IHJlcXVpcmUoXCIuLi9leGNlcHRpb25cIilbXCJkZWZhdWx0XCJdO1xuXG5mdW5jdGlvbiBMb2NhdGlvbkluZm8obG9jSW5mbyl7XG4gIGxvY0luZm8gPSBsb2NJbmZvIHx8IHt9O1xuICB0aGlzLmZpcnN0TGluZSAgID0gbG9jSW5mby5maXJzdF9saW5lO1xuICB0aGlzLmZpcnN0Q29sdW1uID0gbG9jSW5mby5maXJzdF9jb2x1bW47XG4gIHRoaXMubGFzdENvbHVtbiAgPSBsb2NJbmZvLmxhc3RfY29sdW1uO1xuICB0aGlzLmxhc3RMaW5lICAgID0gbG9jSW5mby5sYXN0X2xpbmU7XG59XG5cbnZhciBBU1QgPSB7XG4gIFByb2dyYW1Ob2RlOiBmdW5jdGlvbihzdGF0ZW1lbnRzLCBpbnZlcnNlU3RyaXAsIGludmVyc2UsIGxvY0luZm8pIHtcbiAgICB2YXIgaW52ZXJzZUxvY2F0aW9uSW5mbywgZmlyc3RJbnZlcnNlTm9kZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgbG9jSW5mbyA9IGludmVyc2U7XG4gICAgICBpbnZlcnNlID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGxvY0luZm8gPSBpbnZlcnNlU3RyaXA7XG4gICAgICBpbnZlcnNlU3RyaXAgPSBudWxsO1xuICAgIH1cblxuICAgIExvY2F0aW9uSW5mby5jYWxsKHRoaXMsIGxvY0luZm8pO1xuICAgIHRoaXMudHlwZSA9IFwicHJvZ3JhbVwiO1xuICAgIHRoaXMuc3RhdGVtZW50cyA9IHN0YXRlbWVudHM7XG4gICAgdGhpcy5zdHJpcCA9IHt9O1xuXG4gICAgaWYoaW52ZXJzZSkge1xuICAgICAgZmlyc3RJbnZlcnNlTm9kZSA9IGludmVyc2VbMF07XG4gICAgICBpZiAoZmlyc3RJbnZlcnNlTm9kZSkge1xuICAgICAgICBpbnZlcnNlTG9jYXRpb25JbmZvID0ge1xuICAgICAgICAgIGZpcnN0X2xpbmU6IGZpcnN0SW52ZXJzZU5vZGUuZmlyc3RMaW5lLFxuICAgICAgICAgIGxhc3RfbGluZTogZmlyc3RJbnZlcnNlTm9kZS5sYXN0TGluZSxcbiAgICAgICAgICBsYXN0X2NvbHVtbjogZmlyc3RJbnZlcnNlTm9kZS5sYXN0Q29sdW1uLFxuICAgICAgICAgIGZpcnN0X2NvbHVtbjogZmlyc3RJbnZlcnNlTm9kZS5maXJzdENvbHVtblxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmludmVyc2UgPSBuZXcgQVNULlByb2dyYW1Ob2RlKGludmVyc2UsIGludmVyc2VTdHJpcCwgaW52ZXJzZUxvY2F0aW9uSW5mbyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmludmVyc2UgPSBuZXcgQVNULlByb2dyYW1Ob2RlKGludmVyc2UsIGludmVyc2VTdHJpcCk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0cmlwLnJpZ2h0ID0gaW52ZXJzZVN0cmlwLmxlZnQ7XG4gICAgfSBlbHNlIGlmIChpbnZlcnNlU3RyaXApIHtcbiAgICAgIHRoaXMuc3RyaXAubGVmdCA9IGludmVyc2VTdHJpcC5yaWdodDtcbiAgICB9XG4gIH0sXG5cbiAgTXVzdGFjaGVOb2RlOiBmdW5jdGlvbihyYXdQYXJhbXMsIGhhc2gsIG9wZW4sIHN0cmlwLCBsb2NJbmZvKSB7XG4gICAgTG9jYXRpb25JbmZvLmNhbGwodGhpcywgbG9jSW5mbyk7XG4gICAgdGhpcy50eXBlID0gXCJtdXN0YWNoZVwiO1xuICAgIHRoaXMuc3RyaXAgPSBzdHJpcDtcblxuICAgIC8vIE9wZW4gbWF5IGJlIGEgc3RyaW5nIHBhcnNlZCBmcm9tIHRoZSBwYXJzZXIgb3IgYSBwYXNzZWQgYm9vbGVhbiBmbGFnXG4gICAgaWYgKG9wZW4gIT0gbnVsbCAmJiBvcGVuLmNoYXJBdCkge1xuICAgICAgLy8gTXVzdCB1c2UgY2hhckF0IHRvIHN1cHBvcnQgSUUgcHJlLTEwXG4gICAgICB2YXIgZXNjYXBlRmxhZyA9IG9wZW4uY2hhckF0KDMpIHx8IG9wZW4uY2hhckF0KDIpO1xuICAgICAgdGhpcy5lc2NhcGVkID0gZXNjYXBlRmxhZyAhPT0gJ3snICYmIGVzY2FwZUZsYWcgIT09ICcmJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lc2NhcGVkID0gISFvcGVuO1xuICAgIH1cblxuICAgIGlmIChyYXdQYXJhbXMgaW5zdGFuY2VvZiBBU1QuU2V4cHJOb2RlKSB7XG4gICAgICB0aGlzLnNleHByID0gcmF3UGFyYW1zO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdXBwb3J0IG9sZCBBU1QgQVBJXG4gICAgICB0aGlzLnNleHByID0gbmV3IEFTVC5TZXhwck5vZGUocmF3UGFyYW1zLCBoYXNoKTtcbiAgICB9XG5cbiAgICB0aGlzLnNleHByLmlzUm9vdCA9IHRydWU7XG5cbiAgICAvLyBTdXBwb3J0IG9sZCBBU1QgQVBJIHRoYXQgc3RvcmVkIHRoaXMgaW5mbyBpbiBNdXN0YWNoZU5vZGVcbiAgICB0aGlzLmlkID0gdGhpcy5zZXhwci5pZDtcbiAgICB0aGlzLnBhcmFtcyA9IHRoaXMuc2V4cHIucGFyYW1zO1xuICAgIHRoaXMuaGFzaCA9IHRoaXMuc2V4cHIuaGFzaDtcbiAgICB0aGlzLmVsaWdpYmxlSGVscGVyID0gdGhpcy5zZXhwci5lbGlnaWJsZUhlbHBlcjtcbiAgICB0aGlzLmlzSGVscGVyID0gdGhpcy5zZXhwci5pc0hlbHBlcjtcbiAgfSxcblxuICBTZXhwck5vZGU6IGZ1bmN0aW9uKHJhd1BhcmFtcywgaGFzaCwgbG9jSW5mbykge1xuICAgIExvY2F0aW9uSW5mby5jYWxsKHRoaXMsIGxvY0luZm8pO1xuXG4gICAgdGhpcy50eXBlID0gXCJzZXhwclwiO1xuICAgIHRoaXMuaGFzaCA9IGhhc2g7XG5cbiAgICB2YXIgaWQgPSB0aGlzLmlkID0gcmF3UGFyYW1zWzBdO1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLnBhcmFtcyA9IHJhd1BhcmFtcy5zbGljZSgxKTtcblxuICAgIC8vIGEgbXVzdGFjaGUgaXMgYW4gZWxpZ2libGUgaGVscGVyIGlmOlxuICAgIC8vICogaXRzIGlkIGlzIHNpbXBsZSAoYSBzaW5nbGUgcGFydCwgbm90IGB0aGlzYCBvciBgLi5gKVxuICAgIHZhciBlbGlnaWJsZUhlbHBlciA9IHRoaXMuZWxpZ2libGVIZWxwZXIgPSBpZC5pc1NpbXBsZTtcblxuICAgIC8vIGEgbXVzdGFjaGUgaXMgZGVmaW5pdGVseSBhIGhlbHBlciBpZjpcbiAgICAvLyAqIGl0IGlzIGFuIGVsaWdpYmxlIGhlbHBlciwgYW5kXG4gICAgLy8gKiBpdCBoYXMgYXQgbGVhc3Qgb25lIHBhcmFtZXRlciBvciBoYXNoIHNlZ21lbnRcbiAgICB0aGlzLmlzSGVscGVyID0gZWxpZ2libGVIZWxwZXIgJiYgKHBhcmFtcy5sZW5ndGggfHwgaGFzaCk7XG5cbiAgICAvLyBpZiBhIG11c3RhY2hlIGlzIGFuIGVsaWdpYmxlIGhlbHBlciBidXQgbm90IGEgZGVmaW5pdGVcbiAgICAvLyBoZWxwZXIsIGl0IGlzIGFtYmlndW91cywgYW5kIHdpbGwgYmUgcmVzb2x2ZWQgaW4gYSBsYXRlclxuICAgIC8vIHBhc3Mgb3IgYXQgcnVudGltZS5cbiAgfSxcblxuICBQYXJ0aWFsTm9kZTogZnVuY3Rpb24ocGFydGlhbE5hbWUsIGNvbnRleHQsIHN0cmlwLCBsb2NJbmZvKSB7XG4gICAgTG9jYXRpb25JbmZvLmNhbGwodGhpcywgbG9jSW5mbyk7XG4gICAgdGhpcy50eXBlICAgICAgICAgPSBcInBhcnRpYWxcIjtcbiAgICB0aGlzLnBhcnRpYWxOYW1lICA9IHBhcnRpYWxOYW1lO1xuICAgIHRoaXMuY29udGV4dCAgICAgID0gY29udGV4dDtcbiAgICB0aGlzLnN0cmlwID0gc3RyaXA7XG4gIH0sXG5cbiAgQmxvY2tOb2RlOiBmdW5jdGlvbihtdXN0YWNoZSwgcHJvZ3JhbSwgaW52ZXJzZSwgY2xvc2UsIGxvY0luZm8pIHtcbiAgICBMb2NhdGlvbkluZm8uY2FsbCh0aGlzLCBsb2NJbmZvKTtcblxuICAgIGlmKG11c3RhY2hlLnNleHByLmlkLm9yaWdpbmFsICE9PSBjbG9zZS5wYXRoLm9yaWdpbmFsKSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKG11c3RhY2hlLnNleHByLmlkLm9yaWdpbmFsICsgXCIgZG9lc24ndCBtYXRjaCBcIiArIGNsb3NlLnBhdGgub3JpZ2luYWwsIHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMudHlwZSA9ICdibG9jayc7XG4gICAgdGhpcy5tdXN0YWNoZSA9IG11c3RhY2hlO1xuICAgIHRoaXMucHJvZ3JhbSAgPSBwcm9ncmFtO1xuICAgIHRoaXMuaW52ZXJzZSAgPSBpbnZlcnNlO1xuXG4gICAgdGhpcy5zdHJpcCA9IHtcbiAgICAgIGxlZnQ6IG11c3RhY2hlLnN0cmlwLmxlZnQsXG4gICAgICByaWdodDogY2xvc2Uuc3RyaXAucmlnaHRcbiAgICB9O1xuXG4gICAgKHByb2dyYW0gfHwgaW52ZXJzZSkuc3RyaXAubGVmdCA9IG11c3RhY2hlLnN0cmlwLnJpZ2h0O1xuICAgIChpbnZlcnNlIHx8IHByb2dyYW0pLnN0cmlwLnJpZ2h0ID0gY2xvc2Uuc3RyaXAubGVmdDtcblxuICAgIGlmIChpbnZlcnNlICYmICFwcm9ncmFtKSB7XG4gICAgICB0aGlzLmlzSW52ZXJzZSA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIENvbnRlbnROb2RlOiBmdW5jdGlvbihzdHJpbmcsIGxvY0luZm8pIHtcbiAgICBMb2NhdGlvbkluZm8uY2FsbCh0aGlzLCBsb2NJbmZvKTtcbiAgICB0aGlzLnR5cGUgPSBcImNvbnRlbnRcIjtcbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgfSxcblxuICBIYXNoTm9kZTogZnVuY3Rpb24ocGFpcnMsIGxvY0luZm8pIHtcbiAgICBMb2NhdGlvbkluZm8uY2FsbCh0aGlzLCBsb2NJbmZvKTtcbiAgICB0aGlzLnR5cGUgPSBcImhhc2hcIjtcbiAgICB0aGlzLnBhaXJzID0gcGFpcnM7XG4gIH0sXG5cbiAgSWROb2RlOiBmdW5jdGlvbihwYXJ0cywgbG9jSW5mbykge1xuICAgIExvY2F0aW9uSW5mby5jYWxsKHRoaXMsIGxvY0luZm8pO1xuICAgIHRoaXMudHlwZSA9IFwiSURcIjtcblxuICAgIHZhciBvcmlnaW5hbCA9IFwiXCIsXG4gICAgICAgIGRpZyA9IFtdLFxuICAgICAgICBkZXB0aCA9IDA7XG5cbiAgICBmb3IodmFyIGk9MCxsPXBhcnRzLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV0ucGFydDtcbiAgICAgIG9yaWdpbmFsICs9IChwYXJ0c1tpXS5zZXBhcmF0b3IgfHwgJycpICsgcGFydDtcblxuICAgICAgaWYgKHBhcnQgPT09IFwiLi5cIiB8fCBwYXJ0ID09PSBcIi5cIiB8fCBwYXJ0ID09PSBcInRoaXNcIikge1xuICAgICAgICBpZiAoZGlnLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFwiSW52YWxpZCBwYXRoOiBcIiArIG9yaWdpbmFsLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSBcIi4uXCIpIHtcbiAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaXNTY29wZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWcucHVzaChwYXJ0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm9yaWdpbmFsID0gb3JpZ2luYWw7XG4gICAgdGhpcy5wYXJ0cyAgICA9IGRpZztcbiAgICB0aGlzLnN0cmluZyAgID0gZGlnLmpvaW4oJy4nKTtcbiAgICB0aGlzLmRlcHRoICAgID0gZGVwdGg7XG5cbiAgICAvLyBhbiBJRCBpcyBzaW1wbGUgaWYgaXQgb25seSBoYXMgb25lIHBhcnQsIGFuZCB0aGF0IHBhcnQgaXMgbm90XG4gICAgLy8gYC4uYCBvciBgdGhpc2AuXG4gICAgdGhpcy5pc1NpbXBsZSA9IHBhcnRzLmxlbmd0aCA9PT0gMSAmJiAhdGhpcy5pc1Njb3BlZCAmJiBkZXB0aCA9PT0gMDtcblxuICAgIHRoaXMuc3RyaW5nTW9kZVZhbHVlID0gdGhpcy5zdHJpbmc7XG4gIH0sXG5cbiAgUGFydGlhbE5hbWVOb2RlOiBmdW5jdGlvbihuYW1lLCBsb2NJbmZvKSB7XG4gICAgTG9jYXRpb25JbmZvLmNhbGwodGhpcywgbG9jSW5mbyk7XG4gICAgdGhpcy50eXBlID0gXCJQQVJUSUFMX05BTUVcIjtcbiAgICB0aGlzLm5hbWUgPSBuYW1lLm9yaWdpbmFsO1xuICB9LFxuXG4gIERhdGFOb2RlOiBmdW5jdGlvbihpZCwgbG9jSW5mbykge1xuICAgIExvY2F0aW9uSW5mby5jYWxsKHRoaXMsIGxvY0luZm8pO1xuICAgIHRoaXMudHlwZSA9IFwiREFUQVwiO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgfSxcblxuICBTdHJpbmdOb2RlOiBmdW5jdGlvbihzdHJpbmcsIGxvY0luZm8pIHtcbiAgICBMb2NhdGlvbkluZm8uY2FsbCh0aGlzLCBsb2NJbmZvKTtcbiAgICB0aGlzLnR5cGUgPSBcIlNUUklOR1wiO1xuICAgIHRoaXMub3JpZ2luYWwgPVxuICAgICAgdGhpcy5zdHJpbmcgPVxuICAgICAgdGhpcy5zdHJpbmdNb2RlVmFsdWUgPSBzdHJpbmc7XG4gIH0sXG5cbiAgSW50ZWdlck5vZGU6IGZ1bmN0aW9uKGludGVnZXIsIGxvY0luZm8pIHtcbiAgICBMb2NhdGlvbkluZm8uY2FsbCh0aGlzLCBsb2NJbmZvKTtcbiAgICB0aGlzLnR5cGUgPSBcIklOVEVHRVJcIjtcbiAgICB0aGlzLm9yaWdpbmFsID1cbiAgICAgIHRoaXMuaW50ZWdlciA9IGludGVnZXI7XG4gICAgdGhpcy5zdHJpbmdNb2RlVmFsdWUgPSBOdW1iZXIoaW50ZWdlcik7XG4gIH0sXG5cbiAgQm9vbGVhbk5vZGU6IGZ1bmN0aW9uKGJvb2wsIGxvY0luZm8pIHtcbiAgICBMb2NhdGlvbkluZm8uY2FsbCh0aGlzLCBsb2NJbmZvKTtcbiAgICB0aGlzLnR5cGUgPSBcIkJPT0xFQU5cIjtcbiAgICB0aGlzLmJvb2wgPSBib29sO1xuICAgIHRoaXMuc3RyaW5nTW9kZVZhbHVlID0gYm9vbCA9PT0gXCJ0cnVlXCI7XG4gIH0sXG5cbiAgQ29tbWVudE5vZGU6IGZ1bmN0aW9uKGNvbW1lbnQsIGxvY0luZm8pIHtcbiAgICBMb2NhdGlvbkluZm8uY2FsbCh0aGlzLCBsb2NJbmZvKTtcbiAgICB0aGlzLnR5cGUgPSBcImNvbW1lbnRcIjtcbiAgICB0aGlzLmNvbW1lbnQgPSBjb21tZW50O1xuICB9XG59O1xuXG4vLyBNdXN0IGJlIGV4cG9ydGVkIGFzIGFuIG9iamVjdCByYXRoZXIgdGhhbiB0aGUgcm9vdCBvZiB0aGUgbW9kdWxlIGFzIHRoZSBqaXNvbiBsZXhlclxuLy8gbW9zdCBtb2RpZnkgdGhlIG9iamVjdCB0byBvcGVyYXRlIHByb3Blcmx5LlxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBBU1Q7IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcGFyc2VyID0gcmVxdWlyZShcIi4vcGFyc2VyXCIpW1wiZGVmYXVsdFwiXTtcbnZhciBBU1QgPSByZXF1aXJlKFwiLi9hc3RcIilbXCJkZWZhdWx0XCJdO1xuXG5leHBvcnRzLnBhcnNlciA9IHBhcnNlcjtcblxuZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgLy8gSnVzdCByZXR1cm4gaWYgYW4gYWxyZWFkeS1jb21waWxlIEFTVCB3YXMgcGFzc2VkIGluLlxuICBpZihpbnB1dC5jb25zdHJ1Y3RvciA9PT0gQVNULlByb2dyYW1Ob2RlKSB7IHJldHVybiBpbnB1dDsgfVxuXG4gIHBhcnNlci55eSA9IEFTVDtcbiAgcmV0dXJuIHBhcnNlci5wYXJzZShpbnB1dCk7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTsiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBFeGNlcHRpb24gPSByZXF1aXJlKFwiLi4vZXhjZXB0aW9uXCIpW1wiZGVmYXVsdFwiXTtcblxuZnVuY3Rpb24gQ29tcGlsZXIoKSB7fVxuXG5leHBvcnRzLkNvbXBpbGVyID0gQ29tcGlsZXI7Ly8gdGhlIGZvdW5kSGVscGVyIHJlZ2lzdGVyIHdpbGwgZGlzYW1iaWd1YXRlIGhlbHBlciBsb29rdXAgZnJvbSBmaW5kaW5nIGFcbi8vIGZ1bmN0aW9uIGluIGEgY29udGV4dC4gVGhpcyBpcyBuZWNlc3NhcnkgZm9yIG11c3RhY2hlIGNvbXBhdGliaWxpdHksIHdoaWNoXG4vLyByZXF1aXJlcyB0aGF0IGNvbnRleHQgZnVuY3Rpb25zIGluIGJsb2NrcyBhcmUgZXZhbHVhdGVkIGJ5IGJsb2NrSGVscGVyTWlzc2luZyxcbi8vIGFuZCB0aGVuIHByb2NlZWQgYXMgaWYgdGhlIHJlc3VsdGluZyB2YWx1ZSB3YXMgcHJvdmlkZWQgdG8gYmxvY2tIZWxwZXJNaXNzaW5nLlxuXG5Db21waWxlci5wcm90b3R5cGUgPSB7XG4gIGNvbXBpbGVyOiBDb21waWxlcixcblxuICBkaXNhc3NlbWJsZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9wY29kZXMgPSB0aGlzLm9wY29kZXMsIG9wY29kZSwgb3V0ID0gW10sIHBhcmFtcywgcGFyYW07XG5cbiAgICBmb3IgKHZhciBpPTAsIGw9b3Bjb2Rlcy5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICBvcGNvZGUgPSBvcGNvZGVzW2ldO1xuXG4gICAgICBpZiAob3Bjb2RlLm9wY29kZSA9PT0gJ0RFQ0xBUkUnKSB7XG4gICAgICAgIG91dC5wdXNoKFwiREVDTEFSRSBcIiArIG9wY29kZS5uYW1lICsgXCI9XCIgKyBvcGNvZGUudmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zID0gW107XG4gICAgICAgIGZvciAodmFyIGo9MDsgajxvcGNvZGUuYXJncy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHBhcmFtID0gb3Bjb2RlLmFyZ3Nbal07XG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcGFyYW0gPSBcIlxcXCJcIiArIHBhcmFtLnJlcGxhY2UoXCJcXG5cIiwgXCJcXFxcblwiKSArIFwiXFxcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJhbXMucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0LnB1c2gob3Bjb2RlLm9wY29kZSArIFwiIFwiICsgcGFyYW1zLmpvaW4oXCIgXCIpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0LmpvaW4oXCJcXG5cIik7XG4gIH0sXG5cbiAgZXF1YWxzOiBmdW5jdGlvbihvdGhlcikge1xuICAgIHZhciBsZW4gPSB0aGlzLm9wY29kZXMubGVuZ3RoO1xuICAgIGlmIChvdGhlci5vcGNvZGVzLmxlbmd0aCAhPT0gbGVuKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIG9wY29kZSA9IHRoaXMub3Bjb2Rlc1tpXSxcbiAgICAgICAgICBvdGhlck9wY29kZSA9IG90aGVyLm9wY29kZXNbaV07XG4gICAgICBpZiAob3Bjb2RlLm9wY29kZSAhPT0gb3RoZXJPcGNvZGUub3Bjb2RlIHx8IG9wY29kZS5hcmdzLmxlbmd0aCAhPT0gb3RoZXJPcGNvZGUuYXJncy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvcGNvZGUuYXJncy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAob3Bjb2RlLmFyZ3Nbal0gIT09IG90aGVyT3Bjb2RlLmFyZ3Nbal0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICBpZiAob3RoZXIuY2hpbGRyZW4ubGVuZ3RoICE9PSBsZW4pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMuY2hpbGRyZW5baV0uZXF1YWxzKG90aGVyLmNoaWxkcmVuW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgZ3VpZDogMCxcblxuICBjb21waWxlOiBmdW5jdGlvbihwcm9ncmFtLCBvcHRpb25zKSB7XG4gICAgdGhpcy5vcGNvZGVzID0gW107XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMuZGVwdGhzID0ge2xpc3Q6IFtdfTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgLy8gVGhlc2UgY2hhbmdlcyB3aWxsIHByb3BhZ2F0ZSB0byB0aGUgb3RoZXIgY29tcGlsZXIgY29tcG9uZW50c1xuICAgIHZhciBrbm93bkhlbHBlcnMgPSB0aGlzLm9wdGlvbnMua25vd25IZWxwZXJzO1xuICAgIHRoaXMub3B0aW9ucy5rbm93bkhlbHBlcnMgPSB7XG4gICAgICAnaGVscGVyTWlzc2luZyc6IHRydWUsXG4gICAgICAnYmxvY2tIZWxwZXJNaXNzaW5nJzogdHJ1ZSxcbiAgICAgICdlYWNoJzogdHJ1ZSxcbiAgICAgICdpZic6IHRydWUsXG4gICAgICAndW5sZXNzJzogdHJ1ZSxcbiAgICAgICd3aXRoJzogdHJ1ZSxcbiAgICAgICdsb2cnOiB0cnVlXG4gICAgfTtcbiAgICBpZiAoa25vd25IZWxwZXJzKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGtub3duSGVscGVycykge1xuICAgICAgICB0aGlzLm9wdGlvbnMua25vd25IZWxwZXJzW25hbWVdID0ga25vd25IZWxwZXJzW25hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFjY2VwdChwcm9ncmFtKTtcbiAgfSxcblxuICBhY2NlcHQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgc3RyaXAgPSBub2RlLnN0cmlwIHx8IHt9LFxuICAgICAgICByZXQ7XG4gICAgaWYgKHN0cmlwLmxlZnQpIHtcbiAgICAgIHRoaXMub3Bjb2RlKCdzdHJpcCcpO1xuICAgIH1cblxuICAgIHJldCA9IHRoaXNbbm9kZS50eXBlXShub2RlKTtcblxuICAgIGlmIChzdHJpcC5yaWdodCkge1xuICAgICAgdGhpcy5vcGNvZGUoJ3N0cmlwJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICBwcm9ncmFtOiBmdW5jdGlvbihwcm9ncmFtKSB7XG4gICAgdmFyIHN0YXRlbWVudHMgPSBwcm9ncmFtLnN0YXRlbWVudHM7XG5cbiAgICBmb3IodmFyIGk9MCwgbD1zdGF0ZW1lbnRzLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgIHRoaXMuYWNjZXB0KHN0YXRlbWVudHNbaV0pO1xuICAgIH1cbiAgICB0aGlzLmlzU2ltcGxlID0gbCA9PT0gMTtcblxuICAgIHRoaXMuZGVwdGhzLmxpc3QgPSB0aGlzLmRlcHRocy5saXN0LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgY29tcGlsZVByb2dyYW06IGZ1bmN0aW9uKHByb2dyYW0pIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IHRoaXMuY29tcGlsZXIoKS5jb21waWxlKHByb2dyYW0sIHRoaXMub3B0aW9ucyk7XG4gICAgdmFyIGd1aWQgPSB0aGlzLmd1aWQrKywgZGVwdGg7XG5cbiAgICB0aGlzLnVzZVBhcnRpYWwgPSB0aGlzLnVzZVBhcnRpYWwgfHwgcmVzdWx0LnVzZVBhcnRpYWw7XG5cbiAgICB0aGlzLmNoaWxkcmVuW2d1aWRdID0gcmVzdWx0O1xuXG4gICAgZm9yKHZhciBpPTAsIGw9cmVzdWx0LmRlcHRocy5saXN0Lmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgIGRlcHRoID0gcmVzdWx0LmRlcHRocy5saXN0W2ldO1xuXG4gICAgICBpZihkZXB0aCA8IDIpIHsgY29udGludWU7IH1cbiAgICAgIGVsc2UgeyB0aGlzLmFkZERlcHRoKGRlcHRoIC0gMSk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ3VpZDtcbiAgfSxcblxuICBibG9jazogZnVuY3Rpb24oYmxvY2spIHtcbiAgICB2YXIgbXVzdGFjaGUgPSBibG9jay5tdXN0YWNoZSxcbiAgICAgICAgcHJvZ3JhbSA9IGJsb2NrLnByb2dyYW0sXG4gICAgICAgIGludmVyc2UgPSBibG9jay5pbnZlcnNlO1xuXG4gICAgaWYgKHByb2dyYW0pIHtcbiAgICAgIHByb2dyYW0gPSB0aGlzLmNvbXBpbGVQcm9ncmFtKHByb2dyYW0pO1xuICAgIH1cblxuICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICBpbnZlcnNlID0gdGhpcy5jb21waWxlUHJvZ3JhbShpbnZlcnNlKTtcbiAgICB9XG5cbiAgICB2YXIgc2V4cHIgPSBtdXN0YWNoZS5zZXhwcjtcbiAgICB2YXIgdHlwZSA9IHRoaXMuY2xhc3NpZnlTZXhwcihzZXhwcik7XG5cbiAgICBpZiAodHlwZSA9PT0gXCJoZWxwZXJcIikge1xuICAgICAgdGhpcy5oZWxwZXJTZXhwcihzZXhwciwgcHJvZ3JhbSwgaW52ZXJzZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcInNpbXBsZVwiKSB7XG4gICAgICB0aGlzLnNpbXBsZVNleHByKHNleHByKTtcblxuICAgICAgLy8gbm93IHRoYXQgdGhlIHNpbXBsZSBtdXN0YWNoZSBpcyByZXNvbHZlZCwgd2UgbmVlZCB0b1xuICAgICAgLy8gZXZhbHVhdGUgaXQgYnkgZXhlY3V0aW5nIGBibG9ja0hlbHBlck1pc3NpbmdgXG4gICAgICB0aGlzLm9wY29kZSgncHVzaFByb2dyYW0nLCBwcm9ncmFtKTtcbiAgICAgIHRoaXMub3Bjb2RlKCdwdXNoUHJvZ3JhbScsIGludmVyc2UpO1xuICAgICAgdGhpcy5vcGNvZGUoJ2VtcHR5SGFzaCcpO1xuICAgICAgdGhpcy5vcGNvZGUoJ2Jsb2NrVmFsdWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hbWJpZ3VvdXNTZXhwcihzZXhwciwgcHJvZ3JhbSwgaW52ZXJzZSk7XG5cbiAgICAgIC8vIG5vdyB0aGF0IHRoZSBzaW1wbGUgbXVzdGFjaGUgaXMgcmVzb2x2ZWQsIHdlIG5lZWQgdG9cbiAgICAgIC8vIGV2YWx1YXRlIGl0IGJ5IGV4ZWN1dGluZyBgYmxvY2tIZWxwZXJNaXNzaW5nYFxuICAgICAgdGhpcy5vcGNvZGUoJ3B1c2hQcm9ncmFtJywgcHJvZ3JhbSk7XG4gICAgICB0aGlzLm9wY29kZSgncHVzaFByb2dyYW0nLCBpbnZlcnNlKTtcbiAgICAgIHRoaXMub3Bjb2RlKCdlbXB0eUhhc2gnKTtcbiAgICAgIHRoaXMub3Bjb2RlKCdhbWJpZ3VvdXNCbG9ja1ZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5vcGNvZGUoJ2FwcGVuZCcpO1xuICB9LFxuXG4gIGhhc2g6IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICB2YXIgcGFpcnMgPSBoYXNoLnBhaXJzLCBwYWlyLCB2YWw7XG5cbiAgICB0aGlzLm9wY29kZSgncHVzaEhhc2gnKTtcblxuICAgIGZvcih2YXIgaT0wLCBsPXBhaXJzLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgICAgIHBhaXIgPSBwYWlyc1tpXTtcbiAgICAgIHZhbCAgPSBwYWlyWzFdO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN0cmluZ1BhcmFtcykge1xuICAgICAgICBpZih2YWwuZGVwdGgpIHtcbiAgICAgICAgICB0aGlzLmFkZERlcHRoKHZhbC5kZXB0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcGNvZGUoJ2dldENvbnRleHQnLCB2YWwuZGVwdGggfHwgMCk7XG4gICAgICAgIHRoaXMub3Bjb2RlKCdwdXNoU3RyaW5nUGFyYW0nLCB2YWwuc3RyaW5nTW9kZVZhbHVlLCB2YWwudHlwZSk7XG5cbiAgICAgICAgaWYgKHZhbC50eXBlID09PSAnc2V4cHInKSB7XG4gICAgICAgICAgLy8gU3ViZXhwcmVzc2lvbnMgZ2V0IGV2YWx1YXRlZCBhbmQgcGFzc2VkIGluXG4gICAgICAgICAgLy8gaW4gc3RyaW5nIHBhcmFtcyBtb2RlLlxuICAgICAgICAgIHRoaXMuc2V4cHIodmFsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hY2NlcHQodmFsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcGNvZGUoJ2Fzc2lnblRvSGFzaCcsIHBhaXJbMF0pO1xuICAgIH1cbiAgICB0aGlzLm9wY29kZSgncG9wSGFzaCcpO1xuICB9LFxuXG4gIHBhcnRpYWw6IGZ1bmN0aW9uKHBhcnRpYWwpIHtcbiAgICB2YXIgcGFydGlhbE5hbWUgPSBwYXJ0aWFsLnBhcnRpYWxOYW1lO1xuICAgIHRoaXMudXNlUGFydGlhbCA9IHRydWU7XG5cbiAgICBpZihwYXJ0aWFsLmNvbnRleHQpIHtcbiAgICAgIHRoaXMuSUQocGFydGlhbC5jb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcGNvZGUoJ3B1c2gnLCAnZGVwdGgwJyk7XG4gICAgfVxuXG4gICAgdGhpcy5vcGNvZGUoJ2ludm9rZVBhcnRpYWwnLCBwYXJ0aWFsTmFtZS5uYW1lKTtcbiAgICB0aGlzLm9wY29kZSgnYXBwZW5kJyk7XG4gIH0sXG5cbiAgY29udGVudDogZnVuY3Rpb24oY29udGVudCkge1xuICAgIHRoaXMub3Bjb2RlKCdhcHBlbmRDb250ZW50JywgY29udGVudC5zdHJpbmcpO1xuICB9LFxuXG4gIG11c3RhY2hlOiBmdW5jdGlvbihtdXN0YWNoZSkge1xuICAgIHRoaXMuc2V4cHIobXVzdGFjaGUuc2V4cHIpO1xuXG4gICAgaWYobXVzdGFjaGUuZXNjYXBlZCAmJiAhdGhpcy5vcHRpb25zLm5vRXNjYXBlKSB7XG4gICAgICB0aGlzLm9wY29kZSgnYXBwZW5kRXNjYXBlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wY29kZSgnYXBwZW5kJyk7XG4gICAgfVxuICB9LFxuXG4gIGFtYmlndW91c1NleHByOiBmdW5jdGlvbihzZXhwciwgcHJvZ3JhbSwgaW52ZXJzZSkge1xuICAgIHZhciBpZCA9IHNleHByLmlkLFxuICAgICAgICBuYW1lID0gaWQucGFydHNbMF0sXG4gICAgICAgIGlzQmxvY2sgPSBwcm9ncmFtICE9IG51bGwgfHwgaW52ZXJzZSAhPSBudWxsO1xuXG4gICAgdGhpcy5vcGNvZGUoJ2dldENvbnRleHQnLCBpZC5kZXB0aCk7XG5cbiAgICB0aGlzLm9wY29kZSgncHVzaFByb2dyYW0nLCBwcm9ncmFtKTtcbiAgICB0aGlzLm9wY29kZSgncHVzaFByb2dyYW0nLCBpbnZlcnNlKTtcblxuICAgIHRoaXMub3Bjb2RlKCdpbnZva2VBbWJpZ3VvdXMnLCBuYW1lLCBpc0Jsb2NrKTtcbiAgfSxcblxuICBzaW1wbGVTZXhwcjogZnVuY3Rpb24oc2V4cHIpIHtcbiAgICB2YXIgaWQgPSBzZXhwci5pZDtcblxuICAgIGlmIChpZC50eXBlID09PSAnREFUQScpIHtcbiAgICAgIHRoaXMuREFUQShpZCk7XG4gICAgfSBlbHNlIGlmIChpZC5wYXJ0cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuSUQoaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTaW1wbGlmaWVkIElEIGZvciBgdGhpc2BcbiAgICAgIHRoaXMuYWRkRGVwdGgoaWQuZGVwdGgpO1xuICAgICAgdGhpcy5vcGNvZGUoJ2dldENvbnRleHQnLCBpZC5kZXB0aCk7XG4gICAgICB0aGlzLm9wY29kZSgncHVzaENvbnRleHQnKTtcbiAgICB9XG5cbiAgICB0aGlzLm9wY29kZSgncmVzb2x2ZVBvc3NpYmxlTGFtYmRhJyk7XG4gIH0sXG5cbiAgaGVscGVyU2V4cHI6IGZ1bmN0aW9uKHNleHByLCBwcm9ncmFtLCBpbnZlcnNlKSB7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMuc2V0dXBGdWxsTXVzdGFjaGVQYXJhbXMoc2V4cHIsIHByb2dyYW0sIGludmVyc2UpLFxuICAgICAgICBuYW1lID0gc2V4cHIuaWQucGFydHNbMF07XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmtub3duSGVscGVyc1tuYW1lXSkge1xuICAgICAgdGhpcy5vcGNvZGUoJ2ludm9rZUtub3duSGVscGVyJywgcGFyYW1zLmxlbmd0aCwgbmFtZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMua25vd25IZWxwZXJzT25seSkge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihcIllvdSBzcGVjaWZpZWQga25vd25IZWxwZXJzT25seSwgYnV0IHVzZWQgdGhlIHVua25vd24gaGVscGVyIFwiICsgbmFtZSwgc2V4cHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wY29kZSgnaW52b2tlSGVscGVyJywgcGFyYW1zLmxlbmd0aCwgbmFtZSwgc2V4cHIuaXNSb290KTtcbiAgICB9XG4gIH0sXG5cbiAgc2V4cHI6IGZ1bmN0aW9uKHNleHByKSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLmNsYXNzaWZ5U2V4cHIoc2V4cHIpO1xuXG4gICAgaWYgKHR5cGUgPT09IFwic2ltcGxlXCIpIHtcbiAgICAgIHRoaXMuc2ltcGxlU2V4cHIoc2V4cHIpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJoZWxwZXJcIikge1xuICAgICAgdGhpcy5oZWxwZXJTZXhwcihzZXhwcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYW1iaWd1b3VzU2V4cHIoc2V4cHIpO1xuICAgIH1cbiAgfSxcblxuICBJRDogZnVuY3Rpb24oaWQpIHtcbiAgICB0aGlzLmFkZERlcHRoKGlkLmRlcHRoKTtcbiAgICB0aGlzLm9wY29kZSgnZ2V0Q29udGV4dCcsIGlkLmRlcHRoKTtcblxuICAgIHZhciBuYW1lID0gaWQucGFydHNbMF07XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aGlzLm9wY29kZSgncHVzaENvbnRleHQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcGNvZGUoJ2xvb2t1cE9uQ29udGV4dCcsIGlkLnBhcnRzWzBdKTtcbiAgICB9XG5cbiAgICBmb3IodmFyIGk9MSwgbD1pZC5wYXJ0cy5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICB0aGlzLm9wY29kZSgnbG9va3VwJywgaWQucGFydHNbaV0pO1xuICAgIH1cbiAgfSxcblxuICBEQVRBOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgdGhpcy5vcHRpb25zLmRhdGEgPSB0cnVlO1xuICAgIGlmIChkYXRhLmlkLmlzU2NvcGVkIHx8IGRhdGEuaWQuZGVwdGgpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1Njb3BlZCBkYXRhIHJlZmVyZW5jZXMgYXJlIG5vdCBzdXBwb3J0ZWQ6ICcgKyBkYXRhLm9yaWdpbmFsLCBkYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLm9wY29kZSgnbG9va3VwRGF0YScpO1xuICAgIHZhciBwYXJ0cyA9IGRhdGEuaWQucGFydHM7XG4gICAgZm9yKHZhciBpPTAsIGw9cGFydHMubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgdGhpcy5vcGNvZGUoJ2xvb2t1cCcsIHBhcnRzW2ldKTtcbiAgICB9XG4gIH0sXG5cbiAgU1RSSU5HOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB0aGlzLm9wY29kZSgncHVzaFN0cmluZycsIHN0cmluZy5zdHJpbmcpO1xuICB9LFxuXG4gIElOVEVHRVI6IGZ1bmN0aW9uKGludGVnZXIpIHtcbiAgICB0aGlzLm9wY29kZSgncHVzaExpdGVyYWwnLCBpbnRlZ2VyLmludGVnZXIpO1xuICB9LFxuXG4gIEJPT0xFQU46IGZ1bmN0aW9uKGJvb2wpIHtcbiAgICB0aGlzLm9wY29kZSgncHVzaExpdGVyYWwnLCBib29sLmJvb2wpO1xuICB9LFxuXG4gIGNvbW1lbnQ6IGZ1bmN0aW9uKCkge30sXG5cbiAgLy8gSEVMUEVSU1xuICBvcGNvZGU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB0aGlzLm9wY29kZXMucHVzaCh7IG9wY29kZTogbmFtZSwgYXJnczogW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpIH0pO1xuICB9LFxuXG4gIGRlY2xhcmU6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5vcGNvZGVzLnB1c2goeyBvcGNvZGU6ICdERUNMQVJFJywgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xuICB9LFxuXG4gIGFkZERlcHRoOiBmdW5jdGlvbihkZXB0aCkge1xuICAgIGlmKGRlcHRoID09PSAwKSB7IHJldHVybjsgfVxuXG4gICAgaWYoIXRoaXMuZGVwdGhzW2RlcHRoXSkge1xuICAgICAgdGhpcy5kZXB0aHNbZGVwdGhdID0gdHJ1ZTtcbiAgICAgIHRoaXMuZGVwdGhzLmxpc3QucHVzaChkZXB0aCk7XG4gICAgfVxuICB9LFxuXG4gIGNsYXNzaWZ5U2V4cHI6IGZ1bmN0aW9uKHNleHByKSB7XG4gICAgdmFyIGlzSGVscGVyICAgPSBzZXhwci5pc0hlbHBlcjtcbiAgICB2YXIgaXNFbGlnaWJsZSA9IHNleHByLmVsaWdpYmxlSGVscGVyO1xuICAgIHZhciBvcHRpb25zICAgID0gdGhpcy5vcHRpb25zO1xuXG4gICAgLy8gaWYgYW1iaWd1b3VzLCB3ZSBjYW4gcG9zc2libHkgcmVzb2x2ZSB0aGUgYW1iaWd1aXR5IG5vd1xuICAgIGlmIChpc0VsaWdpYmxlICYmICFpc0hlbHBlcikge1xuICAgICAgdmFyIG5hbWUgPSBzZXhwci5pZC5wYXJ0c1swXTtcblxuICAgICAgaWYgKG9wdGlvbnMua25vd25IZWxwZXJzW25hbWVdKSB7XG4gICAgICAgIGlzSGVscGVyID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5rbm93bkhlbHBlcnNPbmx5KSB7XG4gICAgICAgIGlzRWxpZ2libGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNIZWxwZXIpIHsgcmV0dXJuIFwiaGVscGVyXCI7IH1cbiAgICBlbHNlIGlmIChpc0VsaWdpYmxlKSB7IHJldHVybiBcImFtYmlndW91c1wiOyB9XG4gICAgZWxzZSB7IHJldHVybiBcInNpbXBsZVwiOyB9XG4gIH0sXG5cbiAgcHVzaFBhcmFtczogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgdmFyIGkgPSBwYXJhbXMubGVuZ3RoLCBwYXJhbTtcblxuICAgIHdoaWxlKGktLSkge1xuICAgICAgcGFyYW0gPSBwYXJhbXNbaV07XG5cbiAgICAgIGlmKHRoaXMub3B0aW9ucy5zdHJpbmdQYXJhbXMpIHtcbiAgICAgICAgaWYocGFyYW0uZGVwdGgpIHtcbiAgICAgICAgICB0aGlzLmFkZERlcHRoKHBhcmFtLmRlcHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3Bjb2RlKCdnZXRDb250ZXh0JywgcGFyYW0uZGVwdGggfHwgMCk7XG4gICAgICAgIHRoaXMub3Bjb2RlKCdwdXNoU3RyaW5nUGFyYW0nLCBwYXJhbS5zdHJpbmdNb2RlVmFsdWUsIHBhcmFtLnR5cGUpO1xuXG4gICAgICAgIGlmIChwYXJhbS50eXBlID09PSAnc2V4cHInKSB7XG4gICAgICAgICAgLy8gU3ViZXhwcmVzc2lvbnMgZ2V0IGV2YWx1YXRlZCBhbmQgcGFzc2VkIGluXG4gICAgICAgICAgLy8gaW4gc3RyaW5nIHBhcmFtcyBtb2RlLlxuICAgICAgICAgIHRoaXMuc2V4cHIocGFyYW0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3BhcmFtLnR5cGVdKHBhcmFtKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgc2V0dXBGdWxsTXVzdGFjaGVQYXJhbXM6IGZ1bmN0aW9uKHNleHByLCBwcm9ncmFtLCBpbnZlcnNlKSB7XG4gICAgdmFyIHBhcmFtcyA9IHNleHByLnBhcmFtcztcbiAgICB0aGlzLnB1c2hQYXJhbXMocGFyYW1zKTtcblxuICAgIHRoaXMub3Bjb2RlKCdwdXNoUHJvZ3JhbScsIHByb2dyYW0pO1xuICAgIHRoaXMub3Bjb2RlKCdwdXNoUHJvZ3JhbScsIGludmVyc2UpO1xuXG4gICAgaWYgKHNleHByLmhhc2gpIHtcbiAgICAgIHRoaXMuaGFzaChzZXhwci5oYXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcGNvZGUoJ2VtcHR5SGFzaCcpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHByZWNvbXBpbGUoaW5wdXQsIG9wdGlvbnMsIGVudikge1xuICBpZiAoaW5wdXQgPT0gbnVsbCB8fCAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJyAmJiBpbnB1dC5jb25zdHJ1Y3RvciAhPT0gZW52LkFTVC5Qcm9ncmFtTm9kZSkpIHtcbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFwiWW91IG11c3QgcGFzcyBhIHN0cmluZyBvciBIYW5kbGViYXJzIEFTVCB0byBIYW5kbGViYXJzLnByZWNvbXBpbGUuIFlvdSBwYXNzZWQgXCIgKyBpbnB1dCk7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCEoJ2RhdGEnIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5kYXRhID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBhc3QgPSBlbnYucGFyc2UoaW5wdXQpO1xuICB2YXIgZW52aXJvbm1lbnQgPSBuZXcgZW52LkNvbXBpbGVyKCkuY29tcGlsZShhc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gbmV3IGVudi5KYXZhU2NyaXB0Q29tcGlsZXIoKS5jb21waWxlKGVudmlyb25tZW50LCBvcHRpb25zKTtcbn1cblxuZXhwb3J0cy5wcmVjb21waWxlID0gcHJlY29tcGlsZTtmdW5jdGlvbiBjb21waWxlKGlucHV0LCBvcHRpb25zLCBlbnYpIHtcbiAgaWYgKGlucHV0ID09IG51bGwgfHwgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycgJiYgaW5wdXQuY29uc3RydWN0b3IgIT09IGVudi5BU1QuUHJvZ3JhbU5vZGUpKSB7XG4gICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihcIllvdSBtdXN0IHBhc3MgYSBzdHJpbmcgb3IgSGFuZGxlYmFycyBBU1QgdG8gSGFuZGxlYmFycy5jb21waWxlLiBZb3UgcGFzc2VkIFwiICsgaW5wdXQpO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKCEoJ2RhdGEnIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5kYXRhID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBjb21waWxlZDtcblxuICBmdW5jdGlvbiBjb21waWxlSW5wdXQoKSB7XG4gICAgdmFyIGFzdCA9IGVudi5wYXJzZShpbnB1dCk7XG4gICAgdmFyIGVudmlyb25tZW50ID0gbmV3IGVudi5Db21waWxlcigpLmNvbXBpbGUoYXN0LCBvcHRpb25zKTtcbiAgICB2YXIgdGVtcGxhdGVTcGVjID0gbmV3IGVudi5KYXZhU2NyaXB0Q29tcGlsZXIoKS5jb21waWxlKGVudmlyb25tZW50LCBvcHRpb25zLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIHJldHVybiBlbnYudGVtcGxhdGUodGVtcGxhdGVTcGVjKTtcbiAgfVxuXG4gIC8vIFRlbXBsYXRlIGlzIG9ubHkgY29tcGlsZWQgb24gZmlyc3QgdXNlIGFuZCBjYWNoZWQgYWZ0ZXIgdGhhdCBwb2ludC5cbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWNvbXBpbGVkKSB7XG4gICAgICBjb21waWxlZCA9IGNvbXBpbGVJbnB1dCgpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcGlsZWQuY2FsbCh0aGlzLCBjb250ZXh0LCBvcHRpb25zKTtcbiAgfTtcbn1cblxuZXhwb3J0cy5jb21waWxlID0gY29tcGlsZTsiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBDT01QSUxFUl9SRVZJU0lPTiA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpLkNPTVBJTEVSX1JFVklTSU9OO1xudmFyIFJFVklTSU9OX0NIQU5HRVMgPSByZXF1aXJlKFwiLi4vYmFzZVwiKS5SRVZJU0lPTl9DSEFOR0VTO1xudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi9iYXNlXCIpLmxvZztcbnZhciBFeGNlcHRpb24gPSByZXF1aXJlKFwiLi4vZXhjZXB0aW9uXCIpW1wiZGVmYXVsdFwiXTtcblxuZnVuY3Rpb24gTGl0ZXJhbCh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEphdmFTY3JpcHRDb21waWxlcigpIHt9XG5cbkphdmFTY3JpcHRDb21waWxlci5wcm90b3R5cGUgPSB7XG4gIC8vIFBVQkxJQyBBUEk6IFlvdSBjYW4gb3ZlcnJpZGUgdGhlc2UgbWV0aG9kcyBpbiBhIHN1YmNsYXNzIHRvIHByb3ZpZGVcbiAgLy8gYWx0ZXJuYXRpdmUgY29tcGlsZWQgZm9ybXMgZm9yIG5hbWUgbG9va3VwIGFuZCBidWZmZXJpbmcgc2VtYW50aWNzXG4gIG5hbWVMb29rdXA6IGZ1bmN0aW9uKHBhcmVudCwgbmFtZSAvKiAsIHR5cGUqLykge1xuICAgIHZhciB3cmFwLFxuICAgICAgICByZXQ7XG4gICAgaWYgKHBhcmVudC5pbmRleE9mKCdkZXB0aCcpID09PSAwKSB7XG4gICAgICB3cmFwID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoL15bMC05XSskLy50ZXN0KG5hbWUpKSB7XG4gICAgICByZXQgPSBwYXJlbnQgKyBcIltcIiArIG5hbWUgKyBcIl1cIjtcbiAgICB9IGVsc2UgaWYgKEphdmFTY3JpcHRDb21waWxlci5pc1ZhbGlkSmF2YVNjcmlwdFZhcmlhYmxlTmFtZShuYW1lKSkge1xuICAgICAgcmV0ID0gcGFyZW50ICsgXCIuXCIgKyBuYW1lO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldCA9IHBhcmVudCArIFwiWydcIiArIG5hbWUgKyBcIiddXCI7XG4gICAgfVxuXG4gICAgaWYgKHdyYXApIHtcbiAgICAgIHJldHVybiAnKCcgKyBwYXJlbnQgKyAnICYmICcgKyByZXQgKyAnKSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBpbGVySW5mbzogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJldmlzaW9uID0gQ09NUElMRVJfUkVWSVNJT04sXG4gICAgICAgIHZlcnNpb25zID0gUkVWSVNJT05fQ0hBTkdFU1tyZXZpc2lvbl07XG4gICAgcmV0dXJuIFwidGhpcy5jb21waWxlckluZm8gPSBbXCIrcmV2aXNpb24rXCIsJ1wiK3ZlcnNpb25zK1wiJ107XFxuXCI7XG4gIH0sXG5cbiAgYXBwZW5kVG9CdWZmZXI6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIGlmICh0aGlzLmVudmlyb25tZW50LmlzU2ltcGxlKSB7XG4gICAgICByZXR1cm4gXCJyZXR1cm4gXCIgKyBzdHJpbmcgKyBcIjtcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXBwZW5kVG9CdWZmZXI6IHRydWUsXG4gICAgICAgIGNvbnRlbnQ6IHN0cmluZyxcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJidWZmZXIgKz0gXCIgKyBzdHJpbmcgKyBcIjtcIjsgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUJ1ZmZlcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVvdGVkU3RyaW5nKFwiXCIpO1xuICB9LFxuXG4gIG5hbWVzcGFjZTogXCJIYW5kbGViYXJzXCIsXG4gIC8vIEVORCBQVUJMSUMgQVBJXG5cbiAgY29tcGlsZTogZnVuY3Rpb24oZW52aXJvbm1lbnQsIG9wdGlvbnMsIGNvbnRleHQsIGFzT2JqZWN0KSB7XG4gICAgdGhpcy5lbnZpcm9ubWVudCA9IGVudmlyb25tZW50O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBsb2coJ2RlYnVnJywgdGhpcy5lbnZpcm9ubWVudC5kaXNhc3NlbWJsZSgpICsgXCJcXG5cXG5cIik7XG5cbiAgICB0aGlzLm5hbWUgPSB0aGlzLmVudmlyb25tZW50Lm5hbWU7XG4gICAgdGhpcy5pc0NoaWxkID0gISFjb250ZXh0O1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQgfHwge1xuICAgICAgcHJvZ3JhbXM6IFtdLFxuICAgICAgZW52aXJvbm1lbnRzOiBbXSxcbiAgICAgIGFsaWFzZXM6IHsgfVxuICAgIH07XG5cbiAgICB0aGlzLnByZWFtYmxlKCk7XG5cbiAgICB0aGlzLnN0YWNrU2xvdCA9IDA7XG4gICAgdGhpcy5zdGFja1ZhcnMgPSBbXTtcbiAgICB0aGlzLnJlZ2lzdGVycyA9IHsgbGlzdDogW10gfTtcbiAgICB0aGlzLmhhc2hlcyA9IFtdO1xuICAgIHRoaXMuY29tcGlsZVN0YWNrID0gW107XG4gICAgdGhpcy5pbmxpbmVTdGFjayA9IFtdO1xuXG4gICAgdGhpcy5jb21waWxlQ2hpbGRyZW4oZW52aXJvbm1lbnQsIG9wdGlvbnMpO1xuXG4gICAgdmFyIG9wY29kZXMgPSBlbnZpcm9ubWVudC5vcGNvZGVzLCBvcGNvZGU7XG5cbiAgICB0aGlzLmkgPSAwO1xuXG4gICAgZm9yKHZhciBsPW9wY29kZXMubGVuZ3RoOyB0aGlzLmk8bDsgdGhpcy5pKyspIHtcbiAgICAgIG9wY29kZSA9IG9wY29kZXNbdGhpcy5pXTtcblxuICAgICAgaWYob3Bjb2RlLm9wY29kZSA9PT0gJ0RFQ0xBUkUnKSB7XG4gICAgICAgIHRoaXNbb3Bjb2RlLm5hbWVdID0gb3Bjb2RlLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1tvcGNvZGUub3Bjb2RlXS5hcHBseSh0aGlzLCBvcGNvZGUuYXJncyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlc2V0IHRoZSBzdHJpcE5leHQgZmxhZyBpZiBpdCB3YXMgbm90IHNldCBieSB0aGlzIG9wZXJhdGlvbi5cbiAgICAgIGlmIChvcGNvZGUub3Bjb2RlICE9PSB0aGlzLnN0cmlwTmV4dCkge1xuICAgICAgICB0aGlzLnN0cmlwTmV4dCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZsdXNoIGFueSB0cmFpbGluZyBjb250ZW50IHRoYXQgbWlnaHQgYmUgcGVuZGluZy5cbiAgICB0aGlzLnB1c2hTb3VyY2UoJycpO1xuXG4gICAgaWYgKHRoaXMuc3RhY2tTbG90IHx8IHRoaXMuaW5saW5lU3RhY2subGVuZ3RoIHx8IHRoaXMuY29tcGlsZVN0YWNrLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignQ29tcGlsZSBjb21wbGV0ZWQgd2l0aCBjb250ZW50IGxlZnQgb24gc3RhY2snKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jcmVhdGVGdW5jdGlvbkNvbnRleHQoYXNPYmplY3QpO1xuICB9LFxuXG4gIHByZWFtYmxlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gW107XG5cbiAgICBpZiAoIXRoaXMuaXNDaGlsZCkge1xuICAgICAgdmFyIG5hbWVzcGFjZSA9IHRoaXMubmFtZXNwYWNlO1xuXG4gICAgICB2YXIgY29waWVzID0gXCJoZWxwZXJzID0gdGhpcy5tZXJnZShoZWxwZXJzLCBcIiArIG5hbWVzcGFjZSArIFwiLmhlbHBlcnMpO1wiO1xuICAgICAgaWYgKHRoaXMuZW52aXJvbm1lbnQudXNlUGFydGlhbCkgeyBjb3BpZXMgPSBjb3BpZXMgKyBcIiBwYXJ0aWFscyA9IHRoaXMubWVyZ2UocGFydGlhbHMsIFwiICsgbmFtZXNwYWNlICsgXCIucGFydGlhbHMpO1wiOyB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRhdGEpIHsgY29waWVzID0gY29waWVzICsgXCIgZGF0YSA9IGRhdGEgfHwge307XCI7IH1cbiAgICAgIG91dC5wdXNoKGNvcGllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5wdXNoKCcnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZW52aXJvbm1lbnQuaXNTaW1wbGUpIHtcbiAgICAgIG91dC5wdXNoKFwiLCBidWZmZXIgPSBcIiArIHRoaXMuaW5pdGlhbGl6ZUJ1ZmZlcigpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0LnB1c2goXCJcIik7XG4gICAgfVxuXG4gICAgLy8gdHJhY2sgdGhlIGxhc3QgY29udGV4dCBwdXNoZWQgaW50byBwbGFjZSB0byBhbGxvdyBza2lwcGluZyB0aGVcbiAgICAvLyBnZXRDb250ZXh0IG9wY29kZSB3aGVuIGl0IHdvdWxkIGJlIGEgbm9vcFxuICAgIHRoaXMubGFzdENvbnRleHQgPSAwO1xuICAgIHRoaXMuc291cmNlID0gb3V0O1xuICB9LFxuXG4gIGNyZWF0ZUZ1bmN0aW9uQ29udGV4dDogZnVuY3Rpb24oYXNPYmplY3QpIHtcbiAgICB2YXIgbG9jYWxzID0gdGhpcy5zdGFja1ZhcnMuY29uY2F0KHRoaXMucmVnaXN0ZXJzLmxpc3QpO1xuXG4gICAgaWYobG9jYWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc291cmNlWzFdID0gdGhpcy5zb3VyY2VbMV0gKyBcIiwgXCIgKyBsb2NhbHMuam9pbihcIiwgXCIpO1xuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIG1pbmltaXplciBhbGlhcyBtYXBwaW5nc1xuICAgIGlmICghdGhpcy5pc0NoaWxkKSB7XG4gICAgICBmb3IgKHZhciBhbGlhcyBpbiB0aGlzLmNvbnRleHQuYWxpYXNlcykge1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmFsaWFzZXMuaGFzT3duUHJvcGVydHkoYWxpYXMpKSB7XG4gICAgICAgICAgdGhpcy5zb3VyY2VbMV0gPSB0aGlzLnNvdXJjZVsxXSArICcsICcgKyBhbGlhcyArICc9JyArIHRoaXMuY29udGV4dC5hbGlhc2VzW2FsaWFzXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnNvdXJjZVsxXSkge1xuICAgICAgdGhpcy5zb3VyY2VbMV0gPSBcInZhciBcIiArIHRoaXMuc291cmNlWzFdLnN1YnN0cmluZygyKSArIFwiO1wiO1xuICAgIH1cblxuICAgIC8vIE1lcmdlIGNoaWxkcmVuXG4gICAgaWYgKCF0aGlzLmlzQ2hpbGQpIHtcbiAgICAgIHRoaXMuc291cmNlWzFdICs9ICdcXG4nICsgdGhpcy5jb250ZXh0LnByb2dyYW1zLmpvaW4oJ1xcbicpICsgJ1xcbic7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmVudmlyb25tZW50LmlzU2ltcGxlKSB7XG4gICAgICB0aGlzLnB1c2hTb3VyY2UoXCJyZXR1cm4gYnVmZmVyO1wiKTtcbiAgICB9XG5cbiAgICB2YXIgcGFyYW1zID0gdGhpcy5pc0NoaWxkID8gW1wiZGVwdGgwXCIsIFwiZGF0YVwiXSA6IFtcIkhhbmRsZWJhcnNcIiwgXCJkZXB0aDBcIiwgXCJoZWxwZXJzXCIsIFwicGFydGlhbHNcIiwgXCJkYXRhXCJdO1xuXG4gICAgZm9yKHZhciBpPTAsIGw9dGhpcy5lbnZpcm9ubWVudC5kZXB0aHMubGlzdC5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICBwYXJhbXMucHVzaChcImRlcHRoXCIgKyB0aGlzLmVudmlyb25tZW50LmRlcHRocy5saXN0W2ldKTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGEgc2Vjb25kIHBhc3Mgb3ZlciB0aGUgb3V0cHV0IHRvIG1lcmdlIGNvbnRlbnQgd2hlbiBwb3NzaWJsZVxuICAgIHZhciBzb3VyY2UgPSB0aGlzLm1lcmdlU291cmNlKCk7XG5cbiAgICBpZiAoIXRoaXMuaXNDaGlsZCkge1xuICAgICAgc291cmNlID0gdGhpcy5jb21waWxlckluZm8oKStzb3VyY2U7XG4gICAgfVxuXG4gICAgaWYgKGFzT2JqZWN0KSB7XG4gICAgICBwYXJhbXMucHVzaChzb3VyY2UpO1xuXG4gICAgICByZXR1cm4gRnVuY3Rpb24uYXBwbHkodGhpcywgcGFyYW1zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZ1bmN0aW9uU291cmNlID0gJ2Z1bmN0aW9uICcgKyAodGhpcy5uYW1lIHx8ICcnKSArICcoJyArIHBhcmFtcy5qb2luKCcsJykgKyAnKSB7XFxuICAnICsgc291cmNlICsgJ30nO1xuICAgICAgbG9nKCdkZWJ1ZycsIGZ1bmN0aW9uU291cmNlICsgXCJcXG5cXG5cIik7XG4gICAgICByZXR1cm4gZnVuY3Rpb25Tb3VyY2U7XG4gICAgfVxuICB9LFxuICBtZXJnZVNvdXJjZTogZnVuY3Rpb24oKSB7XG4gICAgLy8gV0FSTjogV2UgYXJlIG5vdCBoYW5kbGluZyB0aGUgY2FzZSB3aGVyZSBidWZmZXIgaXMgc3RpbGwgcG9wdWxhdGVkIGFzIHRoZSBzb3VyY2Ugc2hvdWxkXG4gICAgLy8gbm90IGhhdmUgYnVmZmVyIGFwcGVuZCBvcGVyYXRpb25zIGFzIHRoZWlyIGZpbmFsIGFjdGlvbi5cbiAgICB2YXIgc291cmNlID0gJycsXG4gICAgICAgIGJ1ZmZlcjtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5zb3VyY2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBsaW5lID0gdGhpcy5zb3VyY2VbaV07XG4gICAgICBpZiAobGluZS5hcHBlbmRUb0J1ZmZlcikge1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgYnVmZmVyID0gYnVmZmVyICsgJ1xcbiAgICArICcgKyBsaW5lLmNvbnRlbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmZmVyID0gbGluZS5jb250ZW50O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgc291cmNlICs9ICdidWZmZXIgKz0gJyArIGJ1ZmZlciArICc7XFxuICAnO1xuICAgICAgICAgIGJ1ZmZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgKz0gbGluZSArICdcXG4gICc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2U7XG4gIH0sXG5cbiAgLy8gW2Jsb2NrVmFsdWVdXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IGhhc2gsIGludmVyc2UsIHByb2dyYW0sIHZhbHVlXG4gIC8vIE9uIHN0YWNrLCBhZnRlcjogcmV0dXJuIHZhbHVlIG9mIGJsb2NrSGVscGVyTWlzc2luZ1xuICAvL1xuICAvLyBUaGUgcHVycG9zZSBvZiB0aGlzIG9wY29kZSBpcyB0byB0YWtlIGEgYmxvY2sgb2YgdGhlIGZvcm1cbiAgLy8gYHt7I2Zvb319Li4ue3svZm9vfX1gLCByZXNvbHZlIHRoZSB2YWx1ZSBvZiBgZm9vYCwgYW5kXG4gIC8vIHJlcGxhY2UgaXQgb24gdGhlIHN0YWNrIHdpdGggdGhlIHJlc3VsdCBvZiBwcm9wZXJseVxuICAvLyBpbnZva2luZyBibG9ja0hlbHBlck1pc3NpbmcuXG4gIGJsb2NrVmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29udGV4dC5hbGlhc2VzLmJsb2NrSGVscGVyTWlzc2luZyA9ICdoZWxwZXJzLmJsb2NrSGVscGVyTWlzc2luZyc7XG5cbiAgICB2YXIgcGFyYW1zID0gW1wiZGVwdGgwXCJdO1xuICAgIHRoaXMuc2V0dXBQYXJhbXMoMCwgcGFyYW1zKTtcblxuICAgIHRoaXMucmVwbGFjZVN0YWNrKGZ1bmN0aW9uKGN1cnJlbnQpIHtcbiAgICAgIHBhcmFtcy5zcGxpY2UoMSwgMCwgY3VycmVudCk7XG4gICAgICByZXR1cm4gXCJibG9ja0hlbHBlck1pc3NpbmcuY2FsbChcIiArIHBhcmFtcy5qb2luKFwiLCBcIikgKyBcIilcIjtcbiAgICB9KTtcbiAgfSxcblxuICAvLyBbYW1iaWd1b3VzQmxvY2tWYWx1ZV1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogaGFzaCwgaW52ZXJzZSwgcHJvZ3JhbSwgdmFsdWVcbiAgLy8gQ29tcGlsZXIgdmFsdWUsIGJlZm9yZTogbGFzdEhlbHBlcj12YWx1ZSBvZiBsYXN0IGZvdW5kIGhlbHBlciwgaWYgYW55XG4gIC8vIE9uIHN0YWNrLCBhZnRlciwgaWYgbm8gbGFzdEhlbHBlcjogc2FtZSBhcyBbYmxvY2tWYWx1ZV1cbiAgLy8gT24gc3RhY2ssIGFmdGVyLCBpZiBsYXN0SGVscGVyOiB2YWx1ZVxuICBhbWJpZ3VvdXNCbG9ja1ZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbnRleHQuYWxpYXNlcy5ibG9ja0hlbHBlck1pc3NpbmcgPSAnaGVscGVycy5ibG9ja0hlbHBlck1pc3NpbmcnO1xuXG4gICAgdmFyIHBhcmFtcyA9IFtcImRlcHRoMFwiXTtcbiAgICB0aGlzLnNldHVwUGFyYW1zKDAsIHBhcmFtcyk7XG5cbiAgICB2YXIgY3VycmVudCA9IHRoaXMudG9wU3RhY2soKTtcbiAgICBwYXJhbXMuc3BsaWNlKDEsIDAsIGN1cnJlbnQpO1xuXG4gICAgdGhpcy5wdXNoU291cmNlKFwiaWYgKCFcIiArIHRoaXMubGFzdEhlbHBlciArIFwiKSB7IFwiICsgY3VycmVudCArIFwiID0gYmxvY2tIZWxwZXJNaXNzaW5nLmNhbGwoXCIgKyBwYXJhbXMuam9pbihcIiwgXCIpICsgXCIpOyB9XCIpO1xuICB9LFxuXG4gIC8vIFthcHBlbmRDb250ZW50XVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiAuLi5cbiAgLy9cbiAgLy8gQXBwZW5kcyB0aGUgc3RyaW5nIHZhbHVlIG9mIGBjb250ZW50YCB0byB0aGUgY3VycmVudCBidWZmZXJcbiAgYXBwZW5kQ29udGVudDogZnVuY3Rpb24oY29udGVudCkge1xuICAgIGlmICh0aGlzLnBlbmRpbmdDb250ZW50KSB7XG4gICAgICBjb250ZW50ID0gdGhpcy5wZW5kaW5nQ29udGVudCArIGNvbnRlbnQ7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0cmlwTmV4dCkge1xuICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvXlxccysvLCAnJyk7XG4gICAgfVxuXG4gICAgdGhpcy5wZW5kaW5nQ29udGVudCA9IGNvbnRlbnQ7XG4gIH0sXG5cbiAgLy8gW3N0cmlwXVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiAuLi5cbiAgLy9cbiAgLy8gUmVtb3ZlcyBhbnkgdHJhaWxpbmcgd2hpdGVzcGFjZSBmcm9tIHRoZSBwcmlvciBjb250ZW50IG5vZGUgYW5kIGZsYWdzXG4gIC8vIHRoZSBuZXh0IG9wZXJhdGlvbiBmb3Igc3RyaXBwaW5nIGlmIGl0IGlzIGEgY29udGVudCBub2RlLlxuICBzdHJpcDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucGVuZGluZ0NvbnRlbnQpIHtcbiAgICAgIHRoaXMucGVuZGluZ0NvbnRlbnQgPSB0aGlzLnBlbmRpbmdDb250ZW50LnJlcGxhY2UoL1xccyskLywgJycpO1xuICAgIH1cbiAgICB0aGlzLnN0cmlwTmV4dCA9ICdzdHJpcCc7XG4gIH0sXG5cbiAgLy8gW2FwcGVuZF1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogdmFsdWUsIC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IC4uLlxuICAvL1xuICAvLyBDb2VyY2VzIGB2YWx1ZWAgdG8gYSBTdHJpbmcgYW5kIGFwcGVuZHMgaXQgdG8gdGhlIGN1cnJlbnQgYnVmZmVyLlxuICAvL1xuICAvLyBJZiBgdmFsdWVgIGlzIHRydXRoeSwgb3IgMCwgaXQgaXMgY29lcmNlZCBpbnRvIGEgc3RyaW5nIGFuZCBhcHBlbmRlZFxuICAvLyBPdGhlcndpc2UsIHRoZSBlbXB0eSBzdHJpbmcgaXMgYXBwZW5kZWRcbiAgYXBwZW5kOiBmdW5jdGlvbigpIHtcbiAgICAvLyBGb3JjZSBhbnl0aGluZyB0aGF0IGlzIGlubGluZWQgb250byB0aGUgc3RhY2sgc28gd2UgZG9uJ3QgaGF2ZSBkdXBsaWNhdGlvblxuICAgIC8vIHdoZW4gd2UgZXhhbWluZSBsb2NhbFxuICAgIHRoaXMuZmx1c2hJbmxpbmUoKTtcbiAgICB2YXIgbG9jYWwgPSB0aGlzLnBvcFN0YWNrKCk7XG4gICAgdGhpcy5wdXNoU291cmNlKFwiaWYoXCIgKyBsb2NhbCArIFwiIHx8IFwiICsgbG9jYWwgKyBcIiA9PT0gMCkgeyBcIiArIHRoaXMuYXBwZW5kVG9CdWZmZXIobG9jYWwpICsgXCIgfVwiKTtcbiAgICBpZiAodGhpcy5lbnZpcm9ubWVudC5pc1NpbXBsZSkge1xuICAgICAgdGhpcy5wdXNoU291cmNlKFwiZWxzZSB7IFwiICsgdGhpcy5hcHBlbmRUb0J1ZmZlcihcIicnXCIpICsgXCIgfVwiKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gW2FwcGVuZEVzY2FwZWRdXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IHZhbHVlLCAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiAuLi5cbiAgLy9cbiAgLy8gRXNjYXBlIGB2YWx1ZWAgYW5kIGFwcGVuZCBpdCB0byB0aGUgYnVmZmVyXG4gIGFwcGVuZEVzY2FwZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29udGV4dC5hbGlhc2VzLmVzY2FwZUV4cHJlc3Npb24gPSAndGhpcy5lc2NhcGVFeHByZXNzaW9uJztcblxuICAgIHRoaXMucHVzaFNvdXJjZSh0aGlzLmFwcGVuZFRvQnVmZmVyKFwiZXNjYXBlRXhwcmVzc2lvbihcIiArIHRoaXMucG9wU3RhY2soKSArIFwiKVwiKSk7XG4gIH0sXG5cbiAgLy8gW2dldENvbnRleHRdXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IC4uLlxuICAvLyBDb21waWxlciB2YWx1ZSwgYWZ0ZXI6IGxhc3RDb250ZXh0PWRlcHRoXG4gIC8vXG4gIC8vIFNldCB0aGUgdmFsdWUgb2YgdGhlIGBsYXN0Q29udGV4dGAgY29tcGlsZXIgdmFsdWUgdG8gdGhlIGRlcHRoXG4gIGdldENvbnRleHQ6IGZ1bmN0aW9uKGRlcHRoKSB7XG4gICAgaWYodGhpcy5sYXN0Q29udGV4dCAhPT0gZGVwdGgpIHtcbiAgICAgIHRoaXMubGFzdENvbnRleHQgPSBkZXB0aDtcbiAgICB9XG4gIH0sXG5cbiAgLy8gW2xvb2t1cE9uQ29udGV4dF1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogLi4uXG4gIC8vIE9uIHN0YWNrLCBhZnRlcjogY3VycmVudENvbnRleHRbbmFtZV0sIC4uLlxuICAvL1xuICAvLyBMb29rcyB1cCB0aGUgdmFsdWUgb2YgYG5hbWVgIG9uIHRoZSBjdXJyZW50IGNvbnRleHQgYW5kIHB1c2hlc1xuICAvLyBpdCBvbnRvIHRoZSBzdGFjay5cbiAgbG9va3VwT25Db250ZXh0OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdGhpcy5wdXNoKHRoaXMubmFtZUxvb2t1cCgnZGVwdGgnICsgdGhpcy5sYXN0Q29udGV4dCwgbmFtZSwgJ2NvbnRleHQnKSk7XG4gIH0sXG5cbiAgLy8gW3B1c2hDb250ZXh0XVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiBjdXJyZW50Q29udGV4dCwgLi4uXG4gIC8vXG4gIC8vIFB1c2hlcyB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgY29udGV4dCBvbnRvIHRoZSBzdGFjay5cbiAgcHVzaENvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbCgnZGVwdGgnICsgdGhpcy5sYXN0Q29udGV4dCk7XG4gIH0sXG5cbiAgLy8gW3Jlc29sdmVQb3NzaWJsZUxhbWJkYV1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogdmFsdWUsIC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IHJlc29sdmVkIHZhbHVlLCAuLi5cbiAgLy9cbiAgLy8gSWYgdGhlIGB2YWx1ZWAgaXMgYSBsYW1iZGEsIHJlcGxhY2UgaXQgb24gdGhlIHN0YWNrIGJ5XG4gIC8vIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGxhbWJkYVxuICByZXNvbHZlUG9zc2libGVMYW1iZGE6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29udGV4dC5hbGlhc2VzLmZ1bmN0aW9uVHlwZSA9ICdcImZ1bmN0aW9uXCInO1xuXG4gICAgdGhpcy5yZXBsYWNlU3RhY2soZnVuY3Rpb24oY3VycmVudCkge1xuICAgICAgcmV0dXJuIFwidHlwZW9mIFwiICsgY3VycmVudCArIFwiID09PSBmdW5jdGlvblR5cGUgPyBcIiArIGN1cnJlbnQgKyBcIi5hcHBseShkZXB0aDApIDogXCIgKyBjdXJyZW50O1xuICAgIH0pO1xuICB9LFxuXG4gIC8vIFtsb29rdXBdXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IHZhbHVlLCAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiB2YWx1ZVtuYW1lXSwgLi4uXG4gIC8vXG4gIC8vIFJlcGxhY2UgdGhlIHZhbHVlIG9uIHRoZSBzdGFjayB3aXRoIHRoZSByZXN1bHQgb2YgbG9va2luZ1xuICAvLyB1cCBgbmFtZWAgb24gYHZhbHVlYFxuICBsb29rdXA6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB0aGlzLnJlcGxhY2VTdGFjayhmdW5jdGlvbihjdXJyZW50KSB7XG4gICAgICByZXR1cm4gY3VycmVudCArIFwiID09IG51bGwgfHwgXCIgKyBjdXJyZW50ICsgXCIgPT09IGZhbHNlID8gXCIgKyBjdXJyZW50ICsgXCIgOiBcIiArIHRoaXMubmFtZUxvb2t1cChjdXJyZW50LCBuYW1lLCAnY29udGV4dCcpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8vIFtsb29rdXBEYXRhXVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiBkYXRhLCAuLi5cbiAgLy9cbiAgLy8gUHVzaCB0aGUgZGF0YSBsb29rdXAgb3BlcmF0b3JcbiAgbG9va3VwRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKCdkYXRhJyk7XG4gIH0sXG5cbiAgLy8gW3B1c2hTdHJpbmdQYXJhbV1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogLi4uXG4gIC8vIE9uIHN0YWNrLCBhZnRlcjogc3RyaW5nLCBjdXJyZW50Q29udGV4dCwgLi4uXG4gIC8vXG4gIC8vIFRoaXMgb3Bjb2RlIGlzIGRlc2lnbmVkIGZvciB1c2UgaW4gc3RyaW5nIG1vZGUsIHdoaWNoXG4gIC8vIHByb3ZpZGVzIHRoZSBzdHJpbmcgdmFsdWUgb2YgYSBwYXJhbWV0ZXIgYWxvbmcgd2l0aCBpdHNcbiAgLy8gZGVwdGggcmF0aGVyIHRoYW4gcmVzb2x2aW5nIGl0IGltbWVkaWF0ZWx5LlxuICBwdXNoU3RyaW5nUGFyYW06IGZ1bmN0aW9uKHN0cmluZywgdHlwZSkge1xuICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbCgnZGVwdGgnICsgdGhpcy5sYXN0Q29udGV4dCk7XG5cbiAgICB0aGlzLnB1c2hTdHJpbmcodHlwZSk7XG5cbiAgICAvLyBJZiBpdCdzIGEgc3ViZXhwcmVzc2lvbiwgdGhlIHN0cmluZyByZXN1bHRcbiAgICAvLyB3aWxsIGJlIHB1c2hlZCBhZnRlciB0aGlzIG9wY29kZS5cbiAgICBpZiAodHlwZSAhPT0gJ3NleHByJykge1xuICAgICAgaWYgKHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMucHVzaFN0cmluZyhzdHJpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKHN0cmluZyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGVtcHR5SGFzaDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKCd7fScpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zdHJpbmdQYXJhbXMpIHtcbiAgICAgIHRoaXMucHVzaCgne30nKTsgLy8gaGFzaENvbnRleHRzXG4gICAgICB0aGlzLnB1c2goJ3t9Jyk7IC8vIGhhc2hUeXBlc1xuICAgIH1cbiAgfSxcbiAgcHVzaEhhc2g6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmhhc2gpIHtcbiAgICAgIHRoaXMuaGFzaGVzLnB1c2godGhpcy5oYXNoKTtcbiAgICB9XG4gICAgdGhpcy5oYXNoID0ge3ZhbHVlczogW10sIHR5cGVzOiBbXSwgY29udGV4dHM6IFtdfTtcbiAgfSxcbiAgcG9wSGFzaDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhhc2ggPSB0aGlzLmhhc2g7XG4gICAgdGhpcy5oYXNoID0gdGhpcy5oYXNoZXMucG9wKCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnN0cmluZ1BhcmFtcykge1xuICAgICAgdGhpcy5wdXNoKCd7JyArIGhhc2guY29udGV4dHMuam9pbignLCcpICsgJ30nKTtcbiAgICAgIHRoaXMucHVzaCgneycgKyBoYXNoLnR5cGVzLmpvaW4oJywnKSArICd9Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5wdXNoKCd7XFxuICAgICcgKyBoYXNoLnZhbHVlcy5qb2luKCcsXFxuICAgICcpICsgJ1xcbiAgfScpO1xuICB9LFxuXG4gIC8vIFtwdXNoU3RyaW5nXVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiBxdW90ZWRTdHJpbmcoc3RyaW5nKSwgLi4uXG4gIC8vXG4gIC8vIFB1c2ggYSBxdW90ZWQgdmVyc2lvbiBvZiBgc3RyaW5nYCBvbnRvIHRoZSBzdGFja1xuICBwdXNoU3RyaW5nOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB0aGlzLnB1c2hTdGFja0xpdGVyYWwodGhpcy5xdW90ZWRTdHJpbmcoc3RyaW5nKSk7XG4gIH0sXG5cbiAgLy8gW3B1c2hdXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IGV4cHIsIC4uLlxuICAvL1xuICAvLyBQdXNoIGFuIGV4cHJlc3Npb24gb250byB0aGUgc3RhY2tcbiAgcHVzaDogZnVuY3Rpb24oZXhwcikge1xuICAgIHRoaXMuaW5saW5lU3RhY2sucHVzaChleHByKTtcbiAgICByZXR1cm4gZXhwcjtcbiAgfSxcblxuICAvLyBbcHVzaExpdGVyYWxdXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IHZhbHVlLCAuLi5cbiAgLy9cbiAgLy8gUHVzaGVzIGEgdmFsdWUgb250byB0aGUgc3RhY2suIFRoaXMgb3BlcmF0aW9uIHByZXZlbnRzXG4gIC8vIHRoZSBjb21waWxlciBmcm9tIGNyZWF0aW5nIGEgdGVtcG9yYXJ5IHZhcmlhYmxlIHRvIGhvbGRcbiAgLy8gaXQuXG4gIHB1c2hMaXRlcmFsOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbCh2YWx1ZSk7XG4gIH0sXG5cbiAgLy8gW3B1c2hQcm9ncmFtXVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiBwcm9ncmFtKGd1aWQpLCAuLi5cbiAgLy9cbiAgLy8gUHVzaCBhIHByb2dyYW0gZXhwcmVzc2lvbiBvbnRvIHRoZSBzdGFjay4gVGhpcyB0YWtlc1xuICAvLyBhIGNvbXBpbGUtdGltZSBndWlkIGFuZCBjb252ZXJ0cyBpdCBpbnRvIGEgcnVudGltZS1hY2Nlc3NpYmxlXG4gIC8vIGV4cHJlc3Npb24uXG4gIHB1c2hQcm9ncmFtOiBmdW5jdGlvbihndWlkKSB7XG4gICAgaWYgKGd1aWQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKHRoaXMucHJvZ3JhbUV4cHJlc3Npb24oZ3VpZCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2hTdGFja0xpdGVyYWwobnVsbCk7XG4gICAgfVxuICB9LFxuXG4gIC8vIFtpbnZva2VIZWxwZXJdXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IGhhc2gsIGludmVyc2UsIHByb2dyYW0sIHBhcmFtcy4uLiwgLi4uXG4gIC8vIE9uIHN0YWNrLCBhZnRlcjogcmVzdWx0IG9mIGhlbHBlciBpbnZvY2F0aW9uXG4gIC8vXG4gIC8vIFBvcHMgb2ZmIHRoZSBoZWxwZXIncyBwYXJhbWV0ZXJzLCBpbnZva2VzIHRoZSBoZWxwZXIsXG4gIC8vIGFuZCBwdXNoZXMgdGhlIGhlbHBlcidzIHJldHVybiB2YWx1ZSBvbnRvIHRoZSBzdGFjay5cbiAgLy9cbiAgLy8gSWYgdGhlIGhlbHBlciBpcyBub3QgZm91bmQsIGBoZWxwZXJNaXNzaW5nYCBpcyBjYWxsZWQuXG4gIGludm9rZUhlbHBlcjogZnVuY3Rpb24ocGFyYW1TaXplLCBuYW1lLCBpc1Jvb3QpIHtcbiAgICB0aGlzLmNvbnRleHQuYWxpYXNlcy5oZWxwZXJNaXNzaW5nID0gJ2hlbHBlcnMuaGVscGVyTWlzc2luZyc7XG4gICAgdGhpcy51c2VSZWdpc3RlcignaGVscGVyJyk7XG5cbiAgICB2YXIgaGVscGVyID0gdGhpcy5sYXN0SGVscGVyID0gdGhpcy5zZXR1cEhlbHBlcihwYXJhbVNpemUsIG5hbWUsIHRydWUpO1xuICAgIHZhciBub25IZWxwZXIgPSB0aGlzLm5hbWVMb29rdXAoJ2RlcHRoJyArIHRoaXMubGFzdENvbnRleHQsIG5hbWUsICdjb250ZXh0Jyk7XG5cbiAgICB2YXIgbG9va3VwID0gJ2hlbHBlciA9ICcgKyBoZWxwZXIubmFtZSArICcgfHwgJyArIG5vbkhlbHBlcjtcbiAgICBpZiAoaGVscGVyLnBhcmFtc0luaXQpIHtcbiAgICAgIGxvb2t1cCArPSAnLCcgKyBoZWxwZXIucGFyYW1zSW5pdDtcbiAgICB9XG5cbiAgICB0aGlzLnB1c2goXG4gICAgICAnKCdcbiAgICAgICAgKyBsb29rdXBcbiAgICAgICAgKyAnLGhlbHBlciAnXG4gICAgICAgICAgKyAnPyBoZWxwZXIuY2FsbCgnICsgaGVscGVyLmNhbGxQYXJhbXMgKyAnKSAnXG4gICAgICAgICAgKyAnOiBoZWxwZXJNaXNzaW5nLmNhbGwoJyArIGhlbHBlci5oZWxwZXJNaXNzaW5nUGFyYW1zICsgJykpJyk7XG5cbiAgICAvLyBBbHdheXMgZmx1c2ggc3ViZXhwcmVzc2lvbnMuIFRoaXMgaXMgYm90aCB0byBwcmV2ZW50IHRoZSBjb21wb3VuZGluZyBzaXplIGlzc3VlIHRoYXRcbiAgICAvLyBvY2N1cnMgd2hlbiB0aGUgY29kZSBoYXMgdG8gYmUgZHVwbGljYXRlZCBmb3IgaW5saW5pbmcgYW5kIGFsc28gdG8gcHJldmVudCBlcnJvcnNcbiAgICAvLyBkdWUgdG8gdGhlIGluY29ycmVjdCBvcHRpb25zIG9iamVjdCBiZWluZyBwYXNzZWQgZHVlIHRvIHRoZSBzaGFyZWQgcmVnaXN0ZXIuXG4gICAgaWYgKCFpc1Jvb3QpIHtcbiAgICAgIHRoaXMuZmx1c2hJbmxpbmUoKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gW2ludm9rZUtub3duSGVscGVyXVxuICAvL1xuICAvLyBPbiBzdGFjaywgYmVmb3JlOiBoYXNoLCBpbnZlcnNlLCBwcm9ncmFtLCBwYXJhbXMuLi4sIC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IHJlc3VsdCBvZiBoZWxwZXIgaW52b2NhdGlvblxuICAvL1xuICAvLyBUaGlzIG9wZXJhdGlvbiBpcyB1c2VkIHdoZW4gdGhlIGhlbHBlciBpcyBrbm93biB0byBleGlzdCxcbiAgLy8gc28gYSBgaGVscGVyTWlzc2luZ2AgZmFsbGJhY2sgaXMgbm90IHJlcXVpcmVkLlxuICBpbnZva2VLbm93bkhlbHBlcjogZnVuY3Rpb24ocGFyYW1TaXplLCBuYW1lKSB7XG4gICAgdmFyIGhlbHBlciA9IHRoaXMuc2V0dXBIZWxwZXIocGFyYW1TaXplLCBuYW1lKTtcbiAgICB0aGlzLnB1c2goaGVscGVyLm5hbWUgKyBcIi5jYWxsKFwiICsgaGVscGVyLmNhbGxQYXJhbXMgKyBcIilcIik7XG4gIH0sXG5cbiAgLy8gW2ludm9rZUFtYmlndW91c11cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogaGFzaCwgaW52ZXJzZSwgcHJvZ3JhbSwgcGFyYW1zLi4uLCAuLi5cbiAgLy8gT24gc3RhY2ssIGFmdGVyOiByZXN1bHQgb2YgZGlzYW1iaWd1YXRpb25cbiAgLy9cbiAgLy8gVGhpcyBvcGVyYXRpb24gaXMgdXNlZCB3aGVuIGFuIGV4cHJlc3Npb24gbGlrZSBge3tmb299fWBcbiAgLy8gaXMgcHJvdmlkZWQsIGJ1dCB3ZSBkb24ndCBrbm93IGF0IGNvbXBpbGUtdGltZSB3aGV0aGVyIGl0XG4gIC8vIGlzIGEgaGVscGVyIG9yIGEgcGF0aC5cbiAgLy9cbiAgLy8gVGhpcyBvcGVyYXRpb24gZW1pdHMgbW9yZSBjb2RlIHRoYW4gdGhlIG90aGVyIG9wdGlvbnMsXG4gIC8vIGFuZCBjYW4gYmUgYXZvaWRlZCBieSBwYXNzaW5nIHRoZSBga25vd25IZWxwZXJzYCBhbmRcbiAgLy8gYGtub3duSGVscGVyc09ubHlgIGZsYWdzIGF0IGNvbXBpbGUtdGltZS5cbiAgaW52b2tlQW1iaWd1b3VzOiBmdW5jdGlvbihuYW1lLCBoZWxwZXJDYWxsKSB7XG4gICAgdGhpcy5jb250ZXh0LmFsaWFzZXMuZnVuY3Rpb25UeXBlID0gJ1wiZnVuY3Rpb25cIic7XG4gICAgdGhpcy51c2VSZWdpc3RlcignaGVscGVyJyk7XG5cbiAgICB0aGlzLmVtcHR5SGFzaCgpO1xuICAgIHZhciBoZWxwZXIgPSB0aGlzLnNldHVwSGVscGVyKDAsIG5hbWUsIGhlbHBlckNhbGwpO1xuXG4gICAgdmFyIGhlbHBlck5hbWUgPSB0aGlzLmxhc3RIZWxwZXIgPSB0aGlzLm5hbWVMb29rdXAoJ2hlbHBlcnMnLCBuYW1lLCAnaGVscGVyJyk7XG5cbiAgICB2YXIgbm9uSGVscGVyID0gdGhpcy5uYW1lTG9va3VwKCdkZXB0aCcgKyB0aGlzLmxhc3RDb250ZXh0LCBuYW1lLCAnY29udGV4dCcpO1xuICAgIHZhciBuZXh0U3RhY2sgPSB0aGlzLm5leHRTdGFjaygpO1xuXG4gICAgaWYgKGhlbHBlci5wYXJhbXNJbml0KSB7XG4gICAgICB0aGlzLnB1c2hTb3VyY2UoaGVscGVyLnBhcmFtc0luaXQpO1xuICAgIH1cbiAgICB0aGlzLnB1c2hTb3VyY2UoJ2lmIChoZWxwZXIgPSAnICsgaGVscGVyTmFtZSArICcpIHsgJyArIG5leHRTdGFjayArICcgPSBoZWxwZXIuY2FsbCgnICsgaGVscGVyLmNhbGxQYXJhbXMgKyAnKTsgfScpO1xuICAgIHRoaXMucHVzaFNvdXJjZSgnZWxzZSB7IGhlbHBlciA9ICcgKyBub25IZWxwZXIgKyAnOyAnICsgbmV4dFN0YWNrICsgJyA9IHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKCcgKyBoZWxwZXIuY2FsbFBhcmFtcyArICcpIDogaGVscGVyOyB9Jyk7XG4gIH0sXG5cbiAgLy8gW2ludm9rZVBhcnRpYWxdXG4gIC8vXG4gIC8vIE9uIHN0YWNrLCBiZWZvcmU6IGNvbnRleHQsIC4uLlxuICAvLyBPbiBzdGFjayBhZnRlcjogcmVzdWx0IG9mIHBhcnRpYWwgaW52b2NhdGlvblxuICAvL1xuICAvLyBUaGlzIG9wZXJhdGlvbiBwb3BzIG9mZiBhIGNvbnRleHQsIGludm9rZXMgYSBwYXJ0aWFsIHdpdGggdGhhdCBjb250ZXh0LFxuICAvLyBhbmQgcHVzaGVzIHRoZSByZXN1bHQgb2YgdGhlIGludm9jYXRpb24gYmFjay5cbiAgaW52b2tlUGFydGlhbDogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBwYXJhbXMgPSBbdGhpcy5uYW1lTG9va3VwKCdwYXJ0aWFscycsIG5hbWUsICdwYXJ0aWFsJyksIFwiJ1wiICsgbmFtZSArIFwiJ1wiLCB0aGlzLnBvcFN0YWNrKCksIFwiaGVscGVyc1wiLCBcInBhcnRpYWxzXCJdO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kYXRhKSB7XG4gICAgICBwYXJhbXMucHVzaChcImRhdGFcIik7XG4gICAgfVxuXG4gICAgdGhpcy5jb250ZXh0LmFsaWFzZXMuc2VsZiA9IFwidGhpc1wiO1xuICAgIHRoaXMucHVzaChcInNlbGYuaW52b2tlUGFydGlhbChcIiArIHBhcmFtcy5qb2luKFwiLCBcIikgKyBcIilcIik7XG4gIH0sXG5cbiAgLy8gW2Fzc2lnblRvSGFzaF1cbiAgLy9cbiAgLy8gT24gc3RhY2ssIGJlZm9yZTogdmFsdWUsIGhhc2gsIC4uLlxuICAvLyBPbiBzdGFjaywgYWZ0ZXI6IGhhc2gsIC4uLlxuICAvL1xuICAvLyBQb3BzIGEgdmFsdWUgYW5kIGhhc2ggb2ZmIHRoZSBzdGFjaywgYXNzaWducyBgaGFzaFtrZXldID0gdmFsdWVgXG4gIC8vIGFuZCBwdXNoZXMgdGhlIGhhc2ggYmFjayBvbnRvIHRoZSBzdGFjay5cbiAgYXNzaWduVG9IYXNoOiBmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnBvcFN0YWNrKCksXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHR5cGU7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnN0cmluZ1BhcmFtcykge1xuICAgICAgdHlwZSA9IHRoaXMucG9wU3RhY2soKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzLnBvcFN0YWNrKCk7XG4gICAgfVxuXG4gICAgdmFyIGhhc2ggPSB0aGlzLmhhc2g7XG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgIGhhc2guY29udGV4dHMucHVzaChcIidcIiArIGtleSArIFwiJzogXCIgKyBjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGhhc2gudHlwZXMucHVzaChcIidcIiArIGtleSArIFwiJzogXCIgKyB0eXBlKTtcbiAgICB9XG4gICAgaGFzaC52YWx1ZXMucHVzaChcIidcIiArIGtleSArIFwiJzogKFwiICsgdmFsdWUgKyBcIilcIik7XG4gIH0sXG5cbiAgLy8gSEVMUEVSU1xuXG4gIGNvbXBpbGVyOiBKYXZhU2NyaXB0Q29tcGlsZXIsXG5cbiAgY29tcGlsZUNoaWxkcmVuOiBmdW5jdGlvbihlbnZpcm9ubWVudCwgb3B0aW9ucykge1xuICAgIHZhciBjaGlsZHJlbiA9IGVudmlyb25tZW50LmNoaWxkcmVuLCBjaGlsZCwgY29tcGlsZXI7XG5cbiAgICBmb3IodmFyIGk9MCwgbD1jaGlsZHJlbi5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgY29tcGlsZXIgPSBuZXcgdGhpcy5jb21waWxlcigpO1xuXG4gICAgICB2YXIgaW5kZXggPSB0aGlzLm1hdGNoRXhpc3RpbmdQcm9ncmFtKGNoaWxkKTtcblxuICAgICAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnByb2dyYW1zLnB1c2goJycpOyAgICAgLy8gUGxhY2Vob2xkZXIgdG8gcHJldmVudCBuYW1lIGNvbmZsaWN0cyBmb3IgbmVzdGVkIGNoaWxkcmVuXG4gICAgICAgIGluZGV4ID0gdGhpcy5jb250ZXh0LnByb2dyYW1zLmxlbmd0aDtcbiAgICAgICAgY2hpbGQuaW5kZXggPSBpbmRleDtcbiAgICAgICAgY2hpbGQubmFtZSA9ICdwcm9ncmFtJyArIGluZGV4O1xuICAgICAgICB0aGlzLmNvbnRleHQucHJvZ3JhbXNbaW5kZXhdID0gY29tcGlsZXIuY29tcGlsZShjaGlsZCwgb3B0aW9ucywgdGhpcy5jb250ZXh0KTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmVudmlyb25tZW50c1tpbmRleF0gPSBjaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGNoaWxkLm5hbWUgPSAncHJvZ3JhbScgKyBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1hdGNoRXhpc3RpbmdQcm9ncmFtOiBmdW5jdGlvbihjaGlsZCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvbnRleHQuZW52aXJvbm1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgZW52aXJvbm1lbnQgPSB0aGlzLmNvbnRleHQuZW52aXJvbm1lbnRzW2ldO1xuICAgICAgaWYgKGVudmlyb25tZW50ICYmIGVudmlyb25tZW50LmVxdWFscyhjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHByb2dyYW1FeHByZXNzaW9uOiBmdW5jdGlvbihndWlkKSB7XG4gICAgdGhpcy5jb250ZXh0LmFsaWFzZXMuc2VsZiA9IFwidGhpc1wiO1xuXG4gICAgaWYoZ3VpZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gXCJzZWxmLm5vb3BcIjtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGQgPSB0aGlzLmVudmlyb25tZW50LmNoaWxkcmVuW2d1aWRdLFxuICAgICAgICBkZXB0aHMgPSBjaGlsZC5kZXB0aHMubGlzdCwgZGVwdGg7XG5cbiAgICB2YXIgcHJvZ3JhbVBhcmFtcyA9IFtjaGlsZC5pbmRleCwgY2hpbGQubmFtZSwgXCJkYXRhXCJdO1xuXG4gICAgZm9yKHZhciBpPTAsIGwgPSBkZXB0aHMubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgZGVwdGggPSBkZXB0aHNbaV07XG5cbiAgICAgIGlmKGRlcHRoID09PSAxKSB7IHByb2dyYW1QYXJhbXMucHVzaChcImRlcHRoMFwiKTsgfVxuICAgICAgZWxzZSB7IHByb2dyYW1QYXJhbXMucHVzaChcImRlcHRoXCIgKyAoZGVwdGggLSAxKSk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGRlcHRocy5sZW5ndGggPT09IDAgPyBcInNlbGYucHJvZ3JhbShcIiA6IFwic2VsZi5wcm9ncmFtV2l0aERlcHRoKFwiKSArIHByb2dyYW1QYXJhbXMuam9pbihcIiwgXCIpICsgXCIpXCI7XG4gIH0sXG5cbiAgcmVnaXN0ZXI6IGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuICAgIHRoaXMudXNlUmVnaXN0ZXIobmFtZSk7XG4gICAgdGhpcy5wdXNoU291cmNlKG5hbWUgKyBcIiA9IFwiICsgdmFsICsgXCI7XCIpO1xuICB9LFxuXG4gIHVzZVJlZ2lzdGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYoIXRoaXMucmVnaXN0ZXJzW25hbWVdKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyc1tuYW1lXSA9IHRydWU7XG4gICAgICB0aGlzLnJlZ2lzdGVycy5saXN0LnB1c2gobmFtZSk7XG4gICAgfVxuICB9LFxuXG4gIHB1c2hTdGFja0xpdGVyYWw6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gdGhpcy5wdXNoKG5ldyBMaXRlcmFsKGl0ZW0pKTtcbiAgfSxcblxuICBwdXNoU291cmNlOiBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nQ29udGVudCkge1xuICAgICAgdGhpcy5zb3VyY2UucHVzaCh0aGlzLmFwcGVuZFRvQnVmZmVyKHRoaXMucXVvdGVkU3RyaW5nKHRoaXMucGVuZGluZ0NvbnRlbnQpKSk7XG4gICAgICB0aGlzLnBlbmRpbmdDb250ZW50ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIHRoaXMuc291cmNlLnB1c2goc291cmNlKTtcbiAgICB9XG4gIH0sXG5cbiAgcHVzaFN0YWNrOiBmdW5jdGlvbihpdGVtKSB7XG4gICAgdGhpcy5mbHVzaElubGluZSgpO1xuXG4gICAgdmFyIHN0YWNrID0gdGhpcy5pbmNyU3RhY2soKTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdGhpcy5wdXNoU291cmNlKHN0YWNrICsgXCIgPSBcIiArIGl0ZW0gKyBcIjtcIik7XG4gICAgfVxuICAgIHRoaXMuY29tcGlsZVN0YWNrLnB1c2goc3RhY2spO1xuICAgIHJldHVybiBzdGFjaztcbiAgfSxcblxuICByZXBsYWNlU3RhY2s6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIHByZWZpeCA9ICcnLFxuICAgICAgICBpbmxpbmUgPSB0aGlzLmlzSW5saW5lKCksXG4gICAgICAgIHN0YWNrLFxuICAgICAgICBjcmVhdGVkU3RhY2ssXG4gICAgICAgIHVzZWRMaXRlcmFsO1xuXG4gICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBpbmxpbmUgdGhlbiB3ZSB3YW50IHRvIG1lcmdlIHRoZSBpbmxpbmUgc3RhdGVtZW50IGludG8gdGhlXG4gICAgLy8gcmVwbGFjZW1lbnQgc3RhdGVtZW50IHZpYSAnLCdcbiAgICBpZiAoaW5saW5lKSB7XG4gICAgICB2YXIgdG9wID0gdGhpcy5wb3BTdGFjayh0cnVlKTtcblxuICAgICAgaWYgKHRvcCBpbnN0YW5jZW9mIExpdGVyYWwpIHtcbiAgICAgICAgLy8gTGl0ZXJhbHMgZG8gbm90IG5lZWQgdG8gYmUgaW5saW5lZFxuICAgICAgICBzdGFjayA9IHRvcC52YWx1ZTtcbiAgICAgICAgdXNlZExpdGVyYWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gR2V0IG9yIGNyZWF0ZSB0aGUgY3VycmVudCBzdGFjayBuYW1lIGZvciB1c2UgYnkgdGhlIGlubGluZVxuICAgICAgICBjcmVhdGVkU3RhY2sgPSAhdGhpcy5zdGFja1Nsb3Q7XG4gICAgICAgIHZhciBuYW1lID0gIWNyZWF0ZWRTdGFjayA/IHRoaXMudG9wU3RhY2tOYW1lKCkgOiB0aGlzLmluY3JTdGFjaygpO1xuXG4gICAgICAgIHByZWZpeCA9ICcoJyArIHRoaXMucHVzaChuYW1lKSArICcgPSAnICsgdG9wICsgJyksJztcbiAgICAgICAgc3RhY2sgPSB0aGlzLnRvcFN0YWNrKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YWNrID0gdGhpcy50b3BTdGFjaygpO1xuICAgIH1cblxuICAgIHZhciBpdGVtID0gY2FsbGJhY2suY2FsbCh0aGlzLCBzdGFjayk7XG5cbiAgICBpZiAoaW5saW5lKSB7XG4gICAgICBpZiAoIXVzZWRMaXRlcmFsKSB7XG4gICAgICAgIHRoaXMucG9wU3RhY2soKTtcbiAgICAgIH1cbiAgICAgIGlmIChjcmVhdGVkU3RhY2spIHtcbiAgICAgICAgdGhpcy5zdGFja1Nsb3QtLTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHVzaCgnKCcgKyBwcmVmaXggKyBpdGVtICsgJyknKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUHJldmVudCBtb2RpZmljYXRpb24gb2YgdGhlIGNvbnRleHQgZGVwdGggdmFyaWFibGUuIFRocm91Z2ggcmVwbGFjZVN0YWNrXG4gICAgICBpZiAoIS9ec3RhY2svLnRlc3Qoc3RhY2spKSB7XG4gICAgICAgIHN0YWNrID0gdGhpcy5uZXh0U3RhY2soKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wdXNoU291cmNlKHN0YWNrICsgXCIgPSAoXCIgKyBwcmVmaXggKyBpdGVtICsgXCIpO1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9LFxuXG4gIG5leHRTdGFjazogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKCk7XG4gIH0sXG5cbiAgaW5jclN0YWNrOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0YWNrU2xvdCsrO1xuICAgIGlmKHRoaXMuc3RhY2tTbG90ID4gdGhpcy5zdGFja1ZhcnMubGVuZ3RoKSB7IHRoaXMuc3RhY2tWYXJzLnB1c2goXCJzdGFja1wiICsgdGhpcy5zdGFja1Nsb3QpOyB9XG4gICAgcmV0dXJuIHRoaXMudG9wU3RhY2tOYW1lKCk7XG4gIH0sXG4gIHRvcFN0YWNrTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwic3RhY2tcIiArIHRoaXMuc3RhY2tTbG90O1xuICB9LFxuICBmbHVzaElubGluZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlubGluZVN0YWNrID0gdGhpcy5pbmxpbmVTdGFjaztcbiAgICBpZiAoaW5saW5lU3RhY2subGVuZ3RoKSB7XG4gICAgICB0aGlzLmlubGluZVN0YWNrID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaW5saW5lU3RhY2subGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gaW5saW5lU3RhY2tbaV07XG4gICAgICAgIGlmIChlbnRyeSBpbnN0YW5jZW9mIExpdGVyYWwpIHtcbiAgICAgICAgICB0aGlzLmNvbXBpbGVTdGFjay5wdXNoKGVudHJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnB1c2hTdGFjayhlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGlzSW5saW5lOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbmxpbmVTdGFjay5sZW5ndGg7XG4gIH0sXG5cbiAgcG9wU3RhY2s6IGZ1bmN0aW9uKHdyYXBwZWQpIHtcbiAgICB2YXIgaW5saW5lID0gdGhpcy5pc0lubGluZSgpLFxuICAgICAgICBpdGVtID0gKGlubGluZSA/IHRoaXMuaW5saW5lU3RhY2sgOiB0aGlzLmNvbXBpbGVTdGFjaykucG9wKCk7XG5cbiAgICBpZiAoIXdyYXBwZWQgJiYgKGl0ZW0gaW5zdGFuY2VvZiBMaXRlcmFsKSkge1xuICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghaW5saW5lKSB7XG4gICAgICAgIGlmICghdGhpcy5zdGFja1Nsb3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdJbnZhbGlkIHN0YWNrIHBvcCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhY2tTbG90LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gIH0sXG5cbiAgdG9wU3RhY2s6IGZ1bmN0aW9uKHdyYXBwZWQpIHtcbiAgICB2YXIgc3RhY2sgPSAodGhpcy5pc0lubGluZSgpID8gdGhpcy5pbmxpbmVTdGFjayA6IHRoaXMuY29tcGlsZVN0YWNrKSxcbiAgICAgICAgaXRlbSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKCF3cmFwcGVkICYmIChpdGVtIGluc3RhbmNlb2YgTGl0ZXJhbCkpIHtcbiAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gIH0sXG5cbiAgcXVvdGVkU3RyaW5nOiBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gJ1wiJyArIHN0clxuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJylcbiAgICAgIC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJylcbiAgICAgIC5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJylcbiAgICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJylcbiAgICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKSAgIC8vIFBlciBFY21hLTI2MiA3LjMgKyA3LjguNFxuICAgICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpICsgJ1wiJztcbiAgfSxcblxuICBzZXR1cEhlbHBlcjogZnVuY3Rpb24ocGFyYW1TaXplLCBuYW1lLCBtaXNzaW5nUGFyYW1zKSB7XG4gICAgdmFyIHBhcmFtcyA9IFtdLFxuICAgICAgICBwYXJhbXNJbml0ID0gdGhpcy5zZXR1cFBhcmFtcyhwYXJhbVNpemUsIHBhcmFtcywgbWlzc2luZ1BhcmFtcyk7XG4gICAgdmFyIGZvdW5kSGVscGVyID0gdGhpcy5uYW1lTG9va3VwKCdoZWxwZXJzJywgbmFtZSwgJ2hlbHBlcicpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgcGFyYW1zSW5pdDogcGFyYW1zSW5pdCxcbiAgICAgIG5hbWU6IGZvdW5kSGVscGVyLFxuICAgICAgY2FsbFBhcmFtczogW1wiZGVwdGgwXCJdLmNvbmNhdChwYXJhbXMpLmpvaW4oXCIsIFwiKSxcbiAgICAgIGhlbHBlck1pc3NpbmdQYXJhbXM6IG1pc3NpbmdQYXJhbXMgJiYgW1wiZGVwdGgwXCIsIHRoaXMucXVvdGVkU3RyaW5nKG5hbWUpXS5jb25jYXQocGFyYW1zKS5qb2luKFwiLCBcIilcbiAgICB9O1xuICB9LFxuXG4gIHNldHVwT3B0aW9uczogZnVuY3Rpb24ocGFyYW1TaXplLCBwYXJhbXMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IFtdLCBjb250ZXh0cyA9IFtdLCB0eXBlcyA9IFtdLCBwYXJhbSwgaW52ZXJzZSwgcHJvZ3JhbTtcblxuICAgIG9wdGlvbnMucHVzaChcImhhc2g6XCIgKyB0aGlzLnBvcFN0YWNrKCkpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zdHJpbmdQYXJhbXMpIHtcbiAgICAgIG9wdGlvbnMucHVzaChcImhhc2hUeXBlczpcIiArIHRoaXMucG9wU3RhY2soKSk7XG4gICAgICBvcHRpb25zLnB1c2goXCJoYXNoQ29udGV4dHM6XCIgKyB0aGlzLnBvcFN0YWNrKCkpO1xuICAgIH1cblxuICAgIGludmVyc2UgPSB0aGlzLnBvcFN0YWNrKCk7XG4gICAgcHJvZ3JhbSA9IHRoaXMucG9wU3RhY2soKTtcblxuICAgIC8vIEF2b2lkIHNldHRpbmcgZm4gYW5kIGludmVyc2UgaWYgbmVpdGhlciBhcmUgc2V0LiBUaGlzIGFsbG93c1xuICAgIC8vIGhlbHBlcnMgdG8gZG8gYSBjaGVjayBmb3IgYGlmIChvcHRpb25zLmZuKWBcbiAgICBpZiAocHJvZ3JhbSB8fCBpbnZlcnNlKSB7XG4gICAgICBpZiAoIXByb2dyYW0pIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmFsaWFzZXMuc2VsZiA9IFwidGhpc1wiO1xuICAgICAgICBwcm9ncmFtID0gXCJzZWxmLm5vb3BcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpbnZlcnNlKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5hbGlhc2VzLnNlbGYgPSBcInRoaXNcIjtcbiAgICAgICAgaW52ZXJzZSA9IFwic2VsZi5ub29wXCI7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMucHVzaChcImludmVyc2U6XCIgKyBpbnZlcnNlKTtcbiAgICAgIG9wdGlvbnMucHVzaChcImZuOlwiICsgcHJvZ3JhbSk7XG4gICAgfVxuXG4gICAgZm9yKHZhciBpPTA7IGk8cGFyYW1TaXplOyBpKyspIHtcbiAgICAgIHBhcmFtID0gdGhpcy5wb3BTdGFjaygpO1xuICAgICAgcGFyYW1zLnB1c2gocGFyYW0pO1xuXG4gICAgICBpZih0aGlzLm9wdGlvbnMuc3RyaW5nUGFyYW1zKSB7XG4gICAgICAgIHR5cGVzLnB1c2godGhpcy5wb3BTdGFjaygpKTtcbiAgICAgICAgY29udGV4dHMucHVzaCh0aGlzLnBvcFN0YWNrKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc3RyaW5nUGFyYW1zKSB7XG4gICAgICBvcHRpb25zLnB1c2goXCJjb250ZXh0czpbXCIgKyBjb250ZXh0cy5qb2luKFwiLFwiKSArIFwiXVwiKTtcbiAgICAgIG9wdGlvbnMucHVzaChcInR5cGVzOltcIiArIHR5cGVzLmpvaW4oXCIsXCIpICsgXCJdXCIpO1xuICAgIH1cblxuICAgIGlmKHRoaXMub3B0aW9ucy5kYXRhKSB7XG4gICAgICBvcHRpb25zLnB1c2goXCJkYXRhOmRhdGFcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH0sXG5cbiAgLy8gdGhlIHBhcmFtcyBhbmQgY29udGV4dHMgYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4gYXJyYXlzXG4gIC8vIHRvIGZpbGwgaW5cbiAgc2V0dXBQYXJhbXM6IGZ1bmN0aW9uKHBhcmFtU2l6ZSwgcGFyYW1zLCB1c2VSZWdpc3Rlcikge1xuICAgIHZhciBvcHRpb25zID0gJ3snICsgdGhpcy5zZXR1cE9wdGlvbnMocGFyYW1TaXplLCBwYXJhbXMpLmpvaW4oJywnKSArICd9JztcblxuICAgIGlmICh1c2VSZWdpc3Rlcikge1xuICAgICAgdGhpcy51c2VSZWdpc3Rlcignb3B0aW9ucycpO1xuICAgICAgcGFyYW1zLnB1c2goJ29wdGlvbnMnKTtcbiAgICAgIHJldHVybiAnb3B0aW9ucz0nICsgb3B0aW9ucztcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1zLnB1c2gob3B0aW9ucyk7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcmVzZXJ2ZWRXb3JkcyA9IChcbiAgXCJicmVhayBlbHNlIG5ldyB2YXJcIiArXG4gIFwiIGNhc2UgZmluYWxseSByZXR1cm4gdm9pZFwiICtcbiAgXCIgY2F0Y2ggZm9yIHN3aXRjaCB3aGlsZVwiICtcbiAgXCIgY29udGludWUgZnVuY3Rpb24gdGhpcyB3aXRoXCIgK1xuICBcIiBkZWZhdWx0IGlmIHRocm93XCIgK1xuICBcIiBkZWxldGUgaW4gdHJ5XCIgK1xuICBcIiBkbyBpbnN0YW5jZW9mIHR5cGVvZlwiICtcbiAgXCIgYWJzdHJhY3QgZW51bSBpbnQgc2hvcnRcIiArXG4gIFwiIGJvb2xlYW4gZXhwb3J0IGludGVyZmFjZSBzdGF0aWNcIiArXG4gIFwiIGJ5dGUgZXh0ZW5kcyBsb25nIHN1cGVyXCIgK1xuICBcIiBjaGFyIGZpbmFsIG5hdGl2ZSBzeW5jaHJvbml6ZWRcIiArXG4gIFwiIGNsYXNzIGZsb2F0IHBhY2thZ2UgdGhyb3dzXCIgK1xuICBcIiBjb25zdCBnb3RvIHByaXZhdGUgdHJhbnNpZW50XCIgK1xuICBcIiBkZWJ1Z2dlciBpbXBsZW1lbnRzIHByb3RlY3RlZCB2b2xhdGlsZVwiICtcbiAgXCIgZG91YmxlIGltcG9ydCBwdWJsaWMgbGV0IHlpZWxkXCJcbikuc3BsaXQoXCIgXCIpO1xuXG52YXIgY29tcGlsZXJXb3JkcyA9IEphdmFTY3JpcHRDb21waWxlci5SRVNFUlZFRF9XT1JEUyA9IHt9O1xuXG5mb3IodmFyIGk9MCwgbD1yZXNlcnZlZFdvcmRzLmxlbmd0aDsgaTxsOyBpKyspIHtcbiAgY29tcGlsZXJXb3Jkc1tyZXNlcnZlZFdvcmRzW2ldXSA9IHRydWU7XG59XG5cbkphdmFTY3JpcHRDb21waWxlci5pc1ZhbGlkSmF2YVNjcmlwdFZhcmlhYmxlTmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYoIUphdmFTY3JpcHRDb21waWxlci5SRVNFUlZFRF9XT1JEU1tuYW1lXSAmJiAvXlthLXpBLVpfJF1bMC05YS16QS1aXyRdKiQvLnRlc3QobmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEphdmFTY3JpcHRDb21waWxlcjsiLCJcInVzZSBzdHJpY3RcIjtcbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbi8qIEppc29uIGdlbmVyYXRlZCBwYXJzZXIgKi9cbnZhciBoYW5kbGViYXJzID0gKGZ1bmN0aW9uKCl7XG52YXIgcGFyc2VyID0ge3RyYWNlOiBmdW5jdGlvbiB0cmFjZSgpIHsgfSxcbnl5OiB7fSxcbnN5bWJvbHNfOiB7XCJlcnJvclwiOjIsXCJyb290XCI6MyxcInN0YXRlbWVudHNcIjo0LFwiRU9GXCI6NSxcInByb2dyYW1cIjo2LFwic2ltcGxlSW52ZXJzZVwiOjcsXCJzdGF0ZW1lbnRcIjo4LFwib3BlbkludmVyc2VcIjo5LFwiY2xvc2VCbG9ja1wiOjEwLFwib3BlbkJsb2NrXCI6MTEsXCJtdXN0YWNoZVwiOjEyLFwicGFydGlhbFwiOjEzLFwiQ09OVEVOVFwiOjE0LFwiQ09NTUVOVFwiOjE1LFwiT1BFTl9CTE9DS1wiOjE2LFwic2V4cHJcIjoxNyxcIkNMT1NFXCI6MTgsXCJPUEVOX0lOVkVSU0VcIjoxOSxcIk9QRU5fRU5EQkxPQ0tcIjoyMCxcInBhdGhcIjoyMSxcIk9QRU5cIjoyMixcIk9QRU5fVU5FU0NBUEVEXCI6MjMsXCJDTE9TRV9VTkVTQ0FQRURcIjoyNCxcIk9QRU5fUEFSVElBTFwiOjI1LFwicGFydGlhbE5hbWVcIjoyNixcInBhcnRpYWxfb3B0aW9uMFwiOjI3LFwic2V4cHJfcmVwZXRpdGlvbjBcIjoyOCxcInNleHByX29wdGlvbjBcIjoyOSxcImRhdGFOYW1lXCI6MzAsXCJwYXJhbVwiOjMxLFwiU1RSSU5HXCI6MzIsXCJJTlRFR0VSXCI6MzMsXCJCT09MRUFOXCI6MzQsXCJPUEVOX1NFWFBSXCI6MzUsXCJDTE9TRV9TRVhQUlwiOjM2LFwiaGFzaFwiOjM3LFwiaGFzaF9yZXBldGl0aW9uX3BsdXMwXCI6MzgsXCJoYXNoU2VnbWVudFwiOjM5LFwiSURcIjo0MCxcIkVRVUFMU1wiOjQxLFwiREFUQVwiOjQyLFwicGF0aFNlZ21lbnRzXCI6NDMsXCJTRVBcIjo0NCxcIiRhY2NlcHRcIjowLFwiJGVuZFwiOjF9LFxudGVybWluYWxzXzogezI6XCJlcnJvclwiLDU6XCJFT0ZcIiwxNDpcIkNPTlRFTlRcIiwxNTpcIkNPTU1FTlRcIiwxNjpcIk9QRU5fQkxPQ0tcIiwxODpcIkNMT1NFXCIsMTk6XCJPUEVOX0lOVkVSU0VcIiwyMDpcIk9QRU5fRU5EQkxPQ0tcIiwyMjpcIk9QRU5cIiwyMzpcIk9QRU5fVU5FU0NBUEVEXCIsMjQ6XCJDTE9TRV9VTkVTQ0FQRURcIiwyNTpcIk9QRU5fUEFSVElBTFwiLDMyOlwiU1RSSU5HXCIsMzM6XCJJTlRFR0VSXCIsMzQ6XCJCT09MRUFOXCIsMzU6XCJPUEVOX1NFWFBSXCIsMzY6XCJDTE9TRV9TRVhQUlwiLDQwOlwiSURcIiw0MTpcIkVRVUFMU1wiLDQyOlwiREFUQVwiLDQ0OlwiU0VQXCJ9LFxucHJvZHVjdGlvbnNfOiBbMCxbMywyXSxbMywxXSxbNiwyXSxbNiwzXSxbNiwyXSxbNiwxXSxbNiwxXSxbNiwwXSxbNCwxXSxbNCwyXSxbOCwzXSxbOCwzXSxbOCwxXSxbOCwxXSxbOCwxXSxbOCwxXSxbMTEsM10sWzksM10sWzEwLDNdLFsxMiwzXSxbMTIsM10sWzEzLDRdLFs3LDJdLFsxNywzXSxbMTcsMV0sWzMxLDFdLFszMSwxXSxbMzEsMV0sWzMxLDFdLFszMSwxXSxbMzEsM10sWzM3LDFdLFszOSwzXSxbMjYsMV0sWzI2LDFdLFsyNiwxXSxbMzAsMl0sWzIxLDFdLFs0MywzXSxbNDMsMV0sWzI3LDBdLFsyNywxXSxbMjgsMF0sWzI4LDJdLFsyOSwwXSxbMjksMV0sWzM4LDFdLFszOCwyXV0sXG5wZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXl0ZXh0LHl5bGVuZyx5eWxpbmVubyx5eSx5eXN0YXRlLCQkLF8kKSB7XG5cbnZhciAkMCA9ICQkLmxlbmd0aCAtIDE7XG5zd2l0Y2ggKHl5c3RhdGUpIHtcbmNhc2UgMTogcmV0dXJuIG5ldyB5eS5Qcm9ncmFtTm9kZSgkJFskMC0xXSwgdGhpcy5fJCk7IFxuYnJlYWs7XG5jYXNlIDI6IHJldHVybiBuZXcgeXkuUHJvZ3JhbU5vZGUoW10sIHRoaXMuXyQpOyBcbmJyZWFrO1xuY2FzZSAzOnRoaXMuJCA9IG5ldyB5eS5Qcm9ncmFtTm9kZShbXSwgJCRbJDAtMV0sICQkWyQwXSwgdGhpcy5fJCk7XG5icmVhaztcbmNhc2UgNDp0aGlzLiQgPSBuZXcgeXkuUHJvZ3JhbU5vZGUoJCRbJDAtMl0sICQkWyQwLTFdLCAkJFskMF0sIHRoaXMuXyQpO1xuYnJlYWs7XG5jYXNlIDU6dGhpcy4kID0gbmV3IHl5LlByb2dyYW1Ob2RlKCQkWyQwLTFdLCAkJFskMF0sIFtdLCB0aGlzLl8kKTtcbmJyZWFrO1xuY2FzZSA2OnRoaXMuJCA9IG5ldyB5eS5Qcm9ncmFtTm9kZSgkJFskMF0sIHRoaXMuXyQpO1xuYnJlYWs7XG5jYXNlIDc6dGhpcy4kID0gbmV3IHl5LlByb2dyYW1Ob2RlKFtdLCB0aGlzLl8kKTtcbmJyZWFrO1xuY2FzZSA4OnRoaXMuJCA9IG5ldyB5eS5Qcm9ncmFtTm9kZShbXSwgdGhpcy5fJCk7XG5icmVhaztcbmNhc2UgOTp0aGlzLiQgPSBbJCRbJDBdXTtcbmJyZWFrO1xuY2FzZSAxMDogJCRbJDAtMV0ucHVzaCgkJFskMF0pOyB0aGlzLiQgPSAkJFskMC0xXTsgXG5icmVhaztcbmNhc2UgMTE6dGhpcy4kID0gbmV3IHl5LkJsb2NrTm9kZSgkJFskMC0yXSwgJCRbJDAtMV0uaW52ZXJzZSwgJCRbJDAtMV0sICQkWyQwXSwgdGhpcy5fJCk7XG5icmVhaztcbmNhc2UgMTI6dGhpcy4kID0gbmV3IHl5LkJsb2NrTm9kZSgkJFskMC0yXSwgJCRbJDAtMV0sICQkWyQwLTFdLmludmVyc2UsICQkWyQwXSwgdGhpcy5fJCk7XG5icmVhaztcbmNhc2UgMTM6dGhpcy4kID0gJCRbJDBdO1xuYnJlYWs7XG5jYXNlIDE0OnRoaXMuJCA9ICQkWyQwXTtcbmJyZWFrO1xuY2FzZSAxNTp0aGlzLiQgPSBuZXcgeXkuQ29udGVudE5vZGUoJCRbJDBdLCB0aGlzLl8kKTtcbmJyZWFrO1xuY2FzZSAxNjp0aGlzLiQgPSBuZXcgeXkuQ29tbWVudE5vZGUoJCRbJDBdLCB0aGlzLl8kKTtcbmJyZWFrO1xuY2FzZSAxNzp0aGlzLiQgPSBuZXcgeXkuTXVzdGFjaGVOb2RlKCQkWyQwLTFdLCBudWxsLCAkJFskMC0yXSwgc3RyaXBGbGFncygkJFskMC0yXSwgJCRbJDBdKSwgdGhpcy5fJCk7XG5icmVhaztcbmNhc2UgMTg6dGhpcy4kID0gbmV3IHl5Lk11c3RhY2hlTm9kZSgkJFskMC0xXSwgbnVsbCwgJCRbJDAtMl0sIHN0cmlwRmxhZ3MoJCRbJDAtMl0sICQkWyQwXSksIHRoaXMuXyQpO1xuYnJlYWs7XG5jYXNlIDE5OnRoaXMuJCA9IHtwYXRoOiAkJFskMC0xXSwgc3RyaXA6IHN0cmlwRmxhZ3MoJCRbJDAtMl0sICQkWyQwXSl9O1xuYnJlYWs7XG5jYXNlIDIwOnRoaXMuJCA9IG5ldyB5eS5NdXN0YWNoZU5vZGUoJCRbJDAtMV0sIG51bGwsICQkWyQwLTJdLCBzdHJpcEZsYWdzKCQkWyQwLTJdLCAkJFskMF0pLCB0aGlzLl8kKTtcbmJyZWFrO1xuY2FzZSAyMTp0aGlzLiQgPSBuZXcgeXkuTXVzdGFjaGVOb2RlKCQkWyQwLTFdLCBudWxsLCAkJFskMC0yXSwgc3RyaXBGbGFncygkJFskMC0yXSwgJCRbJDBdKSwgdGhpcy5fJCk7XG5icmVhaztcbmNhc2UgMjI6dGhpcy4kID0gbmV3IHl5LlBhcnRpYWxOb2RlKCQkWyQwLTJdLCAkJFskMC0xXSwgc3RyaXBGbGFncygkJFskMC0zXSwgJCRbJDBdKSwgdGhpcy5fJCk7XG5icmVhaztcbmNhc2UgMjM6dGhpcy4kID0gc3RyaXBGbGFncygkJFskMC0xXSwgJCRbJDBdKTtcbmJyZWFrO1xuY2FzZSAyNDp0aGlzLiQgPSBuZXcgeXkuU2V4cHJOb2RlKFskJFskMC0yXV0uY29uY2F0KCQkWyQwLTFdKSwgJCRbJDBdLCB0aGlzLl8kKTtcbmJyZWFrO1xuY2FzZSAyNTp0aGlzLiQgPSBuZXcgeXkuU2V4cHJOb2RlKFskJFskMF1dLCBudWxsLCB0aGlzLl8kKTtcbmJyZWFrO1xuY2FzZSAyNjp0aGlzLiQgPSAkJFskMF07XG5icmVhaztcbmNhc2UgMjc6dGhpcy4kID0gbmV3IHl5LlN0cmluZ05vZGUoJCRbJDBdLCB0aGlzLl8kKTtcbmJyZWFrO1xuY2FzZSAyODp0aGlzLiQgPSBuZXcgeXkuSW50ZWdlck5vZGUoJCRbJDBdLCB0aGlzLl8kKTtcbmJyZWFrO1xuY2FzZSAyOTp0aGlzLiQgPSBuZXcgeXkuQm9vbGVhbk5vZGUoJCRbJDBdLCB0aGlzLl8kKTtcbmJyZWFrO1xuY2FzZSAzMDp0aGlzLiQgPSAkJFskMF07XG5icmVhaztcbmNhc2UgMzE6JCRbJDAtMV0uaXNIZWxwZXIgPSB0cnVlOyB0aGlzLiQgPSAkJFskMC0xXTtcbmJyZWFrO1xuY2FzZSAzMjp0aGlzLiQgPSBuZXcgeXkuSGFzaE5vZGUoJCRbJDBdLCB0aGlzLl8kKTtcbmJyZWFrO1xuY2FzZSAzMzp0aGlzLiQgPSBbJCRbJDAtMl0sICQkWyQwXV07XG5icmVhaztcbmNhc2UgMzQ6dGhpcy4kID0gbmV3IHl5LlBhcnRpYWxOYW1lTm9kZSgkJFskMF0sIHRoaXMuXyQpO1xuYnJlYWs7XG5jYXNlIDM1OnRoaXMuJCA9IG5ldyB5eS5QYXJ0aWFsTmFtZU5vZGUobmV3IHl5LlN0cmluZ05vZGUoJCRbJDBdLCB0aGlzLl8kKSwgdGhpcy5fJCk7XG5icmVhaztcbmNhc2UgMzY6dGhpcy4kID0gbmV3IHl5LlBhcnRpYWxOYW1lTm9kZShuZXcgeXkuSW50ZWdlck5vZGUoJCRbJDBdLCB0aGlzLl8kKSk7XG5icmVhaztcbmNhc2UgMzc6dGhpcy4kID0gbmV3IHl5LkRhdGFOb2RlKCQkWyQwXSwgdGhpcy5fJCk7XG5icmVhaztcbmNhc2UgMzg6dGhpcy4kID0gbmV3IHl5LklkTm9kZSgkJFskMF0sIHRoaXMuXyQpO1xuYnJlYWs7XG5jYXNlIDM5OiAkJFskMC0yXS5wdXNoKHtwYXJ0OiAkJFskMF0sIHNlcGFyYXRvcjogJCRbJDAtMV19KTsgdGhpcy4kID0gJCRbJDAtMl07IFxuYnJlYWs7XG5jYXNlIDQwOnRoaXMuJCA9IFt7cGFydDogJCRbJDBdfV07XG5icmVhaztcbmNhc2UgNDM6dGhpcy4kID0gW107XG5icmVhaztcbmNhc2UgNDQ6JCRbJDAtMV0ucHVzaCgkJFskMF0pO1xuYnJlYWs7XG5jYXNlIDQ3OnRoaXMuJCA9IFskJFskMF1dO1xuYnJlYWs7XG5jYXNlIDQ4OiQkWyQwLTFdLnB1c2goJCRbJDBdKTtcbmJyZWFrO1xufVxufSxcbnRhYmxlOiBbezM6MSw0OjIsNTpbMSwzXSw4OjQsOTo1LDExOjYsMTI6NywxMzo4LDE0OlsxLDldLDE1OlsxLDEwXSwxNjpbMSwxMl0sMTk6WzEsMTFdLDIyOlsxLDEzXSwyMzpbMSwxNF0sMjU6WzEsMTVdfSx7MTpbM119LHs1OlsxLDE2XSw4OjE3LDk6NSwxMTo2LDEyOjcsMTM6OCwxNDpbMSw5XSwxNTpbMSwxMF0sMTY6WzEsMTJdLDE5OlsxLDExXSwyMjpbMSwxM10sMjM6WzEsMTRdLDI1OlsxLDE1XX0sezE6WzIsMl19LHs1OlsyLDldLDE0OlsyLDldLDE1OlsyLDldLDE2OlsyLDldLDE5OlsyLDldLDIwOlsyLDldLDIyOlsyLDldLDIzOlsyLDldLDI1OlsyLDldfSx7NDoyMCw2OjE4LDc6MTksODo0LDk6NSwxMTo2LDEyOjcsMTM6OCwxNDpbMSw5XSwxNTpbMSwxMF0sMTY6WzEsMTJdLDE5OlsxLDIxXSwyMDpbMiw4XSwyMjpbMSwxM10sMjM6WzEsMTRdLDI1OlsxLDE1XX0sezQ6MjAsNjoyMiw3OjE5LDg6NCw5OjUsMTE6NiwxMjo3LDEzOjgsMTQ6WzEsOV0sMTU6WzEsMTBdLDE2OlsxLDEyXSwxOTpbMSwyMV0sMjA6WzIsOF0sMjI6WzEsMTNdLDIzOlsxLDE0XSwyNTpbMSwxNV19LHs1OlsyLDEzXSwxNDpbMiwxM10sMTU6WzIsMTNdLDE2OlsyLDEzXSwxOTpbMiwxM10sMjA6WzIsMTNdLDIyOlsyLDEzXSwyMzpbMiwxM10sMjU6WzIsMTNdfSx7NTpbMiwxNF0sMTQ6WzIsMTRdLDE1OlsyLDE0XSwxNjpbMiwxNF0sMTk6WzIsMTRdLDIwOlsyLDE0XSwyMjpbMiwxNF0sMjM6WzIsMTRdLDI1OlsyLDE0XX0sezU6WzIsMTVdLDE0OlsyLDE1XSwxNTpbMiwxNV0sMTY6WzIsMTVdLDE5OlsyLDE1XSwyMDpbMiwxNV0sMjI6WzIsMTVdLDIzOlsyLDE1XSwyNTpbMiwxNV19LHs1OlsyLDE2XSwxNDpbMiwxNl0sMTU6WzIsMTZdLDE2OlsyLDE2XSwxOTpbMiwxNl0sMjA6WzIsMTZdLDIyOlsyLDE2XSwyMzpbMiwxNl0sMjU6WzIsMTZdfSx7MTc6MjMsMjE6MjQsMzA6MjUsNDA6WzEsMjhdLDQyOlsxLDI3XSw0MzoyNn0sezE3OjI5LDIxOjI0LDMwOjI1LDQwOlsxLDI4XSw0MjpbMSwyN10sNDM6MjZ9LHsxNzozMCwyMToyNCwzMDoyNSw0MDpbMSwyOF0sNDI6WzEsMjddLDQzOjI2fSx7MTc6MzEsMjE6MjQsMzA6MjUsNDA6WzEsMjhdLDQyOlsxLDI3XSw0MzoyNn0sezIxOjMzLDI2OjMyLDMyOlsxLDM0XSwzMzpbMSwzNV0sNDA6WzEsMjhdLDQzOjI2fSx7MTpbMiwxXX0sezU6WzIsMTBdLDE0OlsyLDEwXSwxNTpbMiwxMF0sMTY6WzIsMTBdLDE5OlsyLDEwXSwyMDpbMiwxMF0sMjI6WzIsMTBdLDIzOlsyLDEwXSwyNTpbMiwxMF19LHsxMDozNiwyMDpbMSwzN119LHs0OjM4LDg6NCw5OjUsMTE6NiwxMjo3LDEzOjgsMTQ6WzEsOV0sMTU6WzEsMTBdLDE2OlsxLDEyXSwxOTpbMSwxMV0sMjA6WzIsN10sMjI6WzEsMTNdLDIzOlsxLDE0XSwyNTpbMSwxNV19LHs3OjM5LDg6MTcsOTo1LDExOjYsMTI6NywxMzo4LDE0OlsxLDldLDE1OlsxLDEwXSwxNjpbMSwxMl0sMTk6WzEsMjFdLDIwOlsyLDZdLDIyOlsxLDEzXSwyMzpbMSwxNF0sMjU6WzEsMTVdfSx7MTc6MjMsMTg6WzEsNDBdLDIxOjI0LDMwOjI1LDQwOlsxLDI4XSw0MjpbMSwyN10sNDM6MjZ9LHsxMDo0MSwyMDpbMSwzN119LHsxODpbMSw0Ml19LHsxODpbMiw0M10sMjQ6WzIsNDNdLDI4OjQzLDMyOlsyLDQzXSwzMzpbMiw0M10sMzQ6WzIsNDNdLDM1OlsyLDQzXSwzNjpbMiw0M10sNDA6WzIsNDNdLDQyOlsyLDQzXX0sezE4OlsyLDI1XSwyNDpbMiwyNV0sMzY6WzIsMjVdfSx7MTg6WzIsMzhdLDI0OlsyLDM4XSwzMjpbMiwzOF0sMzM6WzIsMzhdLDM0OlsyLDM4XSwzNTpbMiwzOF0sMzY6WzIsMzhdLDQwOlsyLDM4XSw0MjpbMiwzOF0sNDQ6WzEsNDRdfSx7MjE6NDUsNDA6WzEsMjhdLDQzOjI2fSx7MTg6WzIsNDBdLDI0OlsyLDQwXSwzMjpbMiw0MF0sMzM6WzIsNDBdLDM0OlsyLDQwXSwzNTpbMiw0MF0sMzY6WzIsNDBdLDQwOlsyLDQwXSw0MjpbMiw0MF0sNDQ6WzIsNDBdfSx7MTg6WzEsNDZdfSx7MTg6WzEsNDddfSx7MjQ6WzEsNDhdfSx7MTg6WzIsNDFdLDIxOjUwLDI3OjQ5LDQwOlsxLDI4XSw0MzoyNn0sezE4OlsyLDM0XSw0MDpbMiwzNF19LHsxODpbMiwzNV0sNDA6WzIsMzVdfSx7MTg6WzIsMzZdLDQwOlsyLDM2XX0sezU6WzIsMTFdLDE0OlsyLDExXSwxNTpbMiwxMV0sMTY6WzIsMTFdLDE5OlsyLDExXSwyMDpbMiwxMV0sMjI6WzIsMTFdLDIzOlsyLDExXSwyNTpbMiwxMV19LHsyMTo1MSw0MDpbMSwyOF0sNDM6MjZ9LHs4OjE3LDk6NSwxMTo2LDEyOjcsMTM6OCwxNDpbMSw5XSwxNTpbMSwxMF0sMTY6WzEsMTJdLDE5OlsxLDExXSwyMDpbMiwzXSwyMjpbMSwxM10sMjM6WzEsMTRdLDI1OlsxLDE1XX0sezQ6NTIsODo0LDk6NSwxMTo2LDEyOjcsMTM6OCwxNDpbMSw5XSwxNTpbMSwxMF0sMTY6WzEsMTJdLDE5OlsxLDExXSwyMDpbMiw1XSwyMjpbMSwxM10sMjM6WzEsMTRdLDI1OlsxLDE1XX0sezE0OlsyLDIzXSwxNTpbMiwyM10sMTY6WzIsMjNdLDE5OlsyLDIzXSwyMDpbMiwyM10sMjI6WzIsMjNdLDIzOlsyLDIzXSwyNTpbMiwyM119LHs1OlsyLDEyXSwxNDpbMiwxMl0sMTU6WzIsMTJdLDE2OlsyLDEyXSwxOTpbMiwxMl0sMjA6WzIsMTJdLDIyOlsyLDEyXSwyMzpbMiwxMl0sMjU6WzIsMTJdfSx7MTQ6WzIsMThdLDE1OlsyLDE4XSwxNjpbMiwxOF0sMTk6WzIsMThdLDIwOlsyLDE4XSwyMjpbMiwxOF0sMjM6WzIsMThdLDI1OlsyLDE4XX0sezE4OlsyLDQ1XSwyMTo1NiwyNDpbMiw0NV0sMjk6NTMsMzA6NjAsMzE6NTQsMzI6WzEsNTddLDMzOlsxLDU4XSwzNDpbMSw1OV0sMzU6WzEsNjFdLDM2OlsyLDQ1XSwzNzo1NSwzODo2MiwzOTo2Myw0MDpbMSw2NF0sNDI6WzEsMjddLDQzOjI2fSx7NDA6WzEsNjVdfSx7MTg6WzIsMzddLDI0OlsyLDM3XSwzMjpbMiwzN10sMzM6WzIsMzddLDM0OlsyLDM3XSwzNTpbMiwzN10sMzY6WzIsMzddLDQwOlsyLDM3XSw0MjpbMiwzN119LHsxNDpbMiwxN10sMTU6WzIsMTddLDE2OlsyLDE3XSwxOTpbMiwxN10sMjA6WzIsMTddLDIyOlsyLDE3XSwyMzpbMiwxN10sMjU6WzIsMTddfSx7NTpbMiwyMF0sMTQ6WzIsMjBdLDE1OlsyLDIwXSwxNjpbMiwyMF0sMTk6WzIsMjBdLDIwOlsyLDIwXSwyMjpbMiwyMF0sMjM6WzIsMjBdLDI1OlsyLDIwXX0sezU6WzIsMjFdLDE0OlsyLDIxXSwxNTpbMiwyMV0sMTY6WzIsMjFdLDE5OlsyLDIxXSwyMDpbMiwyMV0sMjI6WzIsMjFdLDIzOlsyLDIxXSwyNTpbMiwyMV19LHsxODpbMSw2Nl19LHsxODpbMiw0Ml19LHsxODpbMSw2N119LHs4OjE3LDk6NSwxMTo2LDEyOjcsMTM6OCwxNDpbMSw5XSwxNTpbMSwxMF0sMTY6WzEsMTJdLDE5OlsxLDExXSwyMDpbMiw0XSwyMjpbMSwxM10sMjM6WzEsMTRdLDI1OlsxLDE1XX0sezE4OlsyLDI0XSwyNDpbMiwyNF0sMzY6WzIsMjRdfSx7MTg6WzIsNDRdLDI0OlsyLDQ0XSwzMjpbMiw0NF0sMzM6WzIsNDRdLDM0OlsyLDQ0XSwzNTpbMiw0NF0sMzY6WzIsNDRdLDQwOlsyLDQ0XSw0MjpbMiw0NF19LHsxODpbMiw0Nl0sMjQ6WzIsNDZdLDM2OlsyLDQ2XX0sezE4OlsyLDI2XSwyNDpbMiwyNl0sMzI6WzIsMjZdLDMzOlsyLDI2XSwzNDpbMiwyNl0sMzU6WzIsMjZdLDM2OlsyLDI2XSw0MDpbMiwyNl0sNDI6WzIsMjZdfSx7MTg6WzIsMjddLDI0OlsyLDI3XSwzMjpbMiwyN10sMzM6WzIsMjddLDM0OlsyLDI3XSwzNTpbMiwyN10sMzY6WzIsMjddLDQwOlsyLDI3XSw0MjpbMiwyN119LHsxODpbMiwyOF0sMjQ6WzIsMjhdLDMyOlsyLDI4XSwzMzpbMiwyOF0sMzQ6WzIsMjhdLDM1OlsyLDI4XSwzNjpbMiwyOF0sNDA6WzIsMjhdLDQyOlsyLDI4XX0sezE4OlsyLDI5XSwyNDpbMiwyOV0sMzI6WzIsMjldLDMzOlsyLDI5XSwzNDpbMiwyOV0sMzU6WzIsMjldLDM2OlsyLDI5XSw0MDpbMiwyOV0sNDI6WzIsMjldfSx7MTg6WzIsMzBdLDI0OlsyLDMwXSwzMjpbMiwzMF0sMzM6WzIsMzBdLDM0OlsyLDMwXSwzNTpbMiwzMF0sMzY6WzIsMzBdLDQwOlsyLDMwXSw0MjpbMiwzMF19LHsxNzo2OCwyMToyNCwzMDoyNSw0MDpbMSwyOF0sNDI6WzEsMjddLDQzOjI2fSx7MTg6WzIsMzJdLDI0OlsyLDMyXSwzNjpbMiwzMl0sMzk6NjksNDA6WzEsNzBdfSx7MTg6WzIsNDddLDI0OlsyLDQ3XSwzNjpbMiw0N10sNDA6WzIsNDddfSx7MTg6WzIsNDBdLDI0OlsyLDQwXSwzMjpbMiw0MF0sMzM6WzIsNDBdLDM0OlsyLDQwXSwzNTpbMiw0MF0sMzY6WzIsNDBdLDQwOlsyLDQwXSw0MTpbMSw3MV0sNDI6WzIsNDBdLDQ0OlsyLDQwXX0sezE4OlsyLDM5XSwyNDpbMiwzOV0sMzI6WzIsMzldLDMzOlsyLDM5XSwzNDpbMiwzOV0sMzU6WzIsMzldLDM2OlsyLDM5XSw0MDpbMiwzOV0sNDI6WzIsMzldLDQ0OlsyLDM5XX0sezU6WzIsMjJdLDE0OlsyLDIyXSwxNTpbMiwyMl0sMTY6WzIsMjJdLDE5OlsyLDIyXSwyMDpbMiwyMl0sMjI6WzIsMjJdLDIzOlsyLDIyXSwyNTpbMiwyMl19LHs1OlsyLDE5XSwxNDpbMiwxOV0sMTU6WzIsMTldLDE2OlsyLDE5XSwxOTpbMiwxOV0sMjA6WzIsMTldLDIyOlsyLDE5XSwyMzpbMiwxOV0sMjU6WzIsMTldfSx7MzY6WzEsNzJdfSx7MTg6WzIsNDhdLDI0OlsyLDQ4XSwzNjpbMiw0OF0sNDA6WzIsNDhdfSx7NDE6WzEsNzFdfSx7MjE6NTYsMzA6NjAsMzE6NzMsMzI6WzEsNTddLDMzOlsxLDU4XSwzNDpbMSw1OV0sMzU6WzEsNjFdLDQwOlsxLDI4XSw0MjpbMSwyN10sNDM6MjZ9LHsxODpbMiwzMV0sMjQ6WzIsMzFdLDMyOlsyLDMxXSwzMzpbMiwzMV0sMzQ6WzIsMzFdLDM1OlsyLDMxXSwzNjpbMiwzMV0sNDA6WzIsMzFdLDQyOlsyLDMxXX0sezE4OlsyLDMzXSwyNDpbMiwzM10sMzY6WzIsMzNdLDQwOlsyLDMzXX1dLFxuZGVmYXVsdEFjdGlvbnM6IHszOlsyLDJdLDE2OlsyLDFdLDUwOlsyLDQyXX0sXG5wYXJzZUVycm9yOiBmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihzdHIpO1xufSxcbnBhcnNlOiBmdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuICAgIHZhciBzZWxmID0gdGhpcywgc3RhY2sgPSBbMF0sIHZzdGFjayA9IFtudWxsXSwgbHN0YWNrID0gW10sIHRhYmxlID0gdGhpcy50YWJsZSwgeXl0ZXh0ID0gXCJcIiwgeXlsaW5lbm8gPSAwLCB5eWxlbmcgPSAwLCByZWNvdmVyaW5nID0gMCwgVEVSUk9SID0gMiwgRU9GID0gMTtcbiAgICB0aGlzLmxleGVyLnNldElucHV0KGlucHV0KTtcbiAgICB0aGlzLmxleGVyLnl5ID0gdGhpcy55eTtcbiAgICB0aGlzLnl5LmxleGVyID0gdGhpcy5sZXhlcjtcbiAgICB0aGlzLnl5LnBhcnNlciA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmxleGVyLnl5bGxvYyA9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0aGlzLmxleGVyLnl5bGxvYyA9IHt9O1xuICAgIHZhciB5eWxvYyA9IHRoaXMubGV4ZXIueXlsbG9jO1xuICAgIGxzdGFjay5wdXNoKHl5bG9jKTtcbiAgICB2YXIgcmFuZ2VzID0gdGhpcy5sZXhlci5vcHRpb25zICYmIHRoaXMubGV4ZXIub3B0aW9ucy5yYW5nZXM7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnl5LnBhcnNlRXJyb3IgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gdGhpcy55eS5wYXJzZUVycm9yO1xuICAgIGZ1bmN0aW9uIHBvcFN0YWNrKG4pIHtcbiAgICAgICAgc3RhY2subGVuZ3RoID0gc3RhY2subGVuZ3RoIC0gMiAqIG47XG4gICAgICAgIHZzdGFjay5sZW5ndGggPSB2c3RhY2subGVuZ3RoIC0gbjtcbiAgICAgICAgbHN0YWNrLmxlbmd0aCA9IGxzdGFjay5sZW5ndGggLSBuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsZXgoKSB7XG4gICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgdG9rZW4gPSBzZWxmLmxleGVyLmxleCgpIHx8IDE7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRva2VuID0gc2VsZi5zeW1ib2xzX1t0b2tlbl0gfHwgdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgICB2YXIgc3ltYm9sLCBwcmVFcnJvclN5bWJvbCwgc3RhdGUsIGFjdGlvbiwgYSwgciwgeXl2YWwgPSB7fSwgcCwgbGVuLCBuZXdTdGF0ZSwgZXhwZWN0ZWQ7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgc3RhdGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSB0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzeW1ib2wgPT09IG51bGwgfHwgdHlwZW9mIHN5bWJvbCA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbGV4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY3Rpb24gPSB0YWJsZVtzdGF0ZV0gJiYgdGFibGVbc3RhdGVdW3N5bWJvbF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09IFwidW5kZWZpbmVkXCIgfHwgIWFjdGlvbi5sZW5ndGggfHwgIWFjdGlvblswXSkge1xuICAgICAgICAgICAgdmFyIGVyclN0ciA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoIXJlY292ZXJpbmcpIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAocCBpbiB0YWJsZVtzdGF0ZV0pXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRlcm1pbmFsc19bcF0gJiYgcCA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkLnB1c2goXCInXCIgKyB0aGlzLnRlcm1pbmFsc19bcF0gKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZXhlci5zaG93UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gXCJQYXJzZSBlcnJvciBvbiBsaW5lIFwiICsgKHl5bGluZW5vICsgMSkgKyBcIjpcXG5cIiArIHRoaXMubGV4ZXIuc2hvd1Bvc2l0aW9uKCkgKyBcIlxcbkV4cGVjdGluZyBcIiArIGV4cGVjdGVkLmpvaW4oXCIsIFwiKSArIFwiLCBnb3QgJ1wiICsgKHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCkgKyBcIidcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSBcIlBhcnNlIGVycm9yIG9uIGxpbmUgXCIgKyAoeXlsaW5lbm8gKyAxKSArIFwiOiBVbmV4cGVjdGVkIFwiICsgKHN5bWJvbCA9PSAxP1wiZW5kIG9mIGlucHV0XCI6XCInXCIgKyAodGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sKSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUVycm9yKGVyclN0ciwge3RleHQ6IHRoaXMubGV4ZXIubWF0Y2gsIHRva2VuOiB0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wsIGxpbmU6IHRoaXMubGV4ZXIueXlsaW5lbm8sIGxvYzogeXlsb2MsIGV4cGVjdGVkOiBleHBlY3RlZH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhY3Rpb25bMF0gaW5zdGFuY2VvZiBBcnJheSAmJiBhY3Rpb24ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyc2UgRXJyb3I6IG11bHRpcGxlIGFjdGlvbnMgcG9zc2libGUgYXQgc3RhdGU6IFwiICsgc3RhdGUgKyBcIiwgdG9rZW46IFwiICsgc3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGFjdGlvblswXSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBzdGFjay5wdXNoKHN5bWJvbCk7XG4gICAgICAgICAgICB2c3RhY2sucHVzaCh0aGlzLmxleGVyLnl5dGV4dCk7XG4gICAgICAgICAgICBsc3RhY2sucHVzaCh0aGlzLmxleGVyLnl5bGxvYyk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGFjdGlvblsxXSk7XG4gICAgICAgICAgICBzeW1ib2wgPSBudWxsO1xuICAgICAgICAgICAgaWYgKCFwcmVFcnJvclN5bWJvbCkge1xuICAgICAgICAgICAgICAgIHl5bGVuZyA9IHRoaXMubGV4ZXIueXlsZW5nO1xuICAgICAgICAgICAgICAgIHl5dGV4dCA9IHRoaXMubGV4ZXIueXl0ZXh0O1xuICAgICAgICAgICAgICAgIHl5bGluZW5vID0gdGhpcy5sZXhlci55eWxpbmVubztcbiAgICAgICAgICAgICAgICB5eWxvYyA9IHRoaXMubGV4ZXIueXlsbG9jO1xuICAgICAgICAgICAgICAgIGlmIChyZWNvdmVyaW5nID4gMClcbiAgICAgICAgICAgICAgICAgICAgcmVjb3ZlcmluZy0tO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBwcmVFcnJvclN5bWJvbDtcbiAgICAgICAgICAgICAgICBwcmVFcnJvclN5bWJvbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgbGVuID0gdGhpcy5wcm9kdWN0aW9uc19bYWN0aW9uWzFdXVsxXTtcbiAgICAgICAgICAgIHl5dmFsLiQgPSB2c3RhY2tbdnN0YWNrLmxlbmd0aCAtIGxlbl07XG4gICAgICAgICAgICB5eXZhbC5fJCA9IHtmaXJzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLmZpcnN0X2xpbmUsIGxhc3RfbGluZTogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5sYXN0X2xpbmUsIGZpcnN0X2NvbHVtbjogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAobGVuIHx8IDEpXS5maXJzdF9jb2x1bW4sIGxhc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLmxhc3RfY29sdW1ufTtcbiAgICAgICAgICAgIGlmIChyYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB5eXZhbC5fJC5yYW5nZSA9IFtsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLnJhbmdlWzBdLCBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLnJhbmdlWzFdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIgPSB0aGlzLnBlcmZvcm1BY3Rpb24uY2FsbCh5eXZhbCwgeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB0aGlzLnl5LCBhY3Rpb25bMV0sIHZzdGFjaywgbHN0YWNrKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIHN0YWNrID0gc3RhY2suc2xpY2UoMCwgLTEgKiBsZW4gKiAyKTtcbiAgICAgICAgICAgICAgICB2c3RhY2sgPSB2c3RhY2suc2xpY2UoMCwgLTEgKiBsZW4pO1xuICAgICAgICAgICAgICAgIGxzdGFjayA9IGxzdGFjay5zbGljZSgwLCAtMSAqIGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMucHJvZHVjdGlvbnNfW2FjdGlvblsxXV1bMF0pO1xuICAgICAgICAgICAgdnN0YWNrLnB1c2goeXl2YWwuJCk7XG4gICAgICAgICAgICBsc3RhY2sucHVzaCh5eXZhbC5fJCk7XG4gICAgICAgICAgICBuZXdTdGF0ZSA9IHRhYmxlW3N0YWNrW3N0YWNrLmxlbmd0aCAtIDJdXVtzdGFja1tzdGFjay5sZW5ndGggLSAxXV07XG4gICAgICAgICAgICBzdGFjay5wdXNoKG5ld1N0YXRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbn07XG5cblxuZnVuY3Rpb24gc3RyaXBGbGFncyhvcGVuLCBjbG9zZSkge1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IG9wZW4uY2hhckF0KDIpID09PSAnficsXG4gICAgcmlnaHQ6IGNsb3NlLmNoYXJBdCgwKSA9PT0gJ34nIHx8IGNsb3NlLmNoYXJBdCgxKSA9PT0gJ34nXG4gIH07XG59XG5cbi8qIEppc29uIGdlbmVyYXRlZCBsZXhlciAqL1xudmFyIGxleGVyID0gKGZ1bmN0aW9uKCl7XG52YXIgbGV4ZXIgPSAoe0VPRjoxLFxucGFyc2VFcnJvcjpmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCkge1xuICAgICAgICBpZiAodGhpcy55eS5wYXJzZXIpIHtcbiAgICAgICAgICAgIHRoaXMueXkucGFyc2VyLnBhcnNlRXJyb3Ioc3RyLCBoYXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHIpO1xuICAgICAgICB9XG4gICAgfSxcbnNldElucHV0OmZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLl9tb3JlID0gdGhpcy5fbGVzcyA9IHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnl5bGluZW5vID0gdGhpcy55eWxlbmcgPSAwO1xuICAgICAgICB0aGlzLnl5dGV4dCA9IHRoaXMubWF0Y2hlZCA9IHRoaXMubWF0Y2ggPSAnJztcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjayA9IFsnSU5JVElBTCddO1xuICAgICAgICB0aGlzLnl5bGxvYyA9IHtmaXJzdF9saW5lOjEsZmlyc3RfY29sdW1uOjAsbGFzdF9saW5lOjEsbGFzdF9jb2x1bW46MH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB0aGlzLnl5bGxvYy5yYW5nZSA9IFswLDBdO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5pbnB1dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaCA9IHRoaXMuX2lucHV0WzBdO1xuICAgICAgICB0aGlzLnl5dGV4dCArPSBjaDtcbiAgICAgICAgdGhpcy55eWxlbmcrKztcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgdGhpcy5tYXRjaCArPSBjaDtcbiAgICAgICAgdGhpcy5tYXRjaGVkICs9IGNoO1xuICAgICAgICB2YXIgbGluZXMgPSBjaC5tYXRjaCgvKD86XFxyXFxuP3xcXG4pLiovZyk7XG4gICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgdGhpcy55eWxpbmVubysrO1xuICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbisrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB0aGlzLnl5bGxvYy5yYW5nZVsxXSsrO1xuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gdGhpcy5faW5wdXQuc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiBjaDtcbiAgICB9LFxudW5wdXQ6ZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgIHZhciBsZW4gPSBjaC5sZW5ndGg7XG4gICAgICAgIHZhciBsaW5lcyA9IGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG5cbiAgICAgICAgdGhpcy5faW5wdXQgPSBjaCArIHRoaXMuX2lucHV0O1xuICAgICAgICB0aGlzLnl5dGV4dCA9IHRoaXMueXl0ZXh0LnN1YnN0cigwLCB0aGlzLnl5dGV4dC5sZW5ndGgtbGVuLTEpO1xuICAgICAgICAvL3RoaXMueXlsZW5nIC09IGxlbjtcbiAgICAgICAgdGhpcy5vZmZzZXQgLT0gbGVuO1xuICAgICAgICB2YXIgb2xkTGluZXMgPSB0aGlzLm1hdGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG4gICAgICAgIHRoaXMubWF0Y2ggPSB0aGlzLm1hdGNoLnN1YnN0cigwLCB0aGlzLm1hdGNoLmxlbmd0aC0xKTtcbiAgICAgICAgdGhpcy5tYXRjaGVkID0gdGhpcy5tYXRjaGVkLnN1YnN0cigwLCB0aGlzLm1hdGNoZWQubGVuZ3RoLTEpO1xuXG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGgtMSkgdGhpcy55eWxpbmVubyAtPSBsaW5lcy5sZW5ndGgtMTtcbiAgICAgICAgdmFyIHIgPSB0aGlzLnl5bGxvYy5yYW5nZTtcblxuICAgICAgICB0aGlzLnl5bGxvYyA9IHtmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5maXJzdF9saW5lLFxuICAgICAgICAgIGxhc3RfbGluZTogdGhpcy55eWxpbmVubysxLFxuICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uLFxuICAgICAgICAgIGxhc3RfY29sdW1uOiBsaW5lcyA/XG4gICAgICAgICAgICAgIChsaW5lcy5sZW5ndGggPT09IG9sZExpbmVzLmxlbmd0aCA/IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiA6IDApICsgb2xkTGluZXNbb2xkTGluZXMubGVuZ3RoIC0gbGluZXMubGVuZ3RoXS5sZW5ndGggLSBsaW5lc1swXS5sZW5ndGg6XG4gICAgICAgICAgICAgIHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiAtIGxlblxuICAgICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gW3JbMF0sIHJbMF0gKyB0aGlzLnl5bGVuZyAtIGxlbl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbm1vcmU6ZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tb3JlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbmxlc3M6ZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdGhpcy51bnB1dCh0aGlzLm1hdGNoLnNsaWNlKG4pKTtcbiAgICB9LFxucGFzdElucHV0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhc3QgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSB0aGlzLm1hdGNoLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiAocGFzdC5sZW5ndGggPiAyMCA/ICcuLi4nOicnKSArIHBhc3Quc3Vic3RyKC0yMCkucmVwbGFjZSgvXFxuL2csIFwiXCIpO1xuICAgIH0sXG51cGNvbWluZ0lucHV0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLm1hdGNoO1xuICAgICAgICBpZiAobmV4dC5sZW5ndGggPCAyMCkge1xuICAgICAgICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5zdWJzdHIoMCwgMjAtbmV4dC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobmV4dC5zdWJzdHIoMCwyMCkrKG5leHQubGVuZ3RoID4gMjAgPyAnLi4uJzonJykpLnJlcGxhY2UoL1xcbi9nLCBcIlwiKTtcbiAgICB9LFxuc2hvd1Bvc2l0aW9uOmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZSA9IHRoaXMucGFzdElucHV0KCk7XG4gICAgICAgIHZhciBjID0gbmV3IEFycmF5KHByZS5sZW5ndGggKyAxKS5qb2luKFwiLVwiKTtcbiAgICAgICAgcmV0dXJuIHByZSArIHRoaXMudXBjb21pbmdJbnB1dCgpICsgXCJcXG5cIiArIGMrXCJeXCI7XG4gICAgfSxcbm5leHQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pbnB1dCkgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgICB2YXIgdG9rZW4sXG4gICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgIHRlbXBNYXRjaCxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgY29sLFxuICAgICAgICAgICAgbGluZXM7XG4gICAgICAgIGlmICghdGhpcy5fbW9yZSkge1xuICAgICAgICAgICAgdGhpcy55eXRleHQgPSAnJztcbiAgICAgICAgICAgIHRoaXMubWF0Y2ggPSAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLl9jdXJyZW50UnVsZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaT0wO2kgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGVtcE1hdGNoID0gdGhpcy5faW5wdXQubWF0Y2godGhpcy5ydWxlc1tydWxlc1tpXV0pO1xuICAgICAgICAgICAgaWYgKHRlbXBNYXRjaCAmJiAoIW1hdGNoIHx8IHRlbXBNYXRjaFswXS5sZW5ndGggPiBtYXRjaFswXS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSB0ZW1wTWF0Y2g7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmZsZXgpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbGluZXMgPSBtYXRjaFswXS5tYXRjaCgvKD86XFxyXFxuP3xcXG4pLiovZyk7XG4gICAgICAgICAgICBpZiAobGluZXMpIHRoaXMueXlsaW5lbm8gKz0gbGluZXMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy55eWxsb2MgPSB7Zmlyc3RfbGluZTogdGhpcy55eWxsb2MubGFzdF9saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vKzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxpbmVzID8gbGluZXNbbGluZXMubGVuZ3RoLTFdLmxlbmd0aC1saW5lc1tsaW5lcy5sZW5ndGgtMV0ubWF0Y2goL1xccj9cXG4/LylbMF0ubGVuZ3RoIDogdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gKyBtYXRjaFswXS5sZW5ndGh9O1xuICAgICAgICAgICAgdGhpcy55eXRleHQgKz0gbWF0Y2hbMF07XG4gICAgICAgICAgICB0aGlzLm1hdGNoICs9IG1hdGNoWzBdO1xuICAgICAgICAgICAgdGhpcy5tYXRjaGVzID0gbWF0Y2g7XG4gICAgICAgICAgICB0aGlzLnl5bGVuZyA9IHRoaXMueXl0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbdGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICs9IHRoaXMueXlsZW5nXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21vcmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0ID0gdGhpcy5faW5wdXQuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlZCArPSBtYXRjaFswXTtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy5wZXJmb3JtQWN0aW9uLmNhbGwodGhpcywgdGhpcy55eSwgdGhpcywgcnVsZXNbaW5kZXhdLHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGgtMV0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9uZSAmJiB0aGlzLl9pbnB1dCkgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodG9rZW4pIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dCA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcignTGV4aWNhbCBlcnJvciBvbiBsaW5lICcrKHRoaXMueXlsaW5lbm8rMSkrJy4gVW5yZWNvZ25pemVkIHRleHQuXFxuJyt0aGlzLnNob3dQb3NpdGlvbigpLFxuICAgICAgICAgICAgICAgICAgICB7dGV4dDogXCJcIiwgdG9rZW46IG51bGwsIGxpbmU6IHRoaXMueXlsaW5lbm99KTtcbiAgICAgICAgfVxuICAgIH0sXG5sZXg6ZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICB2YXIgciA9IHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAodHlwZW9mIHIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxleCgpO1xuICAgICAgICB9XG4gICAgfSxcbmJlZ2luOmZ1bmN0aW9uIGJlZ2luKGNvbmRpdGlvbikge1xuICAgICAgICB0aGlzLmNvbmRpdGlvblN0YWNrLnB1c2goY29uZGl0aW9uKTtcbiAgICB9LFxucG9wU3RhdGU6ZnVuY3Rpb24gcG9wU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrLnBvcCgpO1xuICAgIH0sXG5fY3VycmVudFJ1bGVzOmZ1bmN0aW9uIF9jdXJyZW50UnVsZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnNbdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aC0xXV0ucnVsZXM7XG4gICAgfSxcbnRvcFN0YXRlOmZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGgtMl07XG4gICAgfSxcbnB1c2hTdGF0ZTpmdW5jdGlvbiBiZWdpbihjb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5iZWdpbihjb25kaXRpb24pO1xuICAgIH19KTtcbmxleGVyLm9wdGlvbnMgPSB7fTtcbmxleGVyLnBlcmZvcm1BY3Rpb24gPSBmdW5jdGlvbiBhbm9ueW1vdXMoeXkseXlfLCRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMsWVlfU1RBUlQpIHtcblxuXG5mdW5jdGlvbiBzdHJpcChzdGFydCwgZW5kKSB7XG4gIHJldHVybiB5eV8ueXl0ZXh0ID0geXlfLnl5dGV4dC5zdWJzdHIoc3RhcnQsIHl5Xy55eWxlbmctZW5kKTtcbn1cblxuXG52YXIgWVlTVEFURT1ZWV9TVEFSVFxuc3dpdGNoKCRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMpIHtcbmNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoeXlfLnl5dGV4dC5zbGljZSgtMikgPT09IFwiXFxcXFxcXFxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmlwKDAsMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iZWdpbihcIm11XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoeXlfLnl5dGV4dC5zbGljZSgtMSkgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaXAoMCwxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJlZ2luKFwiZW11XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmVnaW4oXCJtdVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih5eV8ueXl0ZXh0KSByZXR1cm4gMTQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbmJyZWFrO1xuY2FzZSAxOnJldHVybiAxNDtcbmJyZWFrO1xuY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuYnJlYWs7XG5jYXNlIDM6c3RyaXAoMCw0KTsgdGhpcy5wb3BTdGF0ZSgpOyByZXR1cm4gMTU7XG5icmVhaztcbmNhc2UgNDpyZXR1cm4gMzU7XG5icmVhaztcbmNhc2UgNTpyZXR1cm4gMzY7XG5icmVhaztcbmNhc2UgNjpyZXR1cm4gMjU7XG5icmVhaztcbmNhc2UgNzpyZXR1cm4gMTY7XG5icmVhaztcbmNhc2UgODpyZXR1cm4gMjA7XG5icmVhaztcbmNhc2UgOTpyZXR1cm4gMTk7XG5icmVhaztcbmNhc2UgMTA6cmV0dXJuIDE5O1xuYnJlYWs7XG5jYXNlIDExOnJldHVybiAyMztcbmJyZWFrO1xuY2FzZSAxMjpyZXR1cm4gMjI7XG5icmVhaztcbmNhc2UgMTM6dGhpcy5wb3BTdGF0ZSgpOyB0aGlzLmJlZ2luKCdjb20nKTtcbmJyZWFrO1xuY2FzZSAxNDpzdHJpcCgzLDUpOyB0aGlzLnBvcFN0YXRlKCk7IHJldHVybiAxNTtcbmJyZWFrO1xuY2FzZSAxNTpyZXR1cm4gMjI7XG5icmVhaztcbmNhc2UgMTY6cmV0dXJuIDQxO1xuYnJlYWs7XG5jYXNlIDE3OnJldHVybiA0MDtcbmJyZWFrO1xuY2FzZSAxODpyZXR1cm4gNDA7XG5icmVhaztcbmNhc2UgMTk6cmV0dXJuIDQ0O1xuYnJlYWs7XG5jYXNlIDIwOi8vIGlnbm9yZSB3aGl0ZXNwYWNlXG5icmVhaztcbmNhc2UgMjE6dGhpcy5wb3BTdGF0ZSgpOyByZXR1cm4gMjQ7XG5icmVhaztcbmNhc2UgMjI6dGhpcy5wb3BTdGF0ZSgpOyByZXR1cm4gMTg7XG5icmVhaztcbmNhc2UgMjM6eXlfLnl5dGV4dCA9IHN0cmlwKDEsMikucmVwbGFjZSgvXFxcXFwiL2csJ1wiJyk7IHJldHVybiAzMjtcbmJyZWFrO1xuY2FzZSAyNDp5eV8ueXl0ZXh0ID0gc3RyaXAoMSwyKS5yZXBsYWNlKC9cXFxcJy9nLFwiJ1wiKTsgcmV0dXJuIDMyO1xuYnJlYWs7XG5jYXNlIDI1OnJldHVybiA0MjtcbmJyZWFrO1xuY2FzZSAyNjpyZXR1cm4gMzQ7XG5icmVhaztcbmNhc2UgMjc6cmV0dXJuIDM0O1xuYnJlYWs7XG5jYXNlIDI4OnJldHVybiAzMztcbmJyZWFrO1xuY2FzZSAyOTpyZXR1cm4gNDA7XG5icmVhaztcbmNhc2UgMzA6eXlfLnl5dGV4dCA9IHN0cmlwKDEsMik7IHJldHVybiA0MDtcbmJyZWFrO1xuY2FzZSAzMTpyZXR1cm4gJ0lOVkFMSUQnO1xuYnJlYWs7XG5jYXNlIDMyOnJldHVybiA1O1xuYnJlYWs7XG59XG59O1xubGV4ZXIucnVsZXMgPSBbL14oPzpbXlxceDAwXSo/KD89KFxce1xceykpKS8sL14oPzpbXlxceDAwXSspLywvXig/OlteXFx4MDBdezIsfT8oPz0oXFx7XFx7fFxcXFxcXHtcXHt8XFxcXFxcXFxcXHtcXHt8JCkpKS8sL14oPzpbXFxzXFxTXSo/LS1cXH1cXH0pLywvXig/OlxcKCkvLC9eKD86XFwpKS8sL14oPzpcXHtcXHsofik/PikvLC9eKD86XFx7XFx7KH4pPyMpLywvXig/Olxce1xceyh+KT9cXC8pLywvXig/Olxce1xceyh+KT9cXF4pLywvXig/Olxce1xceyh+KT9cXHMqZWxzZVxcYikvLC9eKD86XFx7XFx7KH4pP1xceykvLC9eKD86XFx7XFx7KH4pPyYpLywvXig/Olxce1xceyEtLSkvLC9eKD86XFx7XFx7IVtcXHNcXFNdKj9cXH1cXH0pLywvXig/Olxce1xceyh+KT8pLywvXig/Oj0pLywvXig/OlxcLlxcLikvLC9eKD86XFwuKD89KFs9fn1cXHNcXC8uKV0pKSkvLC9eKD86W1xcLy5dKS8sL14oPzpcXHMrKS8sL14oPzpcXH0ofik/XFx9XFx9KS8sL14oPzoofik/XFx9XFx9KS8sL14oPzpcIihcXFxcW1wiXXxbXlwiXSkqXCIpLywvXig/OicoXFxcXFsnXXxbXiddKSonKS8sL14oPzpAKS8sL14oPzp0cnVlKD89KFt+fVxccyldKSkpLywvXig/OmZhbHNlKD89KFt+fVxccyldKSkpLywvXig/Oi0/WzAtOV0rKD89KFt+fVxccyldKSkpLywvXig/OihbXlxccyFcIiMlLSxcXC5cXC87LT5AXFxbLVxcXmBcXHstfl0rKD89KFs9fn1cXHNcXC8uKV0pKSkpLywvXig/OlxcW1teXFxdXSpcXF0pLywvXig/Oi4pLywvXig/OiQpL107XG5sZXhlci5jb25kaXRpb25zID0ge1wibXVcIjp7XCJydWxlc1wiOls0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCwyOSwzMCwzMSwzMl0sXCJpbmNsdXNpdmVcIjpmYWxzZX0sXCJlbXVcIjp7XCJydWxlc1wiOlsyXSxcImluY2x1c2l2ZVwiOmZhbHNlfSxcImNvbVwiOntcInJ1bGVzXCI6WzNdLFwiaW5jbHVzaXZlXCI6ZmFsc2V9LFwiSU5JVElBTFwiOntcInJ1bGVzXCI6WzAsMSwzMl0sXCJpbmNsdXNpdmVcIjp0cnVlfX07XG5yZXR1cm4gbGV4ZXI7fSkoKVxucGFyc2VyLmxleGVyID0gbGV4ZXI7XG5mdW5jdGlvbiBQYXJzZXIgKCkgeyB0aGlzLnl5ID0ge307IH1QYXJzZXIucHJvdG90eXBlID0gcGFyc2VyO3BhcnNlci5QYXJzZXIgPSBQYXJzZXI7XG5yZXR1cm4gbmV3IFBhcnNlcjtcbn0pKCk7ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBoYW5kbGViYXJzO1xuLyoganNoaW50IGlnbm9yZTplbmQgKi8iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBWaXNpdG9yID0gcmVxdWlyZShcIi4vdmlzaXRvclwiKVtcImRlZmF1bHRcIl07XG5cbmZ1bmN0aW9uIHByaW50KGFzdCkge1xuICByZXR1cm4gbmV3IFByaW50VmlzaXRvcigpLmFjY2VwdChhc3QpO1xufVxuXG5leHBvcnRzLnByaW50ID0gcHJpbnQ7ZnVuY3Rpb24gUHJpbnRWaXNpdG9yKCkge1xuICB0aGlzLnBhZGRpbmcgPSAwO1xufVxuXG5leHBvcnRzLlByaW50VmlzaXRvciA9IFByaW50VmlzaXRvcjtQcmludFZpc2l0b3IucHJvdG90eXBlID0gbmV3IFZpc2l0b3IoKTtcblxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5wYWQgPSBmdW5jdGlvbihzdHJpbmcsIG5ld2xpbmUpIHtcbiAgdmFyIG91dCA9IFwiXCI7XG5cbiAgZm9yKHZhciBpPTAsbD10aGlzLnBhZGRpbmc7IGk8bDsgaSsrKSB7XG4gICAgb3V0ID0gb3V0ICsgXCIgIFwiO1xuICB9XG5cbiAgb3V0ID0gb3V0ICsgc3RyaW5nO1xuXG4gIGlmKG5ld2xpbmUgIT09IGZhbHNlKSB7IG91dCA9IG91dCArIFwiXFxuXCI7IH1cbiAgcmV0dXJuIG91dDtcbn07XG5cblByaW50VmlzaXRvci5wcm90b3R5cGUucHJvZ3JhbSA9IGZ1bmN0aW9uKHByb2dyYW0pIHtcbiAgdmFyIG91dCA9IFwiXCIsXG4gICAgICBzdGF0ZW1lbnRzID0gcHJvZ3JhbS5zdGF0ZW1lbnRzLFxuICAgICAgaSwgbDtcblxuICBmb3IoaT0wLCBsPXN0YXRlbWVudHMubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgIG91dCA9IG91dCArIHRoaXMuYWNjZXB0KHN0YXRlbWVudHNbaV0pO1xuICB9XG5cbiAgdGhpcy5wYWRkaW5nLS07XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cblByaW50VmlzaXRvci5wcm90b3R5cGUuYmxvY2sgPSBmdW5jdGlvbihibG9jaykge1xuICB2YXIgb3V0ID0gXCJcIjtcblxuICBvdXQgPSBvdXQgKyB0aGlzLnBhZChcIkJMT0NLOlwiKTtcbiAgdGhpcy5wYWRkaW5nKys7XG4gIG91dCA9IG91dCArIHRoaXMuYWNjZXB0KGJsb2NrLm11c3RhY2hlKTtcbiAgaWYgKGJsb2NrLnByb2dyYW0pIHtcbiAgICBvdXQgPSBvdXQgKyB0aGlzLnBhZChcIlBST0dSQU06XCIpO1xuICAgIHRoaXMucGFkZGluZysrO1xuICAgIG91dCA9IG91dCArIHRoaXMuYWNjZXB0KGJsb2NrLnByb2dyYW0pO1xuICAgIHRoaXMucGFkZGluZy0tO1xuICB9XG4gIGlmIChibG9jay5pbnZlcnNlKSB7XG4gICAgaWYgKGJsb2NrLnByb2dyYW0pIHsgdGhpcy5wYWRkaW5nKys7IH1cbiAgICBvdXQgPSBvdXQgKyB0aGlzLnBhZChcInt7Xn19XCIpO1xuICAgIHRoaXMucGFkZGluZysrO1xuICAgIG91dCA9IG91dCArIHRoaXMuYWNjZXB0KGJsb2NrLmludmVyc2UpO1xuICAgIHRoaXMucGFkZGluZy0tO1xuICAgIGlmIChibG9jay5wcm9ncmFtKSB7IHRoaXMucGFkZGluZy0tOyB9XG4gIH1cbiAgdGhpcy5wYWRkaW5nLS07XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cblByaW50VmlzaXRvci5wcm90b3R5cGUuc2V4cHIgPSBmdW5jdGlvbihzZXhwcikge1xuICB2YXIgcGFyYW1zID0gc2V4cHIucGFyYW1zLCBwYXJhbVN0cmluZ3MgPSBbXSwgaGFzaDtcblxuICBmb3IodmFyIGk9MCwgbD1wYXJhbXMubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgIHBhcmFtU3RyaW5ncy5wdXNoKHRoaXMuYWNjZXB0KHBhcmFtc1tpXSkpO1xuICB9XG5cbiAgcGFyYW1zID0gXCJbXCIgKyBwYXJhbVN0cmluZ3Muam9pbihcIiwgXCIpICsgXCJdXCI7XG5cbiAgaGFzaCA9IHNleHByLmhhc2ggPyBcIiBcIiArIHRoaXMuYWNjZXB0KHNleHByLmhhc2gpIDogXCJcIjtcblxuICByZXR1cm4gdGhpcy5hY2NlcHQoc2V4cHIuaWQpICsgXCIgXCIgKyBwYXJhbXMgKyBoYXNoO1xufTtcblxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5tdXN0YWNoZSA9IGZ1bmN0aW9uKG11c3RhY2hlKSB7XG4gIHJldHVybiB0aGlzLnBhZChcInt7IFwiICsgdGhpcy5hY2NlcHQobXVzdGFjaGUuc2V4cHIpICsgXCIgfX1cIik7XG59O1xuXG5QcmludFZpc2l0b3IucHJvdG90eXBlLnBhcnRpYWwgPSBmdW5jdGlvbihwYXJ0aWFsKSB7XG4gIHZhciBjb250ZW50ID0gdGhpcy5hY2NlcHQocGFydGlhbC5wYXJ0aWFsTmFtZSk7XG4gIGlmKHBhcnRpYWwuY29udGV4dCkgeyBjb250ZW50ID0gY29udGVudCArIFwiIFwiICsgdGhpcy5hY2NlcHQocGFydGlhbC5jb250ZXh0KTsgfVxuICByZXR1cm4gdGhpcy5wYWQoXCJ7ez4gXCIgKyBjb250ZW50ICsgXCIgfX1cIik7XG59O1xuXG5QcmludFZpc2l0b3IucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbihoYXNoKSB7XG4gIHZhciBwYWlycyA9IGhhc2gucGFpcnM7XG4gIHZhciBqb2luZWRQYWlycyA9IFtdLCBsZWZ0LCByaWdodDtcblxuICBmb3IodmFyIGk9MCwgbD1wYWlycy5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgbGVmdCA9IHBhaXJzW2ldWzBdO1xuICAgIHJpZ2h0ID0gdGhpcy5hY2NlcHQocGFpcnNbaV1bMV0pO1xuICAgIGpvaW5lZFBhaXJzLnB1c2goIGxlZnQgKyBcIj1cIiArIHJpZ2h0ICk7XG4gIH1cblxuICByZXR1cm4gXCJIQVNIe1wiICsgam9pbmVkUGFpcnMuam9pbihcIiwgXCIpICsgXCJ9XCI7XG59O1xuXG5QcmludFZpc2l0b3IucHJvdG90eXBlLlNUUklORyA9IGZ1bmN0aW9uKHN0cmluZykge1xuICByZXR1cm4gJ1wiJyArIHN0cmluZy5zdHJpbmcgKyAnXCInO1xufTtcblxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5JTlRFR0VSID0gZnVuY3Rpb24oaW50ZWdlcikge1xuICByZXR1cm4gXCJJTlRFR0VSe1wiICsgaW50ZWdlci5pbnRlZ2VyICsgXCJ9XCI7XG59O1xuXG5QcmludFZpc2l0b3IucHJvdG90eXBlLkJPT0xFQU4gPSBmdW5jdGlvbihib29sKSB7XG4gIHJldHVybiBcIkJPT0xFQU57XCIgKyBib29sLmJvb2wgKyBcIn1cIjtcbn07XG5cblByaW50VmlzaXRvci5wcm90b3R5cGUuSUQgPSBmdW5jdGlvbihpZCkge1xuICB2YXIgcGF0aCA9IGlkLnBhcnRzLmpvaW4oXCIvXCIpO1xuICBpZihpZC5wYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIFwiUEFUSDpcIiArIHBhdGg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiSUQ6XCIgKyBwYXRoO1xuICB9XG59O1xuXG5QcmludFZpc2l0b3IucHJvdG90eXBlLlBBUlRJQUxfTkFNRSA9IGZ1bmN0aW9uKHBhcnRpYWxOYW1lKSB7XG4gICAgcmV0dXJuIFwiUEFSVElBTDpcIiArIHBhcnRpYWxOYW1lLm5hbWU7XG59O1xuXG5QcmludFZpc2l0b3IucHJvdG90eXBlLkRBVEEgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHJldHVybiBcIkBcIiArIHRoaXMuYWNjZXB0KGRhdGEuaWQpO1xufTtcblxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5jb250ZW50ID0gZnVuY3Rpb24oY29udGVudCkge1xuICByZXR1cm4gdGhpcy5wYWQoXCJDT05URU5UWyAnXCIgKyBjb250ZW50LnN0cmluZyArIFwiJyBdXCIpO1xufTtcblxuUHJpbnRWaXNpdG9yLnByb3RvdHlwZS5jb21tZW50ID0gZnVuY3Rpb24oY29tbWVudCkge1xuICByZXR1cm4gdGhpcy5wYWQoXCJ7eyEgJ1wiICsgY29tbWVudC5jb21tZW50ICsgXCInIH19XCIpO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIFZpc2l0b3IoKSB7fVxuXG5WaXNpdG9yLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFZpc2l0b3IsXG5cbiAgYWNjZXB0OiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gdGhpc1tvYmplY3QudHlwZV0ob2JqZWN0KTtcbiAgfVxufTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBWaXNpdG9yOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZXJyb3JQcm9wcyA9IFsnZGVzY3JpcHRpb24nLCAnZmlsZU5hbWUnLCAnbGluZU51bWJlcicsICdtZXNzYWdlJywgJ25hbWUnLCAnbnVtYmVyJywgJ3N0YWNrJ107XG5cbmZ1bmN0aW9uIEV4Y2VwdGlvbihtZXNzYWdlLCBub2RlKSB7XG4gIHZhciBsaW5lO1xuICBpZiAobm9kZSAmJiBub2RlLmZpcnN0TGluZSkge1xuICAgIGxpbmUgPSBub2RlLmZpcnN0TGluZTtcblxuICAgIG1lc3NhZ2UgKz0gJyAtICcgKyBsaW5lICsgJzonICsgbm9kZS5maXJzdENvbHVtbjtcbiAgfVxuXG4gIHZhciB0bXAgPSBFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcblxuICAvLyBVbmZvcnR1bmF0ZWx5IGVycm9ycyBhcmUgbm90IGVudW1lcmFibGUgaW4gQ2hyb21lIChhdCBsZWFzdCksIHNvIGBmb3IgcHJvcCBpbiB0bXBgIGRvZXNuJ3Qgd29yay5cbiAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgZXJyb3JQcm9wcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgdGhpc1tlcnJvclByb3BzW2lkeF1dID0gdG1wW2Vycm9yUHJvcHNbaWR4XV07XG4gIH1cblxuICBpZiAobGluZSkge1xuICAgIHRoaXMubGluZU51bWJlciA9IGxpbmU7XG4gICAgdGhpcy5jb2x1bW4gPSBub2RlLmZpcnN0Q29sdW1uO1xuICB9XG59XG5cbkV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBFeGNlcHRpb247IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgVXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBFeGNlcHRpb24gPSByZXF1aXJlKFwiLi9leGNlcHRpb25cIilbXCJkZWZhdWx0XCJdO1xudmFyIENPTVBJTEVSX1JFVklTSU9OID0gcmVxdWlyZShcIi4vYmFzZVwiKS5DT01QSUxFUl9SRVZJU0lPTjtcbnZhciBSRVZJU0lPTl9DSEFOR0VTID0gcmVxdWlyZShcIi4vYmFzZVwiKS5SRVZJU0lPTl9DSEFOR0VTO1xuXG5mdW5jdGlvbiBjaGVja1JldmlzaW9uKGNvbXBpbGVySW5mbykge1xuICB2YXIgY29tcGlsZXJSZXZpc2lvbiA9IGNvbXBpbGVySW5mbyAmJiBjb21waWxlckluZm9bMF0gfHwgMSxcbiAgICAgIGN1cnJlbnRSZXZpc2lvbiA9IENPTVBJTEVSX1JFVklTSU9OO1xuXG4gIGlmIChjb21waWxlclJldmlzaW9uICE9PSBjdXJyZW50UmV2aXNpb24pIHtcbiAgICBpZiAoY29tcGlsZXJSZXZpc2lvbiA8IGN1cnJlbnRSZXZpc2lvbikge1xuICAgICAgdmFyIHJ1bnRpbWVWZXJzaW9ucyA9IFJFVklTSU9OX0NIQU5HRVNbY3VycmVudFJldmlzaW9uXSxcbiAgICAgICAgICBjb21waWxlclZlcnNpb25zID0gUkVWSVNJT05fQ0hBTkdFU1tjb21waWxlclJldmlzaW9uXTtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oXCJUZW1wbGF0ZSB3YXMgcHJlY29tcGlsZWQgd2l0aCBhbiBvbGRlciB2ZXJzaW9uIG9mIEhhbmRsZWJhcnMgdGhhbiB0aGUgY3VycmVudCBydW50aW1lLiBcIitcbiAgICAgICAgICAgIFwiUGxlYXNlIHVwZGF0ZSB5b3VyIHByZWNvbXBpbGVyIHRvIGEgbmV3ZXIgdmVyc2lvbiAoXCIrcnVudGltZVZlcnNpb25zK1wiKSBvciBkb3duZ3JhZGUgeW91ciBydW50aW1lIHRvIGFuIG9sZGVyIHZlcnNpb24gKFwiK2NvbXBpbGVyVmVyc2lvbnMrXCIpLlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXNlIHRoZSBlbWJlZGRlZCB2ZXJzaW9uIGluZm8gc2luY2UgdGhlIHJ1bnRpbWUgZG9lc24ndCBrbm93IGFib3V0IHRoaXMgcmV2aXNpb24geWV0XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFwiVGVtcGxhdGUgd2FzIHByZWNvbXBpbGVkIHdpdGggYSBuZXdlciB2ZXJzaW9uIG9mIEhhbmRsZWJhcnMgdGhhbiB0aGUgY3VycmVudCBydW50aW1lLiBcIitcbiAgICAgICAgICAgIFwiUGxlYXNlIHVwZGF0ZSB5b3VyIHJ1bnRpbWUgdG8gYSBuZXdlciB2ZXJzaW9uIChcIitjb21waWxlckluZm9bMV0rXCIpLlwiKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5jaGVja1JldmlzaW9uID0gY2hlY2tSZXZpc2lvbjsvLyBUT0RPOiBSZW1vdmUgdGhpcyBsaW5lIGFuZCBicmVhayB1cCBjb21waWxlUGFydGlhbFxuXG5mdW5jdGlvbiB0ZW1wbGF0ZSh0ZW1wbGF0ZVNwZWMsIGVudikge1xuICBpZiAoIWVudikge1xuICAgIHRocm93IG5ldyBFeGNlcHRpb24oXCJObyBlbnZpcm9ubWVudCBwYXNzZWQgdG8gdGVtcGxhdGVcIik7XG4gIH1cblxuICAvLyBOb3RlOiBVc2luZyBlbnYuVk0gcmVmZXJlbmNlcyByYXRoZXIgdGhhbiBsb2NhbCB2YXIgcmVmZXJlbmNlcyB0aHJvdWdob3V0IHRoaXMgc2VjdGlvbiB0byBhbGxvd1xuICAvLyBmb3IgZXh0ZXJuYWwgdXNlcnMgdG8gb3ZlcnJpZGUgdGhlc2UgYXMgcHN1ZWRvLXN1cHBvcnRlZCBBUElzLlxuICB2YXIgaW52b2tlUGFydGlhbFdyYXBwZXIgPSBmdW5jdGlvbihwYXJ0aWFsLCBuYW1lLCBjb250ZXh0LCBoZWxwZXJzLCBwYXJ0aWFscywgZGF0YSkge1xuICAgIHZhciByZXN1bHQgPSBlbnYuVk0uaW52b2tlUGFydGlhbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXN1bHQgIT0gbnVsbCkgeyByZXR1cm4gcmVzdWx0OyB9XG5cbiAgICBpZiAoZW52LmNvbXBpbGUpIHtcbiAgICAgIHZhciBvcHRpb25zID0geyBoZWxwZXJzOiBoZWxwZXJzLCBwYXJ0aWFsczogcGFydGlhbHMsIGRhdGE6IGRhdGEgfTtcbiAgICAgIHBhcnRpYWxzW25hbWVdID0gZW52LmNvbXBpbGUocGFydGlhbCwgeyBkYXRhOiBkYXRhICE9PSB1bmRlZmluZWQgfSwgZW52KTtcbiAgICAgIHJldHVybiBwYXJ0aWFsc1tuYW1lXShjb250ZXh0LCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihcIlRoZSBwYXJ0aWFsIFwiICsgbmFtZSArIFwiIGNvdWxkIG5vdCBiZSBjb21waWxlZCB3aGVuIHJ1bm5pbmcgaW4gcnVudGltZS1vbmx5IG1vZGVcIik7XG4gICAgfVxuICB9O1xuXG4gIC8vIEp1c3QgYWRkIHdhdGVyXG4gIHZhciBjb250YWluZXIgPSB7XG4gICAgZXNjYXBlRXhwcmVzc2lvbjogVXRpbHMuZXNjYXBlRXhwcmVzc2lvbixcbiAgICBpbnZva2VQYXJ0aWFsOiBpbnZva2VQYXJ0aWFsV3JhcHBlcixcbiAgICBwcm9ncmFtczogW10sXG4gICAgcHJvZ3JhbTogZnVuY3Rpb24oaSwgZm4sIGRhdGEpIHtcbiAgICAgIHZhciBwcm9ncmFtV3JhcHBlciA9IHRoaXMucHJvZ3JhbXNbaV07XG4gICAgICBpZihkYXRhKSB7XG4gICAgICAgIHByb2dyYW1XcmFwcGVyID0gcHJvZ3JhbShpLCBmbiwgZGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKCFwcm9ncmFtV3JhcHBlcikge1xuICAgICAgICBwcm9ncmFtV3JhcHBlciA9IHRoaXMucHJvZ3JhbXNbaV0gPSBwcm9ncmFtKGksIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9ncmFtV3JhcHBlcjtcbiAgICB9LFxuICAgIG1lcmdlOiBmdW5jdGlvbihwYXJhbSwgY29tbW9uKSB7XG4gICAgICB2YXIgcmV0ID0gcGFyYW0gfHwgY29tbW9uO1xuXG4gICAgICBpZiAocGFyYW0gJiYgY29tbW9uICYmIChwYXJhbSAhPT0gY29tbW9uKSkge1xuICAgICAgICByZXQgPSB7fTtcbiAgICAgICAgVXRpbHMuZXh0ZW5kKHJldCwgY29tbW9uKTtcbiAgICAgICAgVXRpbHMuZXh0ZW5kKHJldCwgcGFyYW0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuICAgIHByb2dyYW1XaXRoRGVwdGg6IGVudi5WTS5wcm9ncmFtV2l0aERlcHRoLFxuICAgIG5vb3A6IGVudi5WTS5ub29wLFxuICAgIGNvbXBpbGVySW5mbzogbnVsbFxuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIG5hbWVzcGFjZSA9IG9wdGlvbnMucGFydGlhbCA/IG9wdGlvbnMgOiBlbnYsXG4gICAgICAgIGhlbHBlcnMsXG4gICAgICAgIHBhcnRpYWxzO1xuXG4gICAgaWYgKCFvcHRpb25zLnBhcnRpYWwpIHtcbiAgICAgIGhlbHBlcnMgPSBvcHRpb25zLmhlbHBlcnM7XG4gICAgICBwYXJ0aWFscyA9IG9wdGlvbnMucGFydGlhbHM7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB0ZW1wbGF0ZVNwZWMuY2FsbChcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgbmFtZXNwYWNlLCBjb250ZXh0LFxuICAgICAgICAgIGhlbHBlcnMsXG4gICAgICAgICAgcGFydGlhbHMsXG4gICAgICAgICAgb3B0aW9ucy5kYXRhKTtcblxuICAgIGlmICghb3B0aW9ucy5wYXJ0aWFsKSB7XG4gICAgICBlbnYuVk0uY2hlY2tSZXZpc2lvbihjb250YWluZXIuY29tcGlsZXJJbmZvKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5leHBvcnRzLnRlbXBsYXRlID0gdGVtcGxhdGU7ZnVuY3Rpb24gcHJvZ3JhbVdpdGhEZXB0aChpLCBmbiwgZGF0YSAvKiwgJGRlcHRoICovKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcblxuICB2YXIgcHJvZyA9IGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBbY29udGV4dCwgb3B0aW9ucy5kYXRhIHx8IGRhdGFdLmNvbmNhdChhcmdzKSk7XG4gIH07XG4gIHByb2cucHJvZ3JhbSA9IGk7XG4gIHByb2cuZGVwdGggPSBhcmdzLmxlbmd0aDtcbiAgcmV0dXJuIHByb2c7XG59XG5cbmV4cG9ydHMucHJvZ3JhbVdpdGhEZXB0aCA9IHByb2dyYW1XaXRoRGVwdGg7ZnVuY3Rpb24gcHJvZ3JhbShpLCBmbiwgZGF0YSkge1xuICB2YXIgcHJvZyA9IGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHJldHVybiBmbihjb250ZXh0LCBvcHRpb25zLmRhdGEgfHwgZGF0YSk7XG4gIH07XG4gIHByb2cucHJvZ3JhbSA9IGk7XG4gIHByb2cuZGVwdGggPSAwO1xuICByZXR1cm4gcHJvZztcbn1cblxuZXhwb3J0cy5wcm9ncmFtID0gcHJvZ3JhbTtmdW5jdGlvbiBpbnZva2VQYXJ0aWFsKHBhcnRpYWwsIG5hbWUsIGNvbnRleHQsIGhlbHBlcnMsIHBhcnRpYWxzLCBkYXRhKSB7XG4gIHZhciBvcHRpb25zID0geyBwYXJ0aWFsOiB0cnVlLCBoZWxwZXJzOiBoZWxwZXJzLCBwYXJ0aWFsczogcGFydGlhbHMsIGRhdGE6IGRhdGEgfTtcblxuICBpZihwYXJ0aWFsID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFwiVGhlIHBhcnRpYWwgXCIgKyBuYW1lICsgXCIgY291bGQgbm90IGJlIGZvdW5kXCIpO1xuICB9IGVsc2UgaWYocGFydGlhbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIHBhcnRpYWwoY29udGV4dCwgb3B0aW9ucyk7XG4gIH1cbn1cblxuZXhwb3J0cy5pbnZva2VQYXJ0aWFsID0gaW52b2tlUGFydGlhbDtmdW5jdGlvbiBub29wKCkgeyByZXR1cm4gXCJcIjsgfVxuXG5leHBvcnRzLm5vb3AgPSBub29wOyIsIlwidXNlIHN0cmljdFwiO1xuLy8gQnVpbGQgb3V0IG91ciBiYXNpYyBTYWZlU3RyaW5nIHR5cGVcbmZ1bmN0aW9uIFNhZmVTdHJpbmcoc3RyaW5nKSB7XG4gIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xufVxuXG5TYWZlU3RyaW5nLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXCJcIiArIHRoaXMuc3RyaW5nO1xufTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBTYWZlU3RyaW5nOyIsIlwidXNlIHN0cmljdFwiO1xuLypqc2hpbnQgLVcwMDQgKi9cbnZhciBTYWZlU3RyaW5nID0gcmVxdWlyZShcIi4vc2FmZS1zdHJpbmdcIilbXCJkZWZhdWx0XCJdO1xuXG52YXIgZXNjYXBlID0ge1xuICBcIiZcIjogXCImYW1wO1wiLFxuICBcIjxcIjogXCImbHQ7XCIsXG4gIFwiPlwiOiBcIiZndDtcIixcbiAgJ1wiJzogXCImcXVvdDtcIixcbiAgXCInXCI6IFwiJiN4Mjc7XCIsXG4gIFwiYFwiOiBcIiYjeDYwO1wiXG59O1xuXG52YXIgYmFkQ2hhcnMgPSAvWyY8PlwiJ2BdL2c7XG52YXIgcG9zc2libGUgPSAvWyY8PlwiJ2BdLztcblxuZnVuY3Rpb24gZXNjYXBlQ2hhcihjaHIpIHtcbiAgcmV0dXJuIGVzY2FwZVtjaHJdIHx8IFwiJmFtcDtcIjtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKG9iaiwgdmFsdWUpIHtcbiAgZm9yKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWVba2V5XTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7dmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmV4cG9ydHMudG9TdHJpbmcgPSB0b1N0cmluZztcbi8vIFNvdXJjZWQgZnJvbSBsb2Rhc2hcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXN0aWVqcy9sb2Rhc2gvYmxvYi9tYXN0ZXIvTElDRU5TRS50eHRcbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn07XG4vLyBmYWxsYmFjayBmb3Igb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmlcbmlmIChpc0Z1bmN0aW9uKC94LykpIHtcbiAgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgfTtcbn1cbnZhciBpc0Z1bmN0aW9uO1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpID8gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScgOiBmYWxzZTtcbn07XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBlc2NhcGVFeHByZXNzaW9uKHN0cmluZykge1xuICAvLyBkb24ndCBlc2NhcGUgU2FmZVN0cmluZ3MsIHNpbmNlIHRoZXkncmUgYWxyZWFkeSBzYWZlXG4gIGlmIChzdHJpbmcgaW5zdGFuY2VvZiBTYWZlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy50b1N0cmluZygpO1xuICB9IGVsc2UgaWYgKCFzdHJpbmcgJiYgc3RyaW5nICE9PSAwKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cblxuICAvLyBGb3JjZSBhIHN0cmluZyBjb252ZXJzaW9uIGFzIHRoaXMgd2lsbCBiZSBkb25lIGJ5IHRoZSBhcHBlbmQgcmVnYXJkbGVzcyBhbmRcbiAgLy8gdGhlIHJlZ2V4IHRlc3Qgd2lsbCBkbyB0aGlzIHRyYW5zcGFyZW50bHkgYmVoaW5kIHRoZSBzY2VuZXMsIGNhdXNpbmcgaXNzdWVzIGlmXG4gIC8vIGFuIG9iamVjdCdzIHRvIHN0cmluZyBoYXMgZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGl0LlxuICBzdHJpbmcgPSBcIlwiICsgc3RyaW5nO1xuXG4gIGlmKCFwb3NzaWJsZS50ZXN0KHN0cmluZykpIHsgcmV0dXJuIHN0cmluZzsgfVxuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoYmFkQ2hhcnMsIGVzY2FwZUNoYXIpO1xufVxuXG5leHBvcnRzLmVzY2FwZUV4cHJlc3Npb24gPSBlc2NhcGVFeHByZXNzaW9uO2Z1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnRzLmlzRW1wdHkgPSBpc0VtcHR5OyIsIi8vIFVTQUdFOlxuLy8gdmFyIGhhbmRsZWJhcnMgPSByZXF1aXJlKCdoYW5kbGViYXJzJyk7XG5cbi8vIHZhciBsb2NhbCA9IGhhbmRsZWJhcnMuY3JlYXRlKCk7XG5cbnZhciBoYW5kbGViYXJzID0gcmVxdWlyZSgnLi4vZGlzdC9janMvaGFuZGxlYmFycycpW1wiZGVmYXVsdFwiXTtcblxuaGFuZGxlYmFycy5WaXNpdG9yID0gcmVxdWlyZSgnLi4vZGlzdC9janMvaGFuZGxlYmFycy9jb21waWxlci92aXNpdG9yJylbXCJkZWZhdWx0XCJdO1xuXG52YXIgcHJpbnRlciA9IHJlcXVpcmUoJy4uL2Rpc3QvY2pzL2hhbmRsZWJhcnMvY29tcGlsZXIvcHJpbnRlcicpO1xuaGFuZGxlYmFycy5QcmludFZpc2l0b3IgPSBwcmludGVyLlByaW50VmlzaXRvcjtcbmhhbmRsZWJhcnMucHJpbnQgPSBwcmludGVyLnByaW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhbmRsZWJhcnM7XG5cbi8vIFB1Ymxpc2ggYSBOb2RlLmpzIHJlcXVpcmUoKSBoYW5kbGVyIGZvciAuaGFuZGxlYmFycyBhbmQgLmhicyBmaWxlc1xuaWYgKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJyAmJiByZXF1aXJlLmV4dGVuc2lvbnMpIHtcbiAgdmFyIGV4dGVuc2lvbiA9IGZ1bmN0aW9uKG1vZHVsZSwgZmlsZW5hbWUpIHtcbiAgICB2YXIgZnMgPSByZXF1aXJlKFwiZnNcIik7XG4gICAgdmFyIHRlbXBsYXRlU3RyaW5nID0gZnMucmVhZEZpbGVTeW5jKGZpbGVuYW1lLCBcInV0ZjhcIik7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBoYW5kbGViYXJzLmNvbXBpbGUodGVtcGxhdGVTdHJpbmcpO1xuICB9O1xuICByZXF1aXJlLmV4dGVuc2lvbnNbXCIuaGFuZGxlYmFyc1wiXSA9IGV4dGVuc2lvbjtcbiAgcmVxdWlyZS5leHRlbnNpb25zW1wiLmhic1wiXSA9IGV4dGVuc2lvbjtcbn1cbiIsIi8vIENyZWF0ZSBhIHNpbXBsZSBwYXRoIGFsaWFzIHRvIGFsbG93IGJyb3dzZXJpZnkgdG8gcmVzb2x2ZVxuLy8gdGhlIHJ1bnRpbWUgb24gYSBzdXBwb3J0ZWQgcGF0aC5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2Nqcy9oYW5kbGViYXJzLnJ1bnRpbWUnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImhhbmRsZWJhcnMvcnVudGltZVwiKVtcImRlZmF1bHRcIl07XG4iLCIvKlxuICAgIEhlYXZpbHkgaW5zcGlyZWQgYnkgdGhlIG9yaWdpbmFsIGpzIGxpYnJhcnkgY29weXJpZ2h0IE1peHBhbmVsLCBJbmMuXG4gICAgKGh0dHA6Ly9taXhwYW5lbC5jb20vKVxuXG4gICAgQ29weXJpZ2h0IChjKSAyMDEyIENhcmwgU3ZlcnJlXG5cbiAgICBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xuXG52YXIgaHR0cCAgICAgICAgICAgID0gcmVxdWlyZSgnaHR0cCcpLFxuICAgIHF1ZXJ5c3RyaW5nICAgICA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyksXG4gICAgQnVmZmVyICAgICAgICAgID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyLFxuICAgIHV0aWwgICAgICAgICAgICA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIGNyZWF0ZV9jbGllbnQgPSBmdW5jdGlvbih0b2tlbiwgY29uZmlnKSB7XG4gICAgdmFyIG1ldHJpY3MgPSB7fTtcblxuICAgIGlmKCF0b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgTWl4cGFuZWwgQ2xpZW50IG5lZWRzIGEgTWl4cGFuZWwgdG9rZW46IGBpbml0KHRva2VuKWBcIik7XG4gICAgfVxuXG4gICAgbWV0cmljcy5jb25maWcgPSB7XG4gICAgICAgIHRlc3Q6IGZhbHNlLFxuICAgICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICAgIHZlcmJvc2U6IGZhbHNlXG4gICAgfTtcblxuICAgIG1ldHJpY3MudG9rZW4gPSB0b2tlbjtcblxuICAgIC8qKlxuICAgICAgICBzZW5kX3JlcXVlc3QoZGF0YSlcbiAgICAgICAgLS0tXG4gICAgICAgIHRoaXMgZnVuY3Rpb24gc2VuZHMgYW4gYXN5bmMgR0VUIHJlcXVlc3QgdG8gbWl4cGFuZWxcblxuICAgICAgICBkYXRhOm9iamVjdCAgICAgICAgICAgICAgICAgICAgIHRoZSBkYXRhIHRvIHNlbmQgaW4gdGhlIHJlcXVlc3RcbiAgICAgICAgY2FsbGJhY2s6ZnVuY3Rpb24oZXJyOkVycm9yKSAgICBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgcmVxdWVzdCBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkIG9yIGFuIGVycm9yIG9jY3Vyc1xuICAgICovXG4gICAgbWV0cmljcy5zZW5kX3JlcXVlc3QgPSBmdW5jdGlvbihlbmRwb2ludCwgZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xuICAgICAgICB2YXIgZXZlbnRfZGF0YSA9IG5ldyBCdWZmZXIoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgICAgICB2YXIgcmVxdWVzdF9kYXRhID0ge1xuICAgICAgICAgICAgJ2RhdGEnOiBldmVudF9kYXRhLnRvU3RyaW5nKCdiYXNlNjQnKSxcbiAgICAgICAgICAgICdpcCc6IDAsXG4gICAgICAgICAgICAndmVyYm9zZSc6IG1ldHJpY3MuY29uZmlnLnZlcmJvc2UgPyAxIDogMFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChlbmRwb2ludCA9PT0gJy9pbXBvcnQnKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gbWV0cmljcy5jb25maWcua2V5O1xuICAgICAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgTWl4cGFuZWwgQ2xpZW50IG5lZWRzIGEgTWl4cGFuZWwgYXBpIGtleSB3aGVuIGltcG9ydGluZyBvbGQgZXZlbnRzOiBgaW5pdCh0b2tlbiwgeyBrZXk6IC4uLiB9KWBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0X2RhdGEuYXBpX2tleSA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXF1ZXN0X29wdGlvbnMgPSB7XG4gICAgICAgICAgICBob3N0OiAnYXBpLm1peHBhbmVsLmNvbScsIFxuICAgICAgICAgICAgaGVhZGVyczoge31cbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0X29wdGlvbnMgPSBfZXh0ZW5kKHJlcXVlc3Rfb3B0aW9ucywgbWV0cmljcy5jb25maWcucmVxdWVzdF9vcHRpb25zKTtcblxuICAgICAgICBpZiAobWV0cmljcy5jb25maWcudGVzdCkgeyByZXF1ZXN0X2RhdGEudGVzdCA9IDE7IH1cblxuICAgICAgICB2YXIgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkocmVxdWVzdF9kYXRhKTtcblxuICAgICAgICByZXF1ZXN0X29wdGlvbnMucGF0aCA9IFtlbmRwb2ludCxcIj9cIixxdWVyeV0uam9pbihcIlwiKTtcblxuICAgICAgICBodHRwLmdldChyZXF1ZXN0X29wdGlvbnMsIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBcIlwiO1xuICAgICAgICAgICAgcmVzLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICAgICAgIGRhdGEgKz0gY2h1bms7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVzLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZTtcbiAgICAgICAgICAgICAgICBpZihtZXRyaWNzLmNvbmZpZy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdC5zdGF0dXMgIT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBuZXcgRXJyb3IoXCJNaXhwYW5lbCBTZXJ2ZXIgRXJyb3I6IFwiICsgcmVzdWx0LmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwYXJzZSByZXNwb25zZSBmcm9tIE1peHBhbmVsXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlID0gKGRhdGEgIT09ICcxJykgPyBuZXcgRXJyb3IoXCJNaXhwYW5lbCBTZXJ2ZXIgRXJyb3I6IFwiICsgZGF0YSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkub24oJ2Vycm9yJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYobWV0cmljcy5jb25maWcuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkdvdCBFcnJvcjogXCIgKyBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgICAgdHJhY2soZXZlbnQsIHByb3BlcnRpZXMsIGNhbGxiYWNrKVxuICAgICAgICAtLS1cbiAgICAgICAgdGhpcyBmdW5jdGlvbiBzZW5kcyBhbiBldmVudCB0byBtaXhwYW5lbC5cblxuICAgICAgICBldmVudDpzdHJpbmcgICAgICAgICAgICAgICAgICAgIHRoZSBldmVudCBuYW1lXG4gICAgICAgIHByb3BlcnRpZXM6b2JqZWN0ICAgICAgICAgICAgICAgYWRkaXRpb25hbCBldmVudCBwcm9wZXJ0aWVzIHRvIHNlbmRcbiAgICAgICAgY2FsbGJhY2s6ZnVuY3Rpb24oZXJyOkVycm9yKSAgICBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgcmVxdWVzdCBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkIG9yIGFuIGVycm9yIG9jY3Vyc1xuICAgICovXG4gICAgbWV0cmljcy50cmFjayA9IGZ1bmN0aW9uKGV2ZW50LCBwcm9wZXJ0aWVzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mKHByb3BlcnRpZXMpID09PSAnZnVuY3Rpb24nIHx8ICFwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHByb3BlcnRpZXM7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBwcm9wZXJ0aWVzLnRpbWUgZXhpc3RzLCB1c2UgaW1wb3J0IGVuZHBvaW50XG4gICAgICAgIHZhciBlbmRwb2ludCA9ICh0eXBlb2YocHJvcGVydGllcy50aW1lKSA9PT0gJ251bWJlcicpID8gJy9pbXBvcnQnIDogJy90cmFjayc7XG5cbiAgICAgICAgcHJvcGVydGllcy50b2tlbiA9IG1ldHJpY3MudG9rZW47XG4gICAgICAgIHByb3BlcnRpZXMubXBfbGliID0gXCJub2RlXCI7XG5cbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAnZXZlbnQnIDogZXZlbnQsXG4gICAgICAgICAgICAncHJvcGVydGllcycgOiBwcm9wZXJ0aWVzXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1ldHJpY3MuY29uZmlnLmRlYnVnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNlbmRpbmcgdGhlIGZvbGxvd2luZyBldmVudCB0byBNaXhwYW5lbDpcIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1ldHJpY3Muc2VuZF9yZXF1ZXN0KGVuZHBvaW50LCBkYXRhLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAgICBpbXBvcnQoZXZlbnQsIHByb3BlcnRpZXMsIGNhbGxiYWNrKVxuICAgICAgICAtLS1cbiAgICAgICAgVGhpcyBmdW5jdGlvbiBzZW5kcyBhbiBldmVudCB0byBtaXhwYW5lbCB1c2luZyB0aGUgaW1wb3J0XG4gICAgICAgIGVuZHBvaW50LiAgVGhlIHRpbWUgYXJndW1lbnQgc2hvdWxkIGJlIGVpdGhlciBhIERhdGUgb3IgTnVtYmVyLFxuICAgICAgICBhbmQgc2hvdWxkIHNpZ25pZnkgdGhlIHRpbWUgdGhlIGV2ZW50IG9jY3VycmVkLlxuXG4gICAgICAgIEl0IGlzIGhpZ2hseSByZWNvbW1lbmRlZCB0aGF0IHlvdSBzcGVjaWZ5IHRoZSBkaXN0aW5jdF9pZFxuICAgICAgICBwcm9wZXJ0eSBmb3IgZWFjaCBldmVudCB5b3UgaW1wb3J0LCBvdGhlcndpc2UgdGhlIGV2ZW50cyB3aWxsIGJlXG4gICAgICAgIHRpZWQgdG8gdGhlIElQIGFkZHJlc3Mgb2YgdGhlIHNlbmRpbmcgbWFjaGluZS5cblxuICAgICAgICBGb3IgbW9yZSBpbmZvcm1hdGlvbiBsb29rIGF0OlxuICAgICAgICBodHRwczovL21peHBhbmVsLmNvbS9kb2NzL2FwaS1kb2N1bWVudGF0aW9uL2ltcG9ydGluZy1ldmVudHMtb2xkZXItdGhhbi0zMS1kYXlzXG5cbiAgICAgICAgZXZlbnQ6c3RyaW5nICAgICAgICAgICAgICAgICAgICB0aGUgZXZlbnQgbmFtZVxuICAgICAgICB0aW1lOmRhdGV8bnVtYmVyICAgICAgICAgICAgICAgIHRoZSB0aW1lIG9mIHRoZSBldmVudFxuICAgICAgICBwcm9wZXJ0aWVzOm9iamVjdCAgICAgICAgICAgICAgIGFkZGl0aW9uYWwgZXZlbnQgcHJvcGVydGllcyB0byBzZW5kXG4gICAgICAgIGNhbGxiYWNrOmZ1bmN0aW9uKGVycjpFcnJvcikgICAgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIHJlcXVlc3QgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZCBvciBhbiBlcnJvciBvY2N1cnNcbiAgICAqL1xuICAgIG1ldHJpY3MuaW1wb3J0ID0gZnVuY3Rpb24oZXZlbnQsIHRpbWUsIHByb3BlcnRpZXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YocHJvcGVydGllcykgPT09ICdmdW5jdGlvbicgfHwgIXByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gcHJvcGVydGllcztcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aW1lID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBpbXBvcnQgbWV0aG9kIHJlcXVpcmVzIHlvdSB0byBzcGVjaWZ5IHRoZSB0aW1lIG9mIHRoZSBldmVudFwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGltZSkgPT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgICAgICAgICAgdGltZSA9IE1hdGguZmxvb3IodGltZS5nZXRUaW1lKCkgLyAxMDAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3BlcnRpZXMudGltZSA9IHRpbWU7XG5cbiAgICAgICAgbWV0cmljcy50cmFjayhldmVudCwgcHJvcGVydGllcywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgICAgYWxpYXMoZGlzdGluY3RfaWQsIGFsaWFzKVxuICAgICAgICAtLS1cbiAgICAgICAgVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGFuIGFsaWFzIGZvciBkaXN0aW5jdF9pZFxuXG4gICAgICAgIEZvciBtb3JlIGluZm9ybWF0aW9uIGxvb2sgYXQ6XG4gICAgICAgIGh0dHBzOi8vbWl4cGFuZWwuY29tL2RvY3MvaW50ZWdyYXRpb24tbGlicmFyaWVzL3VzaW5nLW1peHBhbmVsLWFsaWFzXG5cbiAgICAgICAgZGlzdGluY3RfaWQ6c3RyaW5nICAgICAgICAgICAgICB0aGUgY3VycmVudCBpZGVudGlmaWVyXG4gICAgICAgIGFsaWFzOnN0cmluZyAgICAgICAgICAgICAgICAgICAgdGhlIGZ1dHVyZSBhbGlhc1xuICAgICovXG4gICAgbWV0cmljcy5hbGlhcyA9IGZ1bmN0aW9uKGRpc3RpbmN0X2lkLCBhbGlhcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBkaXN0aW5jdF9pZDogZGlzdGluY3RfaWQsXG4gICAgICAgICAgICBhbGlhczogYWxpYXNcbiAgICAgICAgfTtcblxuICAgICAgICBtZXRyaWNzLnRyYWNrKCckY3JlYXRlX2FsaWFzJywgcHJvcGVydGllcywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBtZXRyaWNzLnBlb3BsZSA9IHtcbiAgICAgICAgLyoqIHBlb3BsZS5zZXRfb25jZShkaXN0aW5jdF9pZCwgcHJvcCwgdG8sIGNhbGxiYWNrKVxuICAgICAgICAgICAgLS0tXG4gICAgICAgICAgICBUaGUgc2FtZSBhcyBwZW9wbGUuc2V0IGJ1dCBpbiB0aGUgd29yZHMgb2YgbWl4cGFuZWw6XG4gICAgICAgICAgICBtaXhwYW5lbC5wZW9wbGUuc2V0X29uY2VcblxuICAgICAgICAgICAgXCIgVGhpcyBtZXRob2QgYWxsb3dzIHlvdSB0byBzZXQgYSB1c2VyIGF0dHJpYnV0ZSwgb25seSBpZlxuICAgICAgICAgICAgIGl0IGlzIG5vdCBjdXJyZW50bHkgc2V0LiBJdCBjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzXG4gICAgICAgICAgICAgc2FmZWx5LCBzbyBpcyBwZXJmZWN0IGZvciBzdG9yaW5nIHRoaW5ncyBsaWtlIHRoZSBmaXJzdCBkYXRlXG4gICAgICAgICAgICAgeW91IHNhdyBhIHVzZXIsIG9yIHRoZSByZWZlcnJlciB0aGF0IGJyb3VnaHQgdGhlbSB0byB5b3VyXG4gICAgICAgICAgICAgd2Vic2l0ZSBmb3IgdGhlIGZpcnN0IHRpbWUuIFwiXG5cbiAgICAgICAgKi9cbiAgICAgICAgc2V0X29uY2U6IGZ1bmN0aW9uKGRpc3RpbmN0X2lkLCBwcm9wLCB0bywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciAkc2V0ID0ge30sIGRhdGEgPSB7fTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZihwcm9wKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHRvO1xuICAgICAgICAgICAgICAgICRzZXQgPSBwcm9wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkc2V0W3Byb3BdID0gdG87XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3NldChkaXN0aW5jdF9pZCwgJHNldCwgY2FsbGJhY2ssIHsgc2V0X29uY2U6IHRydWUgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAgICBwZW9wbGUuc2V0KGRpc3RpbmN0X2lkLCBwcm9wLCB0bywgY2FsbGJhY2spXG4gICAgICAgICAgICAtLS1cbiAgICAgICAgICAgIHNldCBwcm9wZXJ0aWVzIG9uIGFuIHVzZXIgcmVjb3JkIGluIGVuZ2FnZVxuXG4gICAgICAgICAgICB1c2FnZTpcblxuICAgICAgICAgICAgICAgIG1peHBhbmVsLnBlb3BsZS5zZXQoJ2JvYicsICdnZW5kZXInLCAnbScpO1xuXG4gICAgICAgICAgICAgICAgbWl4cGFuZWwucGVvcGxlLnNldCgnam9lJywge1xuICAgICAgICAgICAgICAgICAgICAnY29tcGFueSc6ICdhY21lJyxcbiAgICAgICAgICAgICAgICAgICAgJ3BsYW4nOiAncHJlbWl1bSdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbihkaXN0aW5jdF9pZCwgcHJvcCwgdG8sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgJHNldCA9IHt9LCBkYXRhID0ge307XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YocHJvcCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSB0bztcbiAgICAgICAgICAgICAgICAkc2V0ID0gcHJvcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHNldFtwcm9wXSA9IHRvO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9zZXQoZGlzdGluY3RfaWQsICRzZXQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyB1c2VkIGludGVybmFsbHkgYnkgc2V0IGFuZCBzZXRfb25jZVxuICAgICAgICBfc2V0OiBmdW5jdGlvbihkaXN0aW5jdF9pZCwgJHNldCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBzZXRfa2V5ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXRfb25jZSkgPyBcIiRzZXRfb25jZVwiIDogXCIkc2V0XCI7XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgICAgICckdG9rZW4nOiBtZXRyaWNzLnRva2VuLFxuICAgICAgICAgICAgICAgICckZGlzdGluY3RfaWQnOiBkaXN0aW5jdF9pZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRhdGFbc2V0X2tleV0gPSAkc2V0O1xuXG4gICAgICAgICAgICBpZiAoJ2lwJyBpbiAkc2V0KSB7XG4gICAgICAgICAgICAgICAgZGF0YS4kaXAgPSAkc2V0LmlwO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSAkc2V0LmlwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoJHNldC4kaWdub3JlX3RpbWUpIHtcbiAgICAgICAgICAgICAgICBkYXRhLiRpZ25vcmVfdGltZSA9ICRzZXQuJGlnbm9yZV90aW1lO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSAkc2V0LiRpZ25vcmVfdGltZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYobWV0cmljcy5jb25maWcuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNlbmRpbmcgdGhlIGZvbGxvd2luZyBkYXRhIHRvIE1peHBhbmVsIChFbmdhZ2UpOlwiKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWV0cmljcy5zZW5kX3JlcXVlc3QoJy9lbmdhZ2UnLCBkYXRhLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAgICBwZW9wbGUuaW5jcmVtZW50KGRpc3RpbmN0X2lkLCBwcm9wLCB0bywgY2FsbGJhY2spXG4gICAgICAgICAgICAtLS1cbiAgICAgICAgICAgIGluY3JlbWVudC9kZWNyZW1lbnQgcHJvcGVydGllcyBvbiBhbiB1c2VyIHJlY29yZCBpbiBlbmdhZ2VcblxuICAgICAgICAgICAgdXNhZ2U6XG5cbiAgICAgICAgICAgICAgICBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50KCdib2InLCAncGFnZV92aWV3cycsIDEpO1xuXG4gICAgICAgICAgICAgICAgLy8gb3IsIGZvciBjb252ZW5pZW5jZSwgaWYgeW91J3JlIGp1c3QgaW5jcmVtZW50aW5nIGEgY291bnRlciBieSAxLCB5b3UgY2FuXG4gICAgICAgICAgICAgICAgLy8gc2ltcGx5IGRvXG4gICAgICAgICAgICAgICAgbWl4cGFuZWwucGVvcGxlLmluY3JlbWVudCgnYm9iJywgJ3BhZ2Vfdmlld3MnKTtcblxuICAgICAgICAgICAgICAgIC8vIHRvIGRlY3JlbWVudCBhIGNvdW50ZXIsIHBhc3MgYSBuZWdhdGl2ZSBudW1iZXJcbiAgICAgICAgICAgICAgICBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50KCdib2InLCAnY3JlZGl0c19sZWZ0JywgLTEpO1xuXG4gICAgICAgICAgICAgICAgLy8gbGlrZSBtaXhwYW5lbC5wZW9wbGUuc2V0KCksIHlvdSBjYW4gaW5jcmVtZW50IG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZTpcbiAgICAgICAgICAgICAgICBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50KCdib2InLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXIxOiAxLFxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyMjogMyxcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcjM6IC0yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICovXG4gICAgICAgIGluY3JlbWVudDogZnVuY3Rpb24oZGlzdGluY3RfaWQsIHByb3AsIGJ5LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyICRhZGQgPSB7fTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZihwcm9wKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGJ5O1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHByb3ApLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBwcm9wW2tleV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKHBhcnNlRmxvYXQodmFsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRyaWNzLmNvbmZpZy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIGluY3JlbWVudCB2YWx1ZSBwYXNzZWQgdG8gbWl4cGFuZWwucGVvcGxlLmluY3JlbWVudCAtIG11c3QgYmUgYSBudW1iZXJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlBhc3NlZCBcIiArIGtleSArIFwiOlwiICsgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRhZGRba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJ5KSB7IGJ5ID0gMTsgfVxuICAgICAgICAgICAgICAgICRhZGRbcHJvcF0gPSBieTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgJyRhZGQnOiAkYWRkLFxuICAgICAgICAgICAgICAgICckdG9rZW4nOiBtZXRyaWNzLnRva2VuLFxuICAgICAgICAgICAgICAgICckZGlzdGluY3RfaWQnOiBkaXN0aW5jdF9pZFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYobWV0cmljcy5jb25maWcuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNlbmRpbmcgdGhlIGZvbGxvd2luZyBkYXRhIHRvIE1peHBhbmVsIChFbmdhZ2UpOlwiKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWV0cmljcy5zZW5kX3JlcXVlc3QoJy9lbmdhZ2UnLCBkYXRhLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAgICBwZW9wbGUuYXBwZW5kKGRpc3RpbmN0X2lkLCBwcm9wLCB2YWx1ZSwgY2FsbGJhY2spXG4gICAgICAgICAgICAtLS1cbiAgICAgICAgICAgIEFwcGVuZCBhIHZhbHVlIHRvIGEgbGlzdC12YWx1ZWQgcGVvcGxlIGFuYWx5dGljcyBwcm9wZXJ0eS5cblxuICAgICAgICAgICAgdXNhZ2U6XG5cbiAgICAgICAgICAgICAgICAvLyBhcHBlbmQgYSB2YWx1ZSB0byBhIGxpc3QsIGNyZWF0aW5nIGl0IGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIG1peHBhbmVsLnBlb3BsZS5hcHBlbmQoJ3BhZ2VzX3Zpc2l0ZWQnLCAnaG9tZXBhZ2UnKTtcblxuICAgICAgICAgICAgICAgIC8vIGxpa2UgbWl4cGFuZWwucGVvcGxlLnNldCgpLCB5b3UgY2FuIGFwcGVuZCBtdWx0aXBsZSBwcm9wZXJ0aWVzIGF0IG9uY2U6XG4gICAgICAgICAgICAgICAgbWl4cGFuZWwucGVvcGxlLmFwcGVuZCh7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QxOiAnYm9iJyxcbiAgICAgICAgICAgICAgICAgICAgbGlzdDI6IDEyM1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAqL1xuICAgICAgICBhcHBlbmQ6IGZ1bmN0aW9uKGRpc3RpbmN0X2lkLCBwcm9wLCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciAkYXBwZW5kID0ge307XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YocHJvcCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwcm9wKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAkYXBwZW5kW2tleV0gPSBwcm9wW2tleV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRhcHBlbmRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgJyRhcHBlbmQnOiAkYXBwZW5kLFxuICAgICAgICAgICAgICAgICckdG9rZW4nOiBtZXRyaWNzLnRva2VuLFxuICAgICAgICAgICAgICAgICckZGlzdGluY3RfaWQnOiBkaXN0aW5jdF9pZFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYobWV0cmljcy5jb25maWcuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNlbmRpbmcgdGhlIGZvbGxvd2luZyBkYXRhIHRvIE1peHBhbmVsIChFbmdhZ2UpOlwiKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWV0cmljcy5zZW5kX3JlcXVlc3QoJy9lbmdhZ2UnLCBkYXRhLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAgICBwZW9wbGUudHJhY2tfY2hhcmdlKGRpc3RpbmN0X2lkLCBhbW91bnQsIHByb3BlcnRpZXMsIGNhbGxiYWNrKVxuICAgICAgICAgICAgLS0tXG4gICAgICAgICAgICBSZWNvcmQgdGhhdCB5b3UgaGF2ZSBjaGFyZ2VkIHRoZSBjdXJyZW50IHVzZXIgYSBjZXJ0YWluXG4gICAgICAgICAgICBhbW91bnQgb2YgbW9uZXkuXG5cbiAgICAgICAgICAgIHVzYWdlOlxuXG4gICAgICAgICAgICAgICAgLy8gY2hhcmdlIGEgdXNlciAkMjkuOTlcbiAgICAgICAgICAgICAgICBtaXhwYW5lbC5wZW9wbGUudHJhY2tfY2hhcmdlKCdib2InLCAyOS45OSk7XG5cbiAgICAgICAgICAgICAgICAvLyBjaGFyZ2UgYSB1c2VyICQxOSBvbiB0aGUgMXN0IG9mIGZlYnJ1YXJ5XG4gICAgICAgICAgICAgICAgbWl4cGFuZWwucGVvcGxlLnRyYWNrX2NoYXJnZSgnYm9iJywgMTksIHsgJyR0aW1lJzogbmV3IERhdGUoJ2ZlYiAxIDIwMTInKSB9KTtcbiAgICAgICAgKi9cbiAgICAgICAgdHJhY2tfY2hhcmdlOiBmdW5jdGlvbihkaXN0aW5jdF9pZCwgYW1vdW50LCBwcm9wZXJ0aWVzLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyICRhcHBlbmQgPSB7fTtcblxuICAgICAgICAgICAgaWYgKCFwcm9wZXJ0aWVzKSB7IHByb3BlcnRpZXMgPSB7fTsgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mKGFtb3VudCkgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgYW1vdW50ID0gcGFyc2VGbG9hdChhbW91bnQpO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihhbW91bnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIHZhbHVlIHBhc3NlZCB0byBtaXhwYW5lbC5wZW9wbGUudHJhY2tfY2hhcmdlIC0gbXVzdCBiZSBhIG51bWJlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvcGVydGllcy4kYW1vdW50ID0gYW1vdW50O1xuXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSgnJHRpbWUnKSkge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lID0gcHJvcGVydGllcy4kdGltZTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRpbWUpID09PSAnW29iamVjdCBEYXRlXScpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcy4kdGltZSA9IHRpbWUudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgICAgICckYXBwZW5kJzogeyAnJHRyYW5zYWN0aW9ucyc6IHByb3BlcnRpZXMgfSxcbiAgICAgICAgICAgICAgICAnJHRva2VuJzogbWV0cmljcy50b2tlbixcbiAgICAgICAgICAgICAgICAnJGRpc3RpbmN0X2lkJzogZGlzdGluY3RfaWRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmKG1ldHJpY3MuY29uZmlnLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTZW5kaW5nIHRoZSBmb2xsb3dpbmcgZGF0YSB0byBNaXhwYW5lbCAoRW5nYWdlKTpcIik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1ldHJpY3Muc2VuZF9yZXF1ZXN0KCcvZW5nYWdlJywgZGF0YSwgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgcGVvcGxlLmNsZWFyX2NoYXJnZXMoZGlzdGluY3RfaWQsIGNhbGxiYWNrKVxuICAgICAgICAgICAgLS0tXG4gICAgICAgICAgICBDbGVhciBhbGwgdGhlIGN1cnJlbnQgdXNlcidzIHRyYW5zYWN0aW9ucy5cblxuICAgICAgICAgICAgdXNhZ2U6XG5cbiAgICAgICAgICAgICAgICBtaXhwYW5lbC5wZW9wbGUuY2xlYXJfY2hhcmdlcygnYm9iJyk7XG4gICAgICAgICovXG4gICAgICAgIGNsZWFyX2NoYXJnZXM6IGZ1bmN0aW9uKGRpc3RpbmN0X2lkLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgJyRzZXQnOiB7ICckdHJhbnNhY3Rpb25zJzogW10gfSxcbiAgICAgICAgICAgICAgICAnJHRva2VuJzogbWV0cmljcy50b2tlbixcbiAgICAgICAgICAgICAgICAnJGRpc3RpbmN0X2lkJzogZGlzdGluY3RfaWRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmKG1ldHJpY3MuY29uZmlnLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJDbGVhcmluZyB0aGlzIHVzZXIncyBjaGFyZ2VzOlwiLCBkaXN0aW5jdF9pZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1ldHJpY3Muc2VuZF9yZXF1ZXN0KCcvZW5nYWdlJywgZGF0YSwgY2FsbGJhY2spO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgcGVvcGxlLmRlbGV0ZV91c2VyKGRpc3RpbmN0X2lkLCBjYWxsYmFjaylcbiAgICAgICAgICAgIC0tLVxuICAgICAgICAgICAgZGVsZXRlIGFuIHVzZXIgcmVjb3JkIGluIGVuZ2FnZVxuXG4gICAgICAgICAgICB1c2FnZTpcblxuICAgICAgICAgICAgICAgIG1peHBhbmVsLnBlb3BsZS5kZWxldGVfdXNlcignYm9iJyk7XG4gICAgICAgICovXG4gICAgICAgIGRlbGV0ZV91c2VyOiBmdW5jdGlvbihkaXN0aW5jdF9pZCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgICAgICckZGVsZXRlJzogZGlzdGluY3RfaWQsXG4gICAgICAgICAgICAgICAgJyR0b2tlbic6IG1ldHJpY3MudG9rZW4sXG4gICAgICAgICAgICAgICAgJyRkaXN0aW5jdF9pZCc6IGRpc3RpbmN0X2lkXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZihtZXRyaWNzLmNvbmZpZy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRGVsZXRpbmcgdGhlIHVzZXIgZnJvbSBlbmdhZ2U6XCIsIGRpc3RpbmN0X2lkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWV0cmljcy5zZW5kX3JlcXVlc3QoJy9lbmdhZ2UnLCBkYXRhLCBjYWxsYmFjayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICBwZW9wbGUudW5zZXQoZGlzdGluY3RfaWQsIHByb3AsIGNhbGxiYWNrKVxuICAgICAgICAgLS0tXG4gICAgICAgICBkZWxldGUgYSBwcm9wZXJ0eSBvbiBhbiB1c2VyIHJlY29yZCBpbiBlbmdhZ2VcblxuICAgICAgICAgdXNhZ2U6XG5cbiAgICAgICAgICAgIG1peHBhbmVsLnBlb3BsZS51bnNldCgnYm9iJywgJ3BhZ2Vfdmlld3MnKTtcblxuICAgICAgICAgICAgbWl4cGFuZWwucGVvcGxlLnVuc2V0KCdib2InLCBbJ3BhZ2Vfdmlld3MnLCAnbGFzdF9sb2dpbiddKTtcbiAgICAgICAgICovXG4gICAgICAgIHVuc2V0OiBmdW5jdGlvbihkaXN0aW5jdF9pZCwgcHJvcCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciAkdW5zZXQgPSBbXTtcblxuICAgICAgICAgICAgaWYgKHV0aWwuaXNBcnJheShwcm9wKSkge1xuICAgICAgICAgICAgICAgICR1bnNldCA9IHByb3A7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihwcm9wKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAkdW5zZXQgPSBbcHJvcF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChtZXRyaWNzLmNvbmZpZy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgdG8gbWl4cGFuZWwucGVvcGxlLnVuc2V0IC0gbXVzdCBiZSBhIHN0cmluZyBvciBhcnJheVwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlBhc3NlZDogXCIgKyBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgICckdW5zZXQnOiAkdW5zZXQsXG4gICAgICAgICAgICAgICAgJyR0b2tlbic6IG1ldHJpY3MudG9rZW4sXG4gICAgICAgICAgICAgICAgJyRkaXN0aW5jdF9pZCc6IGRpc3RpbmN0X2lkXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZihtZXRyaWNzLmNvbmZpZy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2VuZGluZyB0aGUgZm9sbG93aW5nIGRhdGEgdG8gTWl4cGFuZWwgKEVuZ2FnZSk6XCIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZXRyaWNzLnNlbmRfcmVxdWVzdCgnL2VuZ2FnZScsIGRhdGEsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgICAgc2V0X2NvbmZpZyhjb25maWcpXG4gICAgICAgIC0tLVxuICAgICAgICBNb2RpZmllcyB0aGUgbWl4cGFuZWwgY29uZmlnXG5cbiAgICAgICAgY29uZmlnOm9iamVjdCAgICAgICBhbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHRvIG92ZXJyaWRlIGluIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1peHBhbmVsIGNsaWVudCBjb25maWdcbiAgICAqL1xuICAgIG1ldHJpY3Muc2V0X2NvbmZpZyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICBtZXRyaWNzLmNvbmZpZyA9IF9leHRlbmQobWV0cmljcy5jb25maWcsIGNvbmZpZyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAgICBfZXh0ZW5kKG9iajEsIG9iajIpXG4gICAgICAgIC0tLVxuICAgICAgICBDb3BpZXMgcHJvcGVydGllcyBmcm9tIG9iajIgdG8gb2JqMVxuICAgICovXG5cbiAgICBfZXh0ZW5kID0gZnVuY3Rpb24ob2JqMSwgb2JqMikge1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iajIpIHtcbiAgICAgICAgICAgIGlmIChvYmoyLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgb2JqMVtwcm9wXSA9IG9iajJbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqMTtcbiAgICB9O1xuXG5cbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgIG1ldHJpY3Muc2V0X2NvbmZpZyhjb25maWcpO1xuICAgIH1cblxuICAgIHJldHVybiBtZXRyaWNzO1xufTtcblxuLy8gbW9kdWxlIGV4cG9ydGluZ1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQ2xpZW50OiBmdW5jdGlvbih0b2tlbikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgZnVuY3Rpb24gYENsaWVudCh0b2tlbilgIGlzIGRlcHJlY2F0ZWQuICBJdCBpcyBub3cgY2FsbGVkIGBpbml0KHRva2VuKWAuXCIpO1xuICAgICAgICByZXR1cm4gY3JlYXRlX2NsaWVudCh0b2tlbik7XG4gICAgfSxcbiAgICBpbml0OiBjcmVhdGVfY2xpZW50XG59O1xuIl19
